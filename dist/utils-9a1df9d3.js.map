{"version":3,"file":"utils-9a1df9d3.js","sources":["../src/order-signing/utils.ts"],"sourcesContent":["import type {\n  Order as OrderFromContract,\n  Signature,\n  TypedDataDomain,\n  EcdsaSigningScheme as EcdsaSigningSchemeContract,\n} from '@wowswapfork/contracts'\nimport {\n  domain as domainGp,\n  EcdsaSignature,\n  IntChainIdTypedDataV4Signer,\n  SigningScheme,\n  signOrder as signOrderGp,\n  signOrderCancellation as signOrderCancellationGp,\n  signOrderCancellations as signOrderCancellationsGp,\n  TypedDataVersionedSigner,\n} from '@wowswapfork/contracts'\nimport type { Signer } from '@ethersproject/abstract-signer'\nimport type { SigningResult, SignOrderParams, SignOrderCancellationParams, UnsignedOrder } from './types'\n\nimport { COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS } from '../common/consts'\nimport { CowError, SupportedChainId } from '../common'\nimport { EcdsaSigningScheme } from '../order-book'\nimport { SignOrderCancellationsParams } from './types'\n\n// For error codes, see:\n// - https://eth.wiki/json-rpc/json-rpc-error-codes-improvement-proposal\n// - https://www.jsonrpc.org/specification#error_object\nconst METAMASK_SIGNATURE_ERROR_CODE = -32603\nconst METHOD_NOT_FOUND_ERROR_CODE = -32601\n// Added the following because of 1Inch wallet who doesn't send the error code\n// So we will check the actual error text\nconst METHOD_NOT_FOUND_ERROR_MSG_REGEX = /Method not found/i\nconst V4_ERROR_MSG_REGEX = /eth_signTypedData_v4 does not exist/i\nconst V3_ERROR_MSG_REGEX = /eth_signTypedData_v3 does not exist/i\nconst RPC_REQUEST_FAILED_REGEX = /RPC request failed/i\nconst METAMASK_STRING_CHAINID_REGEX = /provided chainid .* must match the active chainid/i\n\nconst mapSigningSchema: Record<EcdsaSigningScheme, EcdsaSigningSchemeContract> = {\n  [EcdsaSigningScheme.EIP712]: SigningScheme.EIP712,\n  [EcdsaSigningScheme.ETHSIGN]: SigningScheme.ETHSIGN,\n}\n\ninterface ProviderRpcError extends Error {\n  message: string\n  code: number\n  data?: unknown\n}\n\ntype PayloadParams =\n  | Pick<SignOrderParams, 'order' & 'chainId'>\n  | Pick<SignOrderCancellationParams, 'chainId' & 'orderId'>\n  | Pick<SignOrderCancellationsParams, 'chainId' & 'orderUids'>\n\nfunction isProviderRpcError(error: unknown): error is ProviderRpcError {\n  return (error as ProviderRpcError).code !== undefined || (error as ProviderRpcError).message !== undefined\n}\n\nasync function _signOrder(params: SignOrderParams): Promise<Signature> {\n  const { chainId, signer, order, signingScheme } = params\n\n  const domain = getDomain(chainId)\n\n  return signOrderGp(domain, order as OrderFromContract, signer, mapSigningSchema[signingScheme])\n}\n\nasync function _signOrderCancellation(params: SignOrderCancellationParams): Promise<Signature> {\n  const { chainId, signer, signingScheme, orderUid } = params\n\n  const domain = getDomain(chainId)\n\n  return signOrderCancellationGp(domain, orderUid, signer, mapSigningSchema[signingScheme])\n}\n\nasync function _signOrderCancellations(params: SignOrderCancellationsParams): Promise<Signature> {\n  const { chainId, signer, signingScheme, orderUids } = params\n\n  const domain = getDomain(chainId)\n\n  return signOrderCancellationsGp(domain, orderUids, signer, mapSigningSchema[signingScheme])\n}\n\nasync function _signPayload(\n  payload: PayloadParams,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  signFn: (params: any) => Promise<Signature>,\n  signer: Signer,\n  signingMethod: 'default' | 'v4' | 'int_v4' | 'v3' | 'eth_sign' = 'v4'\n): Promise<SigningResult> {\n  const signingScheme: EcdsaSigningScheme =\n    signingMethod === 'eth_sign' ? EcdsaSigningScheme.ETHSIGN : EcdsaSigningScheme.EIP712\n  let signature: Signature | null = null\n\n  let _signer\n  try {\n    switch (signingMethod) {\n      case 'default':\n      case 'v3':\n        _signer = new TypedDataVersionedSigner(signer)\n        break\n      case 'int_v4':\n        _signer = new IntChainIdTypedDataV4Signer(signer)\n        break\n      default:\n        _signer = signer\n    }\n  } catch (e) {\n    console.error('Wallet not supported:', e)\n    throw new CowError('Wallet not supported')\n  }\n\n  try {\n    signature = (await signFn({ ...payload, signer: _signer, signingScheme })) as EcdsaSignature // Only ECDSA signing supported for now\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    if (!isProviderRpcError(e)) {\n      // Some other error signing. Let it bubble up.\n      console.error(e)\n      throw e\n    }\n\n    const regexErrorCheck = [METHOD_NOT_FOUND_ERROR_MSG_REGEX, RPC_REQUEST_FAILED_REGEX].some((regex) =>\n      // for example 1Inch error doesn't have e.message so we will check the output of toString()\n      [e.message, e.toString()].some((msg) => regex.test(msg))\n    )\n\n    if (e.code === METHOD_NOT_FOUND_ERROR_CODE || regexErrorCheck) {\n      // Maybe the wallet returns the proper error code? We can only hope ðŸ¤ž\n      // OR it failed with a generic message, there's no error code set, and we also hope it'll work\n      // with other methods...\n      switch (signingMethod) {\n        case 'v4':\n          return _signPayload(payload, signFn, signer, 'default')\n        case 'default':\n          return _signPayload(payload, signFn, signer, 'v3')\n        case 'v3':\n          return _signPayload(payload, signFn, signer, 'eth_sign')\n        default:\n          throw e\n      }\n    } else if (METAMASK_STRING_CHAINID_REGEX.test(e.message)) {\n      // Metamask now enforces chainId to be an integer\n      return _signPayload(payload, signFn, signer, 'int_v4')\n    } else if (e.code === METAMASK_SIGNATURE_ERROR_CODE) {\n      // We tried to sign order the nice way.\n      // That works fine for regular MM addresses. Does not work for Hardware wallets, though.\n      // See https://github.com/MetaMask/metamask-extension/issues/10240#issuecomment-810552020\n      // So, when that specific error occurs, we know this is a problem with MM + HW.\n      // Then, we fallback to ETHSIGN.\n      return _signPayload(payload, signFn, signer, 'eth_sign')\n    } else if (V4_ERROR_MSG_REGEX.test(e.message)) {\n      // Failed with `v4`, and the wallet does not set the proper error code\n      return _signPayload(payload, signFn, signer, 'v3')\n    } else if (V3_ERROR_MSG_REGEX.test(e.message)) {\n      // Failed with `v3`, and the wallet does not set the proper error code\n      return _signPayload(payload, signFn, signer, 'eth_sign')\n    } else {\n      // Some other error signing. Let it bubble up.\n      console.error(e)\n      throw e\n    }\n  }\n\n  const data: unknown = signature?.data\n\n  return { signature: data?.toString() || '', signingScheme }\n}\n\n/**\n * Returns the signature for the specified order with the signing scheme encoded\n * into the signature.\n * @param {UnsignedOrder} order The order to sign.\n * @param {SupportedChainId} chainId The chain Id\n * @param {Signer} signer The owner for the order used to sign.\n * @return {*} Encoded signature including signing scheme for the order.\n */\nexport async function signOrder(\n  order: UnsignedOrder,\n  chainId: SupportedChainId,\n  signer: Signer\n): Promise<SigningResult> {\n  return _signPayload({ order, chainId }, _signOrder, signer)\n}\n\n/**\n * Returns the signature for the Order Cancellation with the signing scheme encoded\n * into the signature.\n * @param {string} orderUid The unique identifier of the order being cancelled.\n * @param {SupportedChainId} chainId The chain Id\n * @param {Signer} signer The owner for the order used to sign.\n * @return {*} Encoded signature including signing scheme for the order.\n */\nexport async function signOrderCancellation(\n  orderUid: string,\n  chainId: SupportedChainId,\n  signer: Signer\n): Promise<SigningResult> {\n  return _signPayload({ orderUid, chainId }, _signOrderCancellation, signer)\n}\n\n/**\n * Returns the signature for the Order Cancellations with the signing scheme encoded\n * into the signature.\n *\n * @param {string[]} orderUids The unique identifiers of the orders being cancelled.\n * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n * @param {Signer} signer The owner that had placed the orders used to sign.\n * @returns {*} Encoded signature including signing scheme for the order.\n */\nexport async function signOrderCancellations(\n  orderUids: string[],\n  chainId: SupportedChainId,\n  signer: Signer\n): Promise<SigningResult> {\n  return _signPayload({ orderUids, chainId }, _signOrderCancellations, signer)\n}\n\n/**\n * Returns the TypedDataDomain used for signing for the specified chainId.\n * @param {SupportedChainId} chainId The chain Id\n * @return {*} The TypedDataDomain for the specified chainId.\n * @throws {CowError} If the chainId is not supported.\n */\nexport function getDomain(chainId: SupportedChainId): TypedDataDomain {\n  // Get settlement contract address\n  const settlementContract = COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS[chainId]\n\n  if (!settlementContract) {\n    throw new CowError('Unsupported network. Settlement contract is not deployed')\n  }\n\n  return domainGp(chainId, settlementContract)\n}\n"],"names":["_signPayload","payload","signFn","signer","signingMethod","_exit","_temp2","_result","data","signature","toString","signingScheme","EcdsaSigningScheme","ETHSIGN","EIP712","_signer","TypedDataVersionedSigner","IntChainIdTypedDataV4Signer","e","console","error","CowError","_temp","Promise","resolve","then","_signFn","_catch","undefined","code","message","regexErrorCheck","METHOD_NOT_FOUND_ERROR_MSG_REGEX","RPC_REQUEST_FAILED_REGEX","some","regex","msg","test","METHOD_NOT_FOUND_ERROR_CODE","METAMASK_STRING_CHAINID_REGEX","_signPayload5","METAMASK_SIGNATURE_ERROR_CODE","_signPayload6","V4_ERROR_MSG_REGEX","_signPayload7","V3_ERROR_MSG_REGEX","_signPayload8","_signPayload2","_signPayload3","_signPayload4","reject","_signOrderCancellations","params","chainId","orderUids","domain","getDomain","signOrderCancellationsGp","signOrderCancellations","mapSigningSchema","_signOrderCancellation","orderUid","signOrderCancellationGp","_signOrder","order","signOrderGp","signOrder","SigningScheme","settlementContract","COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS","domainGp"],"mappings":"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"}