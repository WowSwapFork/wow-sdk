{"version":3,"file":"index-29756f86.js","sources":["../src/common/chains.ts","../src/common/configs.ts","../src/common/cow-error.ts","../src/common/consts.ts","../src/order-book/transformOrder.ts","../src/order-book/request.ts","../src/order-book/api.ts","../src/order-book/generated/models/BuyTokenDestination.ts","../src/order-book/generated/models/EcdsaSigningScheme.ts","../src/order-book/generated/models/OnchainOrderData.ts","../src/order-book/generated/models/OrderCancellationError.ts","../src/order-book/generated/models/OrderClass.ts","../src/order-book/generated/models/OrderKind.ts","../src/order-book/generated/models/OrderPostError.ts","../src/order-book/generated/models/OrderStatus.ts","../src/order-book/generated/models/PriceEstimationError.ts","../src/order-book/generated/models/PriceQuality.ts","../src/order-book/generated/models/ReplaceOrderError.ts","../src/order-book/generated/models/SellTokenSource.ts","../src/order-book/generated/models/SigningScheme.ts","../src/order-book/generated/models/OrderQuoteSideKindBuy.ts","../src/order-book/generated/models/OrderQuoteSideKindSell.ts","../src/subgraph/queries.ts","../src/subgraph/api.ts","../src/order-signing/orderSigningUtils.ts","../src/composable/types.ts","../src/composable/generated/factories/ComposableCoW__factory.ts","../src/composable/generated/factories/ExtensibleFallbackHandler__factory.ts","../node_modules/@wowswapfork/contracts/lib/esm/order.js","../node_modules/node-fetch/browser.js","../node_modules/@wowswapfork/contracts/lib/esm/interaction.js","../node_modules/@wowswapfork/contracts/lib/esm/types/ethers.js","../node_modules/@wowswapfork/contracts/lib/esm/sign.js","../node_modules/@wowswapfork/contracts/lib/esm/settlement.js","../node_modules/@wowswapfork/contracts/lib/esm/api.js","../node_modules/@wowswapfork/contracts/lib/esm/deploy.js","../node_modules/@wowswapfork/contracts/lib/esm/proxy.js","../node_modules/@wowswapfork/contracts/lib/esm/vault.js","../src/composable/utils.ts","../src/composable/contracts.ts","../src/composable/ConditionalOrder.ts","../src/utils.ts","../src/composable/Multiplexer.ts","../src/composable/orderTypes/Twap.ts","../src/composable/orderTypes/index.ts","../src/composable/ConditionalOrderFactory.ts","../src/common/ipfs.ts"],"sourcesContent":["/**\n * Supported chains and their `chainId` for the SDK.\n * @enum\n */\nexport enum SupportedChainId {\n  MAINNET = 1,\n  GOERLI = 5,\n  GNOSIS_CHAIN = 100,\n  MUMBAI=80001\n}\n","import { SupportedChainId } from './chains'\nimport { BackoffOptions } from 'exponential-backoff'\nimport { RateLimiterOpts } from 'limiter/dist/esm'\n\n/**\n * IPFS configuration.\n *\n * For production use, consider using {@link Pinata: https://www.pinata.cloud/}\n * @property {string} [uri] The URI of the IPFS node to use.\n * @property {string} [writeUri] The URI of the IPFS node to use for writing.\n * @property {string} [readUri] The URI of the IPFS node to use for reading.\n * @property {string} [pinataApiKey] The API key to use for Pinata.\n * @property {string} [pinataApiSecret] The API secret to use for Pinata.\n */\nexport interface IpfsConfig {\n  uri?: string\n  writeUri?: string\n  readUri?: string\n  pinataApiKey?: string\n  pinataApiSecret?: string\n}\n\n/**\n * @property {RateLimiterOpts} [limiterOpts] The options to use for the rate limiter.\n * @property {BackoffOptions} [backoffOpts] The options to use for the backoff.\n */\nexport interface RequestOptions {\n  limiterOpts?: RateLimiterOpts\n  backoffOpts?: BackoffOptions\n}\n\n/**\n * The environment to use for the Cow API.\n */\nexport type CowEnv = 'prod' | 'staging'\n\n/**\n * Override some properties of the {@link ApiContext}.\n */\nexport type PartialApiContext = Partial<ApiContext>\n\n/**\n * @property {string} [1] The base URL for the mainnet API.\n * @property {string} [5] The base URL for the Goerli testnet API.\n * @property {string} [100] The base URL for the Gnosis Chain API.\n */\nexport type ApiBaseUrls = Record<SupportedChainId, string>\n\n/**\n * Define the context to use for the CoW Protocol API.\n *\n * CoW Protocol is a set of smart contracts and off-chain services, deployed on **multiple chains**.\n * {@link SupportedChainId Supported chains} are:\n * - Mainnet\n * - Goerli\n * - Gnosis Chain\n *\n * Each chain has it's own API, and each API has it's own base URL.\n *\n * Options may be selectively overridden by passing a {@link PartialApiContext} to the constructor.\n * @see {@link https://api.cow.fi/docs/#/}\n * @property {SupportedChainId} chainId The `chainId`` corresponding to this CoW Protocol API instance.\n * @property {CowEnv} env The environment that this context corresponds to.\n * @property {ApiBaseUrls} [baseUrls] URls that may be used to connect to this context.\n */\nexport interface ApiContext {\n  chainId: SupportedChainId\n  env: CowEnv\n  baseUrls?: ApiBaseUrls\n}\n\n/**\n * The list of available environments.\n */\nexport const ENVS_LIST: CowEnv[] = ['prod', 'staging']\n\n/**\n * The default CoW Protocol API context.\n */\nexport const DEFAULT_COW_API_CONTEXT: ApiContext = {\n  env: 'prod',\n  chainId: SupportedChainId.MAINNET,\n}\n","export class CowError extends Error {\n  error_code?: string\n\n  constructor(message: string, error_code?: string) {\n    super(message)\n    this.error_code = error_code\n  }\n}\n\nexport const logPrefix = 'cow-sdk:'\n","import { SupportedChainId } from './chains'\nimport contractNetworks from '@wowswapfork/contracts/networks.json'\nconst { GPv2Settlement } = JSON.parse(contractNetworks as unknown as string) as typeof contractNetworks\n\nexport const BUY_ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'\nexport const EXTENSIBLE_FALLBACK_HANDLER = '0x2f55e8b20D0B9FEFA187AA7d00B6Cbe563605bF5'\nexport const COMPOSABLE_COW = '0x5d84eB96e4D57fB2a7945f32be7401237eD243ad'\n\n/**\n * The list of supported chains.\n */\nexport const ALL_SUPPORTED_CHAIN_IDS: SupportedChainId[] = [\n  SupportedChainId.MAINNET,\n  SupportedChainId.GOERLI,\n  SupportedChainId.GNOSIS_CHAIN,\n  SupportedChainId.MUMBAI,\n\n]\n\n/**\n * An object containing the addresses of the CoW Protocol settlement contracts for each supported chain.\n */\nexport const COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: GPv2Settlement[chainId].address,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ExtensibleFallbackHandler` contracts for each supported chain.\n */\nexport const EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: EXTENSIBLE_FALLBACK_HANDLER,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ComposableCow` contracts for each supported chain.\n */\nexport const COMPOSABLE_COW_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: COMPOSABLE_COW,\n  }),\n  {}\n)\n","import { BUY_ETH_ADDRESS } from '../common/consts'\nimport { Order } from './generated'\nimport { EnrichedOrder } from './types'\n\n/**\n * Apply programmatic transformations to an order.\n *\n * For example, transformations may be applied to an order to recognise it as a Native EthFlow order.\n * @param order to apply transformations to\n * @returns An order with the total fee added.\n */\nexport function transformOrder(order: Order): EnrichedOrder {\n  return transformEthFlowOrder(addTotalFeeToOrder(order))\n}\n\n/**\n * Add the total fee to the order.\n *\n * The `executedSurplusFee` represents exactly the fee that was charged (regardless of the fee\n * signed with the order). So, while the protocol currently does not allow placing a limit order\n * with any other fee than 0 - the backend is designed to support these kinds of orders for the\n * future.\n * @param dto The order to add the total fee to.\n * @returns The order with the total fee added.\n */\nfunction addTotalFeeToOrder(dto: Order): EnrichedOrder {\n  const { executedFeeAmount, executedSurplusFee } = dto\n  const totalFee = executedSurplusFee ?? executedFeeAmount\n\n  return {\n    ...dto,\n    totalFee,\n  }\n}\n\n/**\n * Transform order field for Native EthFlow orders\n *\n * A no-op for regular orders\n * For Native EthFlow, due to how the contract is setup:\n * - sellToken set to Native token address\n * - owner set to `onchainUser`\n * - validTo set to `ethflowData.userValidTo`\n */\nfunction transformEthFlowOrder(order: EnrichedOrder): EnrichedOrder {\n  const { ethflowData } = order\n\n  if (!ethflowData) {\n    return order\n  }\n\n  const { userValidTo: validTo } = ethflowData\n  const owner = order.onchainUser || order.owner\n  const sellToken = BUY_ETH_ADDRESS\n\n  return { ...order, validTo, owner, sellToken }\n}\n","import { backOff, BackoffOptions } from 'exponential-backoff'\nimport { RateLimiter, RateLimiterOpts } from 'limiter'\n\n/**\n * Error thrown when the CoW Protocol OrderBook API returns an error.\n */\nexport class OrderBookApiError<T = unknown> extends Error {\n  /**\n   * Error thrown when the CoW Protocol OrderBook API returns an error.\n   * @param response The response from the CoW Protocol OrderBook API.\n   * @param body The body of the response.\n   * @constructor\n   */\n  constructor(public readonly response: Response, public readonly body: T) {\n    super(typeof body === 'string' ? body : response.statusText)\n  }\n}\n\nconst REQUEST_TIMEOUT = 408\nconst TOO_EARLY = 425\nconst TOO_MANY_REQUESTS = 429\nconst INTERNAL_SERVER_ERROR = 500\nconst BAD_GATEWAY = 502\nconst SERVICE_UNAVAILABLE = 503\nconst GATEWAY_TIMEOUT = 504\n\nconst STATUS_CODES_TO_RETRY = [\n  REQUEST_TIMEOUT,\n  TOO_EARLY,\n  TOO_MANY_REQUESTS,\n  INTERNAL_SERVER_ERROR,\n  BAD_GATEWAY,\n  SERVICE_UNAVAILABLE,\n  GATEWAY_TIMEOUT,\n]\n\n/**\n * The default backoff options for CoW Protocol's API\n * @see {@link Backoff configuration: https://www.npmjs.com/package/@insertish/exponential-backoff}\n */\nexport const DEFAULT_BACKOFF_OPTIONS: BackoffOptions = {\n  numOfAttempts: 10,\n  maxDelay: Infinity,\n  jitter: 'none',\n  retry: (error: Error | OrderBookApiError) => {\n    if (error instanceof OrderBookApiError) {\n      return STATUS_CODES_TO_RETRY.includes(error.response.status)\n    }\n\n    return true\n  },\n}\n\n/**\n * The default rate limiter options for CoW Protocol's API.\n *\n * **CAUTION**: The CoW Protocol OrderBook API is limited to 5 requests per second per IP.\n */\nexport const DEFAULT_LIMITER_OPTIONS: RateLimiterOpts = {\n  tokensPerInterval: 5,\n  interval: 'second',\n}\n\n/**\n * Describe the parameters for a fetch request.\n */\nexport interface FetchParams {\n  path: string\n  method: 'GET' | 'POST' | 'DELETE' | 'PUT'\n  body?: unknown\n  query?: URLSearchParams\n}\n\nconst getResponseBody = async (response: Response): Promise<unknown> => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get('Content-Type')\n      if (contentType) {\n        if (contentType.toLowerCase().startsWith('application/json')) {\n          return await response.json()\n        } else {\n          return await response.text()\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  return undefined\n}\n\n/**\n * Helper function to make a rate-limited request to an API.\n * @param baseUrl The base URL of the API.\n * @param path The path of the request.\n * @param query The query parameters of the request.\n * @param method The HTTP method of the request.\n * @param body The body of the request.\n * @param rateLimiter The rate limiter to use.\n * @param backoffOpts The backoff options to use.\n * @returns The response of the request.\n * @throws If the API returns an error or if the request fails.\n */\nexport async function request<T>(\n  baseUrl: string,\n  { path, query, method, body }: FetchParams,\n  rateLimiter: RateLimiter,\n  backoffOpts: BackoffOptions\n): Promise<T> {\n  const queryString = query ? '?' + query : ''\n  const headers = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  }\n\n  const url = `${baseUrl}${path}${queryString}`\n  const bodyContent = (() => {\n    if (!body) return undefined\n\n    return typeof body === 'string' ? body : JSON.stringify(body)\n  })()\n  const init: RequestInit = {\n    method,\n    body: bodyContent,\n    headers,\n  }\n\n  return backOff<T>(async () => {\n    await rateLimiter.removeTokens(1)\n\n    const response = await fetch(url, init)\n    const responseBody = (await getResponseBody(response)) as T\n\n    // Successful response\n    if (response.status >= 200 && response.status < 300) {\n      return responseBody\n    }\n\n    return Promise.reject(new OrderBookApiError(response, responseBody))\n  }, backoffOpts)\n}\n","import 'cross-fetch/polyfill'\nimport {\n  Address,\n  AppDataHash,\n  AppDataObject,\n  NativePriceResponse,\n  Order,\n  OrderCancellations,\n  OrderCreation,\n  OrderQuoteRequest,\n  OrderQuoteResponse,\n  SolverCompetitionResponse,\n  TotalSurplus,\n  Trade,\n  TransactionHash,\n  UID,\n} from './generated'\nimport { CowError } from '../common/cow-error'\nimport {\n  ApiBaseUrls,\n  ApiContext,\n  CowEnv,\n  DEFAULT_COW_API_CONTEXT,\n  ENVS_LIST,\n  PartialApiContext,\n  RequestOptions,\n} from '../common/configs'\nimport { transformOrder } from './transformOrder'\nimport { EnrichedOrder } from './types'\nimport { SupportedChainId } from '../common/chains'\nimport { RateLimiter } from 'limiter'\nimport { DEFAULT_BACKOFF_OPTIONS, DEFAULT_LIMITER_OPTIONS, FetchParams, OrderBookApiError, request } from './request'\n\n/**\n * An object containing *production* environment base URLs for each supported `chainId`.\n * @see {@link https://api.cow.fi/docs/#/}\n */\nexport const ORDER_BOOK_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n}\n\n/**\n * An object containing *staging* environment base URLs for each supported `chainId`.\n */\nexport const ORDER_BOOK_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://barn.api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://barn.api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://barn.api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n\n}\n\nfunction cleanObjectFromUndefinedValues(obj: Record<string, string>): typeof obj {\n  return Object.keys(obj).reduce((acc, key) => {\n    const val = obj[key]\n    if (typeof val !== 'undefined') acc[key] = val\n    return acc\n  }, {} as typeof obj)\n}\n\n/**\n * The parameters for the `getOrders` request.\n */\nexport type GetOrdersRequest = {\n  owner: Address\n  offset?: number\n  limit?: number\n}\n\n/**\n * The CoW Protocol OrderBook API client.\n *\n * This is the main entry point for interacting with the CoW Protocol OrderBook API. The main advantage of using\n * this client is the batteries-included approach to interacting with the API. It handles:\n *\n * - Environment configuration (mainnet, staging, etc.)\n * - Rate limiting\n * - Retries\n * - Backoff\n * - Error handling\n * - Request signing\n * - Request validation\n *\n * @example\n *\n * ```typescript\n * import { OrderBookApi, OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * const quoteRequest = {\n *   sellToken: '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6', // WETH goerli\n *   buyToken: '0x02abbdbaaa7b1bb64b5c878f7ac17f8dda169532', // GNO goerli\n *   from: account,\n *   receiver: account,\n *   sellAmountBeforeFee: (0.4 * 10 ** 18).toString(), // 0.4 WETH\n *   kind: OrderQuoteSide.kind.SELL,\n * }\n *\n * const orderBookApi = new OrderBookApi({ chainId: SupportedChainId.GOERLI })\n *\n * async function main() {\n *     const { quote } = await orderBookApi.getQuote(quoteRequest)\n *\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n *\n * @see {@link Swagger documentation https://api.cow.fi/docs/#/}\n * @see {@link OrderBook API https://github.com/cowprotocol/services}\n */\nexport class OrderBookApi {\n  public context: ApiContext & RequestOptions\n\n  private rateLimiter: RateLimiter\n\n  /**\n   * Creates a new instance of the CoW Protocol OrderBook API client.\n   * @param context - The API context to use. If not provided, the default context will be used.\n   */\n  constructor(context: PartialApiContext & RequestOptions = {}) {\n    this.context = { ...DEFAULT_COW_API_CONTEXT, ...context }\n    this.rateLimiter = new RateLimiter(context.limiterOpts || DEFAULT_LIMITER_OPTIONS)\n  }\n\n  /**\n   * Get the version of the API.\n   * @param contextOverride Optional context override for this request.\n   * @returns The version of the API.\n   * @see {@link https://api.cow.fi/docs/#/default/get_api_v1_version}\n   */\n  getVersion(contextOverride: PartialApiContext = {}): Promise<string> {\n    return this.fetch({ path: '/api/v1/version', method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Get all the trades for either an `owner` **OR** `orderUid`.\n   *\n   * Given that an order *may* be partially fillable, it is possible that a discrete order (`orderUid`)\n   * may have *multiple* trades. Therefore, this method returns a list of trades, either for *all* the orders\n   * of a given `owner`, or for a discrete order (`orderUid`).\n   * @param request Either an `owner` or an `orderUid` **MUST** be specified.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of trades matching the request.\n   */\n  getTrades(\n    request: { owner?: Address; orderUid?: UID },\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<Trade>> {\n    if (request.owner && request.orderUid) {\n      return Promise.reject(new CowError('Cannot specify both owner and orderId'))\n    } else if (!request.owner && !request.orderUid) {\n      return Promise.reject(new CowError('Must specify either owner or orderId'))\n    }\n\n    const query = new URLSearchParams(cleanObjectFromUndefinedValues(request))\n\n    return this.fetch({ path: '/api/v1/trades', method: 'GET', query }, contextOverride)\n  }\n\n  /**\n   * Get a list of orders for a given `owner`.\n   * @param request The request parameters with `request.offset = 0` and `request.limit = 1000` by default.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link GetOrdersRequest}\n   * @see {@link EnrichedOrder}\n   */\n  getOrders(\n    { owner, offset = 0, limit = 1000 }: GetOrdersRequest,\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<EnrichedOrder>> {\n    const query = new URLSearchParams(\n      cleanObjectFromUndefinedValues({ offset: offset.toString(), limit: limit.toString() })\n    )\n\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/account/${owner}/orders`, method: 'GET', query },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get a list of orders from a given settlement transaction hash.\n   * @param txHash The transaction hash.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link EnrichedOrder}\n   */\n  getTxOrders(txHash: TransactionHash, contextOverride: PartialApiContext = {}): Promise<Array<EnrichedOrder>> {\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/transactions/${txHash}/orders`, method: 'GET' },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   */\n  getOrder(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    return this.fetch<Order>({ path: `/api/v1/orders/${orderUid}`, method: 'GET' }, contextOverride).then((order) => {\n      return transformOrder(order)\n    })\n  }\n\n  /**\n   * Attempt to get an order by its unique identifier, `orderUid`, from multiple environments.\n   *\n   * **NOTE**: The environment refers to either `prod` or `staging`. This allows a conveience method to\n   * attempt to get an order from both environments, in the event that the order is not found in the\n   * environment specified in the context.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   * @throws {OrderBookApiError} If the order is not found in any of the environments.\n   */\n  getOrderMultiEnv(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    const { env } = this.getContextWithOverride(contextOverride)\n    const otherEnvs = ENVS_LIST.filter((i) => i !== env)\n\n    let attemptsCount = 0\n\n    const fallback = (error: Error | OrderBookApiError): Promise<EnrichedOrder> => {\n      const nextEnv = otherEnvs[attemptsCount]\n\n      if (error instanceof OrderBookApiError && error.response.status === 404 && nextEnv) {\n        attemptsCount++\n\n        return this.getOrder(orderUid, { ...contextOverride, env: nextEnv }).catch(fallback)\n      }\n\n      return Promise.reject(error)\n    }\n\n    return this.getOrder(orderUid, { ...contextOverride, env }).catch(fallback)\n  }\n\n  /**\n   * Get a quote for an order.\n   * This allows for the calculation of the total cost of an order, including fees, before signing and submitting.\n   * @param requestBody The parameters for the order quote request.\n   * @param contextOverride Optional context override for this request.\n   * @returns A hydrated order matching the request ready to be signed.\n   */\n  getQuote(requestBody: OrderQuoteRequest, contextOverride: PartialApiContext = {}): Promise<OrderQuoteResponse> {\n    return this.fetch({ path: '/api/v1/quote', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Cancel one or more orders.\n   *\n   * **NOTE**: Cancellation is on a best-effort basis. Orders that are already in the process of being settled\n   * (ie. transaction has been submitted to chain by the solver) cannot not be cancelled.\n   * **CAUTION**: This method can only be used to cancel orders that were signed using `EIP-712` or `eth_sign (EIP-191)`.\n   * @param requestBody Orders to be cancelled and signed instructions to cancel them.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of order unique identifiers that were successfully cancelled.\n   */\n  sendSignedOrderCancellations(\n    requestBody: OrderCancellations,\n    contextOverride: PartialApiContext = {}\n  ): Promise<void> {\n    return this.fetch({ path: '/api/v1/orders', method: 'DELETE', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Submit an order to the order book.\n   * @param requestBody The signed order to be submitted.\n   * @param contextOverride Optional context override for this request.\n   * @returns The unique identifier of the order.\n   */\n  sendOrder(requestBody: OrderCreation, contextOverride: PartialApiContext = {}): Promise<UID> {\n    return this.fetch({ path: '/api/v1/orders', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Get the native price of a token.\n   *\n   * **NOTE**: The native price is the price of the token in the native currency of the chain. For example, on Ethereum\n   * this would be the price of the token in ETH.\n   * @param tokenAddress The address of the ERC-20 token.\n   * @param contextOverride Optional context override for this request.\n   * @returns The native price of the token.\n   */\n  getNativePrice(tokenAddress: Address, contextOverride: PartialApiContext = {}): Promise<NativePriceResponse> {\n    return this.fetch({ path: `/api/v1/token/${tokenAddress}/native_price`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Given a user's address, get the total surplus that they have earned.\n   * @param address The user's address\n   * @param contextOverride Optional context override for this request.\n   * @returns Calculated user's surplus\n   */\n  getTotalSurplus(address: Address, contextOverride: PartialApiContext = {}): Promise<TotalSurplus> {\n    return this.fetch({ path: `/api/v1/users/${address}/total_surplus`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Retrieve the full app data for a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param contextOverride Optional context override for this request.\n   * @returns Full app data that was uploaded\n   */\n  getAppData(appDataHash: AppDataHash, contextOverride: PartialApiContext = {}): Promise<AppDataObject> {\n    return this.fetch({ path: `/api/v1/app_data/${appDataHash}`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Upload the full app data that corresponds to a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param fullAppData Full app data to be uploaded\n   * @param contextOverride Optional context override for this request.\n   * @returns The string encoding of the full app data that was uploaded.\n   */\n  uploadAppData(\n    appDataHash: AppDataHash,\n    fullAppData: string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<AppDataObject> {\n    return this.fetch(\n      { path: `/api/v1/app_data/${appDataHash}`, method: 'PUT', body: { fullAppData } },\n      contextOverride\n    )\n  }\n\n  getSolverCompetition(auctionId: number, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  getSolverCompetition(txHash: string, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  /**\n   * Given an auction id or tx hash, get the details of the solver competition for that auction.\n   * @param auctionIdorTx auction id or tx hash corresponding to the auction\n   * @param contextOverride Optional context override for this request.\n   * @returns An object containing the solver competition details\n   */\n  getSolverCompetition(\n    auctionIdorTx: number | string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<SolverCompetitionResponse> {\n    return this.fetch(\n      {\n        path: `/api/v1/solver_competition${typeof auctionIdorTx === 'string' ? '/by_tx_hash' : ''}/${auctionIdorTx}`,\n        method: 'GET',\n      },\n      contextOverride\n    )\n  }\n\n  /**\n   * Generate an API endpoint for an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The API endpoint to get the order.\n   */\n  getOrderLink(orderUid: UID, contextOverride?: PartialApiContext): string {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    return this.getApiBaseUrls(env)[chainId] + `/api/v1/orders/${orderUid}`\n  }\n\n  /**\n   * Apply an override to the context for a request.\n   * @param contextOverride Optional context override for this request.\n   * @returns New context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext & RequestOptions {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the API endpoints given the environment.\n   * @param env The environment to get the base URLs for.\n   * @returns The base URLs for the API endpoints.\n   */\n  private getApiBaseUrls(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? ORDER_BOOK_PROD_CONFIG : ORDER_BOOK_STAGING_CONFIG\n  }\n\n  /**\n   * Make a request to the API.\n   * @param params The parameters for the request.\n   * @param contextOverride Optional context override for this request.\n   * @returns The response from the API.\n   */\n  private fetch<T>(params: FetchParams, contextOverride: PartialApiContext = {}): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getApiBaseUrls(env)[chainId]\n    const backoffOpts = this.context.backoffOpts || DEFAULT_BACKOFF_OPTIONS\n\n    return request(baseUrl, params, this.rateLimiter, backoffOpts)\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `buyToken` be transferred to?\n */\nexport enum BuyTokenDestination {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum EcdsaSigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nimport type { Address } from './Address';\n\nexport type OnchainOrderData = {\n    /**\n     * If orders are placed as on-chain orders, the owner of the order might\n     * be a smart contract, but not the user placing the order. The\n     * actual user will be provided in this field.\n     *\n     */\n    sender: Address;\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    placementError?: OnchainOrderData.placementError;\n};\n\nexport namespace OnchainOrderData {\n\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    export enum placementError {\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        VALID_TO_TOO_FAR_IN_FUTURE = 'ValidToTooFarInFuture',\n        PRE_VALIDATION_ERROR = 'PreValidationError',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderCancellationError = {\n    errorType: OrderCancellationError.errorType;\n    description: string;\n};\n\nexport namespace OrderCancellationError {\n\n    export enum errorType {\n        INVALID_SIGNATURE = 'InvalidSignature',\n        WRONG_OWNER = 'WrongOwner',\n        ORDER_NOT_FOUND = 'OrderNotFound',\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Order class.\n */\nexport enum OrderClass {\n    MARKET = 'market',\n    LIMIT = 'limit',\n    LIQUIDITY = 'liquidity',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Is this order a buy or sell?\n */\nexport enum OrderKind {\n    BUY = 'buy',\n    SELL = 'sell',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderPostError = {\n    errorType: OrderPostError.errorType;\n    description: string;\n};\n\nexport namespace OrderPostError {\n\n    export enum errorType {\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        INVALID_QUOTE = 'InvalidQuote',\n        MISSING_FROM = 'MissingFrom',\n        WRONG_OWNER = 'WrongOwner',\n        INVALID_EIP1271SIGNATURE = 'InvalidEip1271Signature',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        SELL_AMOUNT_OVERFLOW = 'SellAmountOverflow',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        ZERO_AMOUNT = 'ZeroAmount',\n        INCOMPATIBLE_SIGNING_SCHEME = 'IncompatibleSigningScheme',\n        TOO_MANY_LIMIT_ORDERS_UNSUPPORTED_BUY_TOKEN_DESTINATION = 'TooManyLimitOrders UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        INVALID_NATIVE_SELL_TOKEN_SAME_BUY_AND_SELL_TOKEN = 'InvalidNativeSellToken SameBuyAndSellToken',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        UNSUPPORTED_CUSTOM_INTERACTION_INVALID_APP_DATA = 'UnsupportedCustomInteraction InvalidAppData',\n        APP_DATA_HASH_MISMATCH = 'AppDataHashMismatch',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * The current order status.\n */\nexport enum OrderStatus {\n    PRESIGNATURE_PENDING = 'presignaturePending',\n    OPEN = 'open',\n    FULFILLED = 'fulfilled',\n    CANCELLED = 'cancelled',\n    EXPIRED = 'expired',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type PriceEstimationError = {\n    errorType: PriceEstimationError.errorType;\n    description: string;\n};\n\nexport namespace PriceEstimationError {\n\n    export enum errorType {\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How good should the price estimate be?\n *\n * Fast: The price estimate is chosen among the fastest N price estimates.\n * Optimal: The price estimate is chosen among all price estimates.\n * Verified: The price estimate is chosen among all verified/simulated price estimates.\n *\n * **NOTE**: Orders are supposed to be created from `verified` price estimates.\n *\n */\nexport enum PriceQuality {\n    FAST = 'fast',\n    OPTIMAL = 'optimal',\n    VERIFIED = 'verified',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type ReplaceOrderError = {\n    errorType: ReplaceOrderError.errorType;\n    description: string;\n};\n\nexport namespace ReplaceOrderError {\n\n    export enum errorType {\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        WRONG_OWNER = 'WrongOwner',\n        SAME_BUY_AND_SELL_TOKEN = 'SameBuyAndSellToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_BUY_TOKEN_DESTINATION = 'UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `sellToken` be drawn from?\n */\nexport enum SellTokenSource {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n    EXTERNAL = 'external',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum SigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n    PRESIGN = 'presign',\n    EIP1271 = 'eip1271',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindBuy {\n    BUY = 'buy',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindSell {\n    SELL = 'sell',\n}\n","import { gql } from 'graphql-request'\n\n/**\n * GraphQL query for the total number of tokens, orders, traders, settlements, volume, and fees.\n */\nexport const TOTALS_QUERY = gql`\n  query Totals {\n    totals {\n      tokens\n      orders\n      traders\n      settlements\n      volumeUsd\n      volumeEth\n      feesUsd\n      feesEth\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N days.\n * @param days The number of days to query.\n */\nexport const LAST_DAYS_VOLUME_QUERY = gql`\n  query LastDaysVolume($days: Int!) {\n    dailyTotals(orderBy: timestamp, orderDirection: desc, first: $days) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N hours.\n * @param hours The number of hours to query.\n */\nexport const LAST_HOURS_VOLUME_QUERY = gql`\n  query LastHoursVolume($hours: Int!) {\n    hourlyTotals(orderBy: timestamp, orderDirection: desc, first: $hours) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n","import { CowError } from '../common/cow-error'\nimport { LastDaysVolumeQuery, LastHoursVolumeQuery, TotalsQuery } from './graphql'\nimport { LAST_DAYS_VOLUME_QUERY, LAST_HOURS_VOLUME_QUERY, TOTALS_QUERY } from './queries'\nimport { DocumentNode } from 'graphql/index'\nimport { request, Variables } from 'graphql-request'\nimport { ApiContext, CowEnv, DEFAULT_COW_API_CONTEXT, ApiBaseUrls, PartialApiContext } from '../common/configs'\nimport { SupportedChainId } from '../common/chains'\n\nconst SUBGRAPH_BASE_URL = 'https://api.thegraph.com/subgraphs/name/cowprotocol'\n\n/**\n * CoW Protocol Production Subgraph API configuration.\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-goerli}\n */\nexport const SUBGRAPH_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc',\n  [SupportedChainId.GOERLI]: SUBGRAPH_BASE_URL + '/cow-goerli',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * CoW Protocol Staging Subgraph API configuration.\n * @deprecated\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-staging}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc-staging}\n */\nexport const SUBGRAPH_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow-staging',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc-staging',\n  [SupportedChainId.GOERLI]: '',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * TheGraph API client for CoW Protocol.\n */\nexport class SubgraphApi {\n  API_NAME = 'CoW Protocol Subgraph'\n\n  public context: ApiContext\n\n  /**\n   * Create a new CoW Protocol API instance.\n   * @param context Any properties of the {@link ApiContext} may be overridden by passing a {@link PartialApiContext}.\n   */\n  constructor(context: PartialApiContext = {}) {\n    this.context = {\n      ...DEFAULT_COW_API_CONTEXT,\n      ...context,\n    }\n  }\n\n  /**\n   * Query the totals from TheGraph for the CoW Protocol.\n   * @param contextOverride Override the context for this call only.\n   * @returns The totals for the CoW Protocol.\n   */\n  async getTotals(contextOverride: PartialApiContext = {}): Promise<TotalsQuery['totals'][0]> {\n    const response = await this.runQuery<TotalsQuery>(TOTALS_QUERY, undefined, contextOverride)\n    return response.totals[0]\n  }\n\n  /**\n   * Query the volume over the last N days from TheGraph for the CoW Protocol.\n   * @param {number} days The number of days to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N days.\n   */\n  async getLastDaysVolume(days: number, contextOverride: PartialApiContext = {}): Promise<LastDaysVolumeQuery> {\n    return this.runQuery<LastDaysVolumeQuery>(LAST_DAYS_VOLUME_QUERY, { days }, contextOverride)\n  }\n\n  /**\n   * Query the volume over the last N hours from TheGraph for the CoW Protocol.\n   * @param {number} hours The number of hours to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N hours.\n   */\n  async getLastHoursVolume(hours: number, contextOverride: PartialApiContext = {}): Promise<LastHoursVolumeQuery> {\n    return this.runQuery<LastHoursVolumeQuery>(LAST_HOURS_VOLUME_QUERY, { hours }, contextOverride)\n  }\n\n  /**\n   * Run a query against the CoW Protocol Subgraph.\n   * @param {string | DocumentNode} query GQL query string or DocumentNode.\n   * @param {Variables | undefined} variables To be passed to the query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns Results of the query.\n   * @throws {@link CowError} if the query fails.\n   */\n  async runQuery<T>(\n    query: string | DocumentNode,\n    variables: Variables | undefined = undefined,\n    contextOverride: PartialApiContext = {}\n  ): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getEnvConfigs(env)[chainId]\n\n    try {\n      return await request(baseUrl, query, variables)\n    } catch (error) {\n      console.error(`[subgraph:${this.API_NAME}]`, error)\n      throw new CowError(\n        `Error running query: ${query}. Variables: ${JSON.stringify(variables)}. API: ${baseUrl}. Inner Error: ${error}`\n      )\n    }\n  }\n\n  /**\n   * Override parts of the context for a specific call.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns {ApiContext} The context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the given environment.\n   * @param {CowEnv} env The environment to get the base URLs for.\n   * @returns {ApiBaseUrls} The base URLs for the given environment.\n   */\n  private getEnvConfigs(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? SUBGRAPH_PROD_CONFIG : SUBGRAPH_STAGING_CONFIG\n  }\n}\n","import type { SupportedChainId } from '../common'\nimport type { Signer } from '@ethersproject/abstract-signer'\nimport type { TypedDataDomain } from '@cowprotocol/contracts'\nimport type { SigningResult, UnsignedOrder } from './types'\n\nconst getSignUtils = () => import('./utils')\nconst ethersUtils = () => import('ethers/lib/utils')\n\n/**\n * Utility class for signing order intents and cancellations.\n *\n * @remarks This class only supports `eth_sign` and wallet-native EIP-712 signing. For use of\n *          `presign` and `eip1271` {@link https://docs.cow.fi/ | see the docs}.\n * @example\n *\n * ```typescript\n * import { OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * async function main() {\n *     const { order: Order } = { ... }\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n */\nexport class OrderSigningUtils {\n  /**\n   * Sign the order intent with the specified signer.\n   *\n   * @remarks If the API reports an error with the signature, it is likely to be due to an incorrectly\n   *          specified `chainId`. Please ensure that the `chainId` is correct for the network you are\n   *          using.\n   * @param {UnsignedOrder} order The unsigned order intent to be placed.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who is placing the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the order.\n   */\n  static async signOrder(order: UnsignedOrder, chainId: SupportedChainId, signer: Signer): Promise<SigningResult> {\n    const { signOrder } = await getSignUtils()\n    return signOrder(order, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of an order intent with the specified signer.\n   * @param {string} orderUid The unique identifier of the order to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainid` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellation(\n    orderUid: string,\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellation } = await getSignUtils()\n    return signOrderCancellation(orderUid, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of multiple order intents with the specified signer.\n   * @param {string[]} orderUids An array of `orderUid` to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intents.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellations(\n    orderUids: string[],\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellations } = await getSignUtils()\n    return signOrderCancellations(orderUids, chainId, signer)\n  }\n\n  /**\n   * Get the EIP-712 typed domain data being used for signing.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @return The EIP-712 typed domain data.\n   * @see https://eips.ethereum.org/EIPS/eip-712\n   */\n  static async getDomain(chainId: SupportedChainId): Promise<TypedDataDomain> {\n    const { getDomain } = await getSignUtils()\n    return getDomain(chainId)\n  }\n\n  /**\n   * Get the domain separator hash for the EIP-712 typed domain data being used for signing.\n   * @param chainId {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @returns A string representation of the EIP-712 typed domain data hash.\n   */\n  static async getDomainSeparator(chainId: SupportedChainId): Promise<string> {\n    const { getDomain } = await getSignUtils()\n    const { _TypedDataEncoder } = await ethersUtils()\n    return _TypedDataEncoder.hashDomain(getDomain(chainId))\n  }\n\n  /**\n   * Get the EIP-712 types used for signing a GPv2Order.Data struct. This is useful for when\n   * signing orders using smart contracts, whereby this SDK cannot do the EIP-1271 signing for you.\n   * @returns The EIP-712 types used for signing.\n   */\n  static getEIP712Types(): Record<string, any> {\n    return {\n      Order: [\n        { name: 'sellToken', type: 'address' },\n        { name: 'buyToken', type: 'address' },\n        { name: 'receiver', type: 'address' },\n        { name: 'sellAmount', type: 'uint256' },\n        { name: 'buyAmount', type: 'uint256' },\n        { name: 'validTo', type: 'uint32' },\n        { name: 'appData', type: 'bytes32' },\n        { name: 'feeAmount', type: 'uint256' },\n        { name: 'kind', type: 'string' },\n        { name: 'partiallyFillable', type: 'bool' },\n        { name: 'sellTokenBalance', type: 'string' },\n        { name: 'buyTokenBalance', type: 'string' },\n      ],\n    }\n  }\n}\n","import { OrderBookApi } from '../order-book'\nimport { SupportedChainId } from '../common'\nimport { GPv2Order } from './generated/ComposableCoW'\nimport { providers } from 'ethers'\n\nexport interface ConditionalOrderArguments<T> {\n  handler: string\n  data: T\n  salt?: string\n  hasOffChainInput?: boolean\n}\n\nexport type ConditionalOrderParams = {\n  readonly handler: string\n  readonly salt: string\n  readonly staticInput: string\n}\n\nexport enum ProofLocation {\n  // The location of the proofs is private to the caller.\n  PRIVATE = 0,\n  // The `data` field of the emitted `Proof` struct contains proofs + conditional order parameters.\n  EMITTED = 1,\n  // The `data` field of the emitted `Proof` struct contains the Swarm address (`bytes32`) of the proofs + conditional order parameters.\n  SWARM = 2,\n  // The `data` field is set to TBD.\n  WAKU = 3,\n  // The `data` field is set to TBD\n  RESERVED = 4,\n  // The `data` field of the emitted `Proof` struct contains the IPFS address (`bytes32`) of the proofs + conditional order parameters.\n  IPFS = 5,\n}\n\n/**\n * A factory and it's arguments that are called at transaction mining time to generate the context\n * for a conditional order(s).\n *\n * This allows to support the case where conditional orders may want to *commence* validity at the\n * time of transaction mining, like in the case of a `TWAP` executed by a DAO or `Safe` that takes\n * a reasonable amount of time to aggregate signatures or collect votes.\n *\n * @remarks This is used in conjunction with `setRootWithContext` or `createWithContext`.\n */\nexport type ContextFactory = {\n  // The address of the `IValueFactory` that will be used to resolve the context.\n  address: string\n  // Any arguments that will be passed to the `IValueFactory` to resolve the context.\n  factoryArgs?: {\n    args: unknown[]\n    argsType: string[]\n  }\n}\n\n/**\n * A struct for a proof that can be used with `setRoot` and `setRootWithContext` on a\n * ComposableCoW-enabled Safe.\n */\nexport type ProofStruct = {\n  // The location of the proof.\n  location: ProofLocation\n  // The data for the proof.\n  data: string | '0x'\n}\n\n/**\n * Payload for emitting a merkle root to a ComposableCoW-enabled Safe.\n *\n * If setting `ProofLocation.EMITTED`, this type should be used as the `data` in the `Proof` struct.\n */\nexport type PayloadLocationEmitted = {\n  // An array of conditional orders and their proofs.\n  proofs: ProofWithParams[]\n}\n\n/**\n * A proof for a conditional order and it's parameters.\n */\nexport type ProofWithParams = {\n  // The proof for the Merkle tree that contains the conditional order.\n  proof: string[]\n  // The parameters as expected by ABI encoding.\n  params: ConditionalOrderParams\n}\n\nexport type OwnerContext = {\n  owner: string\n  chainId: SupportedChainId\n  provider: providers.Provider\n}\n\nexport type PollParams = OwnerContext & {\n  offchainInput?: string\n  proof?: string[]\n\n  /**\n   * If present, it can be used for custom conditional order validations. If not present, the orders will need to get the block info themselves\n   */\n  blockInfo?: BlockInfo\n\n  /**\n   * Allows to optional pass the config of the orderbook API\n   */\n  orderbookApiConfig?: OrderBookApiConfig\n}\n\nexport type OrderBookApiConfig = Omit<ConstructorParameters<typeof OrderBookApi>[0], 'chainId'>\n\nexport type BlockInfo = {\n  blockNumber: number\n  blockTimestamp: number\n}\n\nexport type PollResult = PollResultSuccess | PollResultErrors\n\nexport type PollResultErrors =\n  | PollResultTryNextBlock\n  | PollResultTryOnBlock\n  | PollResultTryAtEpoch\n  | PollResultUnexpectedError\n  | PollResultDontTryAgain\n\nexport enum PollResultCode {\n  SUCCESS = 'SUCCESS',\n  UNEXPECTED_ERROR = 'UNEXPECTED_ERROR',\n  TRY_NEXT_BLOCK = 'TRY_NEXT_BLOCK',\n  TRY_ON_BLOCK = 'TRY_ON_BLOCK',\n  TRY_AT_EPOCH = 'TRY_AT_EPOCH',\n  DONT_TRY_AGAIN = 'DONT_TRY_AGAIN',\n}\nexport interface PollResultSuccess {\n  readonly result: PollResultCode.SUCCESS\n  readonly order: GPv2Order.DataStruct\n  readonly signature: string\n}\n\nexport interface PollResultUnexpectedError {\n  readonly result: PollResultCode.UNEXPECTED_ERROR\n  readonly error: unknown\n  reason?: string\n}\n\nexport interface PollResultTryNextBlock {\n  readonly result: PollResultCode.TRY_NEXT_BLOCK\n  reason?: string\n}\n\nexport interface PollResultTryOnBlock {\n  readonly result: PollResultCode.TRY_ON_BLOCK\n  readonly blockNumber: number\n  reason?: string\n}\n\nexport interface PollResultTryAtEpoch {\n  readonly result: PollResultCode.TRY_AT_EPOCH\n  /**\n   * The epoch after which it is ok to retry to to poll this order.\n   * The value is expressed as a Unix timestamp (in seconds).\n   *\n   * This epoch will be inclusive, meaning that it is ok to retry at the block mined precisely at this epoch or later.\n   */\n  readonly epoch: number\n  reason?: string\n}\n\nexport interface PollResultDontTryAgain {\n  readonly result: PollResultCode.DONT_TRY_AGAIN\n  reason?: string\n}\n\nexport type IsValidResult = IsValid | IsNotValid\nexport interface IsValid {\n  isValid: true\n}\nexport interface IsNotValid {\n  isValid: false\n  reason: string\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type { ComposableCoW, ComposableCoWInterface } from \"../ComposableCoW\";\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_settlement\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"InterfaceNotSupported\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidHandler\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ProofNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SingleOrderNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SwapGuardRestricted\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"ConditionalOrderCreated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"MerkleRootSet\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"SwapGuardSet\",\n    type: \"event\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"cabinet\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"create\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"createWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"domainSeparator\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"offchainInput\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"proof\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"getTradeableOrderWithSignature\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IERC20\",\n            name: \"sellToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"contract IERC20\",\n            name: \"buyToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"receiver\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"sellAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"buyAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint32\",\n            name: \"validTo\",\n            type: \"uint32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"appData\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"feeAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"kind\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bool\",\n            name: \"partiallyFillable\",\n            type: \"bool\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"sellTokenBalance\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"buyTokenBalance\",\n            type: \"bytes32\",\n          },\n        ],\n        internalType: \"struct GPv2Order.Data\",\n        name: \"order\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"hash\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"encodeData\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"payload\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSafeSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"singleOrderHash\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"remove\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"roots\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"setRoot\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"setRootWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"setSwapGuard\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"singleOrders\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"swapGuards\",\n    outputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ComposableCoW__factory {\n  static readonly abi = _abi;\n  static createInterface(): ComposableCoWInterface {\n    return new utils.Interface(_abi) as ComposableCoWInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ComposableCoW {\n    return new Contract(address, _abi, signerOrProvider) as ComposableCoW;\n  }\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type {\n  ExtensibleFallbackHandler,\n  ExtensibleFallbackHandlerInterface,\n} from \"../ExtensibleFallbackHandler\";\n\nconst _abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"verifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"AddedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"method\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AddedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"oldVerifier\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"ChangedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"oldMethod\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"ChangedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"RemovedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    stateMutability: \"nonpayable\",\n    type: \"fallback\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"domainVerifiers\",\n    outputs: [\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155BatchReceived\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC721Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeInterfaces\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeMethods\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"setDomainVerifier\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"setSafeMethod\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"supported\",\n        type: \"bool\",\n      },\n    ],\n    name: \"setSupportedInterface\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"_interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"handlerWithSelectors\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"setSupportedInterfaceBatch\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"supportsInterface\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ExtensibleFallbackHandler__factory {\n  static readonly abi = _abi;\n  static createInterface(): ExtensibleFallbackHandlerInterface {\n    return new utils.Interface(_abi) as ExtensibleFallbackHandlerInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ExtensibleFallbackHandler {\n    return new Contract(\n      address,\n      _abi,\n      signerOrProvider\n    ) as ExtensibleFallbackHandler;\n  }\n}\n","import { ethers } from \"ethers\";\n/**\n * Marker address to indicate that an order is buying Ether.\n *\n * Note that this address is only has special meaning in the `buyToken` and will\n * be treated as a ERC20 token address in the `sellToken` position, causing the\n * settlement to revert.\n */\nexport const BUY_ETH_ADDRESS = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n/**\n * Order kind.\n */\nexport var OrderKind;\n(function (OrderKind) {\n    /**\n     * A sell order.\n     */\n    OrderKind[\"SELL\"] = \"sell\";\n    /**\n     * A buy order.\n     */\n    OrderKind[\"BUY\"] = \"buy\";\n})(OrderKind || (OrderKind = {}));\n/**\n * Order balance configuration.\n */\nexport var OrderBalance;\n(function (OrderBalance) {\n    /**\n     * Use ERC20 token balances.\n     */\n    OrderBalance[\"ERC20\"] = \"erc20\";\n    /**\n     * Use Balancer Vault external balances.\n     *\n     * This can only be specified specified for the sell balance and allows orders\n     * to re-use Vault ERC20 allowances. When specified for the buy balance, it\n     * will be treated as {@link OrderBalance.ERC20}.\n     */\n    OrderBalance[\"EXTERNAL\"] = \"external\";\n    /**\n     * Use Balancer Vault internal balances.\n     */\n    OrderBalance[\"INTERNAL\"] = \"internal\";\n})(OrderBalance || (OrderBalance = {}));\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_FIELDS = [\n    { name: \"sellToken\", type: \"address\" },\n    { name: \"buyToken\", type: \"address\" },\n    { name: \"receiver\", type: \"address\" },\n    { name: \"sellAmount\", type: \"uint256\" },\n    { name: \"buyAmount\", type: \"uint256\" },\n    { name: \"validTo\", type: \"uint32\" },\n    { name: \"appData\", type: \"bytes32\" },\n    { name: \"feeAmount\", type: \"uint256\" },\n    { name: \"kind\", type: \"string\" },\n    { name: \"partiallyFillable\", type: \"bool\" },\n    { name: \"sellTokenBalance\", type: \"string\" },\n    { name: \"buyTokenBalance\", type: \"string\" },\n];\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const CANCELLATIONS_TYPE_FIELDS = [\n    { name: \"orderUids\", type: \"bytes[]\" },\n];\n/**\n * The EIP-712 type hash for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_HASH = ethers.utils.id(`Order(${ORDER_TYPE_FIELDS.map(({ name, type }) => `${type} ${name}`).join(\",\")})`);\n/**\n * Normalizes a timestamp value to a Unix timestamp.\n * @param time The timestamp value to normalize.\n * @return Unix timestamp or number of seconds since the Unix Epoch.\n */\nexport function timestamp(t) {\n    return typeof t === \"number\" ? t : ~~(t.getTime() / 1000);\n}\n/**\n * Normalizes an app data value to a 32-byte hash.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function hashify(h) {\n    return typeof h === \"number\"\n        ? `0x${h.toString(16).padStart(64, \"0\")}`\n        : ethers.utils.hexZeroPad(h, 32);\n}\n/**\n * Normalizes the balance configuration for a buy token. Specifically, this\n * function ensures that {@link OrderBalance.EXTERNAL} gets normalized to\n * {@link OrderBalance.ERC20}.\n *\n * @param balance The balance configuration.\n * @returns The normalized balance configuration.\n */\nexport function normalizeBuyTokenBalance(balance) {\n    switch (balance) {\n        case undefined:\n        case OrderBalance.ERC20:\n        case OrderBalance.EXTERNAL:\n            return OrderBalance.ERC20;\n        case OrderBalance.INTERNAL:\n            return OrderBalance.INTERNAL;\n        default:\n            throw new Error(`invalid order balance ${balance}`);\n    }\n}\n/**\n * Normalizes an order for hashing and signing, so that it can be used with\n * Ethers.js for EIP-712 operations.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function normalizeOrder(order) {\n    var _a, _b;\n    if (order.receiver === ethers.constants.AddressZero) {\n        throw new Error(\"receiver cannot be address(0)\");\n    }\n    const normalizedOrder = Object.assign(Object.assign({}, order), { sellTokenBalance: (_a = order.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20, receiver: (_b = order.receiver) !== null && _b !== void 0 ? _b : ethers.constants.AddressZero, validTo: timestamp(order.validTo), appData: hashify(order.appData), buyTokenBalance: normalizeBuyTokenBalance(order.buyTokenBalance) });\n    return normalizedOrder;\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param types The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashTypedData(domain, types, data) {\n    return ethers.utils._TypedDataEncoder.hash(domain, types, data);\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param order The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrder(domain, order) {\n    return hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order));\n}\n/**\n * Compute the 32-byte signing hash for the specified cancellation.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUid The unique identifier of the order to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellation(domain, orderUid) {\n    return hashOrderCancellations(domain, [orderUid]);\n}\n/**\n * Compute the 32-byte signing hash for the specified order cancellations.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellations(domain, orderUids) {\n    return hashTypedData(domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids });\n}\n/**\n * The byte length of an order UID.\n */\nexport const ORDER_UID_LENGTH = 56;\n/**\n * Computes the order UID for an order and the given owner.\n */\nexport function computeOrderUid(domain, order, owner) {\n    return packOrderUidParams({\n        orderDigest: hashOrder(domain, order),\n        owner,\n        validTo: order.validTo,\n    });\n}\n/**\n * Compute the unique identifier describing a user order in the settlement\n * contract.\n *\n * @param OrderUidParams The parameters used for computing the order's unique\n * identifier.\n * @returns A string that unequivocally identifies the order of the user.\n */\nexport function packOrderUidParams({ orderDigest, owner, validTo, }) {\n    return ethers.utils.solidityPack([\"bytes32\", \"address\", \"uint32\"], [orderDigest, owner, timestamp(validTo)]);\n}\n/**\n * Extracts the order unique identifier parameters from the specified bytes.\n *\n * @param orderUid The order UID encoded as a hexadecimal string.\n * @returns The extracted order UID parameters.\n */\nexport function extractOrderUidParams(orderUid) {\n    const bytes = ethers.utils.arrayify(orderUid);\n    if (bytes.length != ORDER_UID_LENGTH) {\n        throw new Error(\"invalid order UID length\");\n    }\n    const view = new DataView(bytes.buffer);\n    return {\n        orderDigest: ethers.utils.hexlify(bytes.subarray(0, 32)),\n        owner: ethers.utils.getAddress(ethers.utils.hexlify(bytes.subarray(32, 52))),\n        validTo: view.getUint32(52),\n    };\n}\n//# sourceMappingURL=order.js.map","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;","/**\n * Normalizes interaction data so that it is ready to be be ABI encoded.\n *\n * @param interaction The interaction to normalize.\n * @return The normalized interaction.\n */\nexport function normalizeInteraction(interaction) {\n    return Object.assign({ value: 0, callData: \"0x\" }, interaction);\n}\n/**\n * Normalizes data for many interactions so that they can be ABI encoded. This\n * calls [`normalizeInteraction`] for each interaction.\n *\n * @param interactions The interactions to normalize.\n * @return The normalized interactions.\n */\nexport function normalizeInteractions(interactions) {\n    return interactions.map(normalizeInteraction);\n}\n//# sourceMappingURL=interaction.js.map","/**\n * Checks whether the specified signer is a typed data signer.\n */\nexport function isTypedDataSigner(signer) {\n    return \"_signTypedData\" in signer;\n}\n/**\n * Checks whether the specified provider is a JSON RPC provider.\n */\nexport function isJsonRpcProvider(provider) {\n    return \"send\" in provider;\n}\n//# sourceMappingURL=ethers.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\nimport { ORDER_TYPE_FIELDS, CANCELLATIONS_TYPE_FIELDS, normalizeOrder, hashTypedData, } from \"./order\";\nimport { isTypedDataSigner, } from \"./types/ethers\";\n/**\n * Value returned by a call to `isValidSignature` if the signature was verified\n * successfully. The value is defined in the EIP-1271 standard as:\n * bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n */\nexport const EIP1271_MAGICVALUE = ethers.utils.hexDataSlice(ethers.utils.id(\"isValidSignature(bytes32,bytes)\"), 0, 4);\n/**\n * Marker value indicating a presignature is set.\n */\nexport const PRE_SIGNED = ethers.utils.id(\"GPv2Signing.Scheme.PreSign\");\n/**\n * The signing scheme used to sign the order.\n */\nexport var SigningScheme;\n(function (SigningScheme) {\n    /**\n     * The EIP-712 typed data signing scheme. This is the preferred scheme as it\n     * provides more infomation to wallets performing the signature on the data\n     * being signed.\n     *\n     * <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-domainseparator>\n     */\n    SigningScheme[SigningScheme[\"EIP712\"] = 0] = \"EIP712\";\n    /**\n     * Message signed using eth_sign RPC call.\n     */\n    SigningScheme[SigningScheme[\"ETHSIGN\"] = 1] = \"ETHSIGN\";\n    /**\n     * Smart contract signatures as defined in EIP-1271.\n     *\n     * <https://eips.ethereum.org/EIPS/eip-1271>\n     */\n    SigningScheme[SigningScheme[\"EIP1271\"] = 2] = \"EIP1271\";\n    /**\n     * Pre-signed order.\n     */\n    SigningScheme[SigningScheme[\"PRESIGN\"] = 3] = \"PRESIGN\";\n})(SigningScheme || (SigningScheme = {}));\nfunction ecdsaSignTypedData(scheme, owner, domain, types, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let signature = null;\n        switch (scheme) {\n            case SigningScheme.EIP712:\n                if (!isTypedDataSigner(owner)) {\n                    throw new Error(\"signer does not support signing typed data\");\n                }\n                signature = yield owner._signTypedData(domain, types, data);\n                break;\n            case SigningScheme.ETHSIGN:\n                signature = yield owner.signMessage(ethers.utils.arrayify(hashTypedData(domain, types, data)));\n                break;\n            default:\n                throw new Error(\"invalid signing scheme\");\n        }\n        // Passing the signature through split/join to normalize the `v` byte.\n        // Some wallets do not pad it with `27`, which causes a signature failure\n        // `splitSignature` pads it if needed, and `joinSignature` simply puts it back together\n        return ethers.utils.joinSignature(ethers.utils.splitSignature(signature));\n    });\n}\n/**\n * Returns the signature for the specified order with the signing scheme encoded\n * into the signature.\n *\n * @param domain The domain to sign the order for. This is used by the smart\n * contract to ensure orders can't be replayed across different applications,\n * but also different deployments (as the contract chain ID and address are\n * mixed into to the domain value).\n * @param order The order to sign.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the order.\n */\nexport function signOrder(domain, order, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order)),\n        };\n    });\n}\n/**\n * Returns the signature for cancelling a single order with the specified\n * signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUid The unique identifier of the order being cancelled.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellation(domain, orderUid, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return signOrderCancellations(domain, [orderUid], owner, scheme);\n    });\n}\n/**\n * Returns the signature for cancelling multiple orders by UID with the\n * specified signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellations(domain, orderUids, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids }),\n        };\n    });\n}\n/**\n * Encodes the necessary data required for the Gnosis Protocol contracts to\n * verify an EIP-1271 signature.\n *\n * @param signature The EIP-1271 signature data to encode.\n */\nexport function encodeEip1271SignatureData({ verifier, signature, }) {\n    return ethers.utils.solidityPack([\"address\", \"bytes\"], [verifier, signature]);\n}\n/**\n * Decodes a GPv2 EIP-1271-type signature into the actual EIP-1271 signature\n * and the verifier contract.\n *\n * @param signature The EIP-1271 signature data to decode.\n * @returns decodedSignature The decoded signature object, composed of an\n * EIP-1271 signature and a verifier.\n */\nexport function decodeEip1271SignatureData(signature) {\n    const arrayifiedSignature = ethers.utils.arrayify(signature);\n    const verifier = ethers.utils.getAddress(ethers.utils.hexlify(arrayifiedSignature.slice(0, 20)));\n    return {\n        verifier,\n        signature: arrayifiedSignature.slice(20),\n    };\n}\n//# sourceMappingURL=sign.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers, BigNumber } from \"ethers\";\nimport { normalizeInteraction, } from \"./interaction\";\nimport { ORDER_TYPE_FIELDS, ORDER_UID_LENGTH, OrderBalance, OrderKind, hashTypedData, normalizeBuyTokenBalance, normalizeOrder, } from \"./order\";\nimport { SigningScheme, encodeEip1271SignatureData, signOrder, decodeEip1271SignatureData, } from \"./sign\";\n/**\n * The stage an interaction should be executed in.\n */\nexport var InteractionStage;\n(function (InteractionStage) {\n    /**\n     * A pre-settlement intraction.\n     *\n     * The interaction will be executed before any trading occurs. This can be\n     * used, for example, to perform as EIP-2612 `permit` call for a user trading\n     * in the current settlement.\n     */\n    InteractionStage[InteractionStage[\"PRE\"] = 0] = \"PRE\";\n    /**\n     * An intra-settlement interaction.\n     *\n     * The interaction will be executed after all trade sell amounts are\n     * transferred into the settlement contract, but before the buy amounts are\n     * transferred out to the traders. This can be used, for example, to interact\n     * with on-chain AMMs.\n     */\n    InteractionStage[InteractionStage[\"INTRA\"] = 1] = \"INTRA\";\n    /**\n     * A post-settlement interaction.\n     *\n     * The interaction will be executed after all trading has completed.\n     */\n    InteractionStage[InteractionStage[\"POST\"] = 2] = \"POST\";\n})(InteractionStage || (InteractionStage = {}));\n/**\n * An object listing all flag options in order along with their bit offset.\n */\nexport const FLAG_MASKS = {\n    kind: {\n        offset: 0,\n        options: [OrderKind.SELL, OrderKind.BUY],\n    },\n    partiallyFillable: {\n        offset: 1,\n        options: [false, true],\n    },\n    sellTokenBalance: {\n        offset: 2,\n        options: [\n            OrderBalance.ERC20,\n            undefined,\n            OrderBalance.EXTERNAL,\n            OrderBalance.INTERNAL,\n        ],\n    },\n    buyTokenBalance: {\n        offset: 4,\n        options: [OrderBalance.ERC20, OrderBalance.INTERNAL],\n    },\n    signingScheme: {\n        offset: 5,\n        options: [\n            SigningScheme.EIP712,\n            SigningScheme.ETHSIGN,\n            SigningScheme.EIP1271,\n            SigningScheme.PRESIGN,\n        ],\n    },\n};\nfunction encodeFlag(key, flag) {\n    const index = FLAG_MASKS[key].options.findIndex((search) => search === flag);\n    if (index === undefined) {\n        throw new Error(`Bad key/value pair to encode: ${key}/${flag}`);\n    }\n    return index << FLAG_MASKS[key].offset;\n}\n// Counts the smallest mask needed to store the input options in the masked\n// bitfield.\nfunction mask(options) {\n    const num = options.length;\n    const bitCount = 32 - Math.clz32(num - 1);\n    return (1 << bitCount) - 1;\n}\nfunction decodeFlag(key, flag) {\n    const { offset, options } = FLAG_MASKS[key];\n    const numberFlags = BigNumber.from(flag).toNumber();\n    const index = (numberFlags >> offset) & mask(options);\n    // This type casting should not be needed\n    const decoded = options[index];\n    if (decoded === undefined || index < 0) {\n        throw new Error(`Invalid input flag for ${key}: 0b${numberFlags.toString(2)}`);\n    }\n    return decoded;\n}\n/**\n * Encodes signing scheme as a bitfield.\n *\n * @param scheme The signing scheme to encode.\n * @return The bitfield result.\n */\nexport function encodeSigningScheme(scheme) {\n    return encodeFlag(\"signingScheme\", scheme);\n}\n/**\n * Decodes signing scheme from a bitfield.\n *\n * @param flag The encoded order flag.\n * @return The decoded signing scheme.\n */\nexport function decodeSigningScheme(flags) {\n    return decodeFlag(\"signingScheme\", flags);\n}\n/**\n * Encodes order flags as a bitfield.\n *\n * @param flags The order flags to encode.\n * @return The bitfield result.\n */\nexport function encodeOrderFlags(flags) {\n    var _a;\n    return (encodeFlag(\"kind\", flags.kind) |\n        encodeFlag(\"partiallyFillable\", flags.partiallyFillable) |\n        encodeFlag(\"sellTokenBalance\", (_a = flags.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20) |\n        encodeFlag(\"buyTokenBalance\", normalizeBuyTokenBalance(flags.buyTokenBalance)));\n}\n/**\n * Decode order flags from a bitfield.\n *\n * @param flags The order flags encoded as a bitfield.\n * @return The decoded order flags.\n */\nexport function decodeOrderFlags(flags) {\n    return {\n        kind: decodeFlag(\"kind\", flags),\n        partiallyFillable: decodeFlag(\"partiallyFillable\", flags),\n        sellTokenBalance: decodeFlag(\"sellTokenBalance\", flags),\n        buyTokenBalance: decodeFlag(\"buyTokenBalance\", flags),\n    };\n}\n/**\n * Encodes trade flags as a bitfield.\n *\n * @param flags The trade flags to encode.\n * @return The bitfield result.\n */\nexport function encodeTradeFlags(flags) {\n    return encodeOrderFlags(flags) | encodeSigningScheme(flags.signingScheme);\n}\n/**\n * Decode trade flags from a bitfield.\n *\n * @param flags The trade flags encoded as a bitfield.\n * @return The bitfield result.\n */\nexport function decodeTradeFlags(flags) {\n    return Object.assign(Object.assign({}, decodeOrderFlags(flags)), { signingScheme: decodeSigningScheme(flags) });\n}\nexport function encodeSignatureData(sig) {\n    switch (sig.scheme) {\n        case SigningScheme.EIP712:\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.joinSignature(sig.data);\n        case SigningScheme.EIP1271:\n            return encodeEip1271SignatureData(sig.data);\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(sig.data);\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\nexport function decodeSignatureOwner(domain, order, scheme, sig) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return ethers.utils.verifyTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order), sig);\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.verifyMessage(ethers.utils.arrayify(hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order))), sig);\n        case SigningScheme.EIP1271:\n            return decodeEip1271SignatureData(sig).verifier;\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(ethers.utils.hexlify(sig));\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\n/**\n * Encodes a trade to be used with the settlement contract.\n */\nexport function encodeTrade(tokens, order, signature, { executedAmount }) {\n    const tradeFlags = Object.assign(Object.assign({}, order), { signingScheme: signature.scheme });\n    const o = normalizeOrder(order);\n    return {\n        sellTokenIndex: tokens.index(o.sellToken),\n        buyTokenIndex: tokens.index(o.buyToken),\n        receiver: o.receiver,\n        sellAmount: o.sellAmount,\n        buyAmount: o.buyAmount,\n        validTo: o.validTo,\n        appData: o.appData,\n        feeAmount: o.feeAmount,\n        flags: encodeTradeFlags(tradeFlags),\n        executedAmount,\n        signature: encodeSignatureData(signature),\n    };\n}\n/**\n * A class used for tracking tokens when encoding settlements.\n *\n * This is used as settlement trades reference tokens by index instead of\n * directly by address for multiple reasons:\n * - Reduce encoding size of orders to save on `calldata` gas.\n * - Direct access to a token's clearing price on settlement instead of\n *   requiring a search.\n */\nexport class TokenRegistry {\n    constructor() {\n        this._tokens = [];\n        this._tokenMap = {};\n    }\n    /**\n     * Gets the array of token addresses currently stored in the registry.\n     */\n    get addresses() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.slice();\n    }\n    /**\n     * Retrieves the token index for the specified token address. If the token is\n     * not in the registry, it will be added.\n     *\n     * @param token The token address to add to the registry.\n     * @return The token index.\n     */\n    index(token) {\n        // NOTE: Verify and normalize the address into a case-checksummed address.\n        // Not only does this ensure validity of the addresses early on, it also\n        // makes it so `0xff...f` and `0xFF..F` map to the same ID.\n        const tokenAddress = ethers.utils.getAddress(token);\n        let tokenIndex = this._tokenMap[tokenAddress];\n        if (tokenIndex === undefined) {\n            tokenIndex = this._tokens.length;\n            this._tokens.push(tokenAddress);\n            this._tokenMap[tokenAddress] = tokenIndex;\n        }\n        return tokenIndex;\n    }\n}\n/**\n * A class for building calldata for a settlement.\n *\n * The encoder ensures that token addresses are kept track of and performs\n * necessary computation in order to map each token addresses to IDs to\n * properly encode order parameters for trades.\n */\nexport class SettlementEncoder {\n    /**\n     * Creates a new settlement encoder instance.\n     * @param domain Domain used for signing orders. See {@link signOrder} for\n     * more details.\n     */\n    constructor(domain) {\n        this.domain = domain;\n        this._tokens = new TokenRegistry();\n        this._trades = [];\n        this._interactions = {\n            [InteractionStage.PRE]: [],\n            [InteractionStage.INTRA]: [],\n            [InteractionStage.POST]: [],\n        };\n        this._orderRefunds = {\n            filledAmounts: [],\n            preSignatures: [],\n        };\n    }\n    /**\n     * Gets the array of token addresses used by the currently encoded orders.\n     */\n    get tokens() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.addresses;\n    }\n    /**\n     * Gets the encoded trades.\n     */\n    get trades() {\n        return this._trades.slice();\n    }\n    /**\n     * Gets all encoded interactions for all stages.\n     *\n     * Note that order refund interactions are included as post-interactions.\n     */\n    get interactions() {\n        return [\n            this._interactions[InteractionStage.PRE].slice(),\n            this._interactions[InteractionStage.INTRA].slice(),\n            [\n                ...this._interactions[InteractionStage.POST],\n                ...this.encodedOrderRefunds,\n            ],\n        ];\n    }\n    /**\n     * Gets the order refunds encoded as interactions.\n     */\n    get encodedOrderRefunds() {\n        const { filledAmounts, preSignatures } = this._orderRefunds;\n        if (filledAmounts.length + preSignatures.length === 0) {\n            return [];\n        }\n        const settlement = this.domain.verifyingContract;\n        if (settlement === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        // NOTE: Avoid importing the full GPv2Settlement contract artifact just for\n        // a tiny snippet of the ABI. Unit and integration tests will catch any\n        // issues that may arise from this definition becoming out of date.\n        const iface = new ethers.utils.Interface([\n            \"function freeFilledAmountStorage(bytes[] orderUids)\",\n            \"function freePreSignatureStorage(bytes[] orderUids)\",\n        ]);\n        const interactions = [];\n        for (const [functionName, orderUids] of [\n            [\"freeFilledAmountStorage\", filledAmounts],\n            [\"freePreSignatureStorage\", preSignatures],\n        ].filter(([, orderUids]) => orderUids.length > 0)) {\n            interactions.push(normalizeInteraction({\n                target: settlement,\n                callData: iface.encodeFunctionData(functionName, [orderUids]),\n            }));\n        }\n        return interactions;\n    }\n    /**\n     * Returns a clearing price vector for the current settlement tokens from the\n     * provided price map.\n     *\n     * @param prices The price map from token address to price.\n     * @return The price vector.\n     */\n    clearingPrices(prices) {\n        return this.tokens.map((token) => {\n            const price = prices[token];\n            if (price === undefined) {\n                throw new Error(`missing price for token ${token}`);\n            }\n            return price;\n        });\n    }\n    /**\n     * Encodes a trade from a signed order and executed amount, appending it to\n     * the `calldata` bytes that are being built.\n     *\n     * Additionally, if the order references new tokens that the encoder has not\n     * yet seen, they are added to the tokens array.\n     *\n     * @param order The order of the trade to encode.\n     * @param signature The signature for the order data.\n     * @param tradeExecution The execution details for the trade.\n     */\n    encodeTrade(order, signature, { executedAmount } = {}) {\n        if (order.partiallyFillable && executedAmount === undefined) {\n            throw new Error(\"missing executed amount for partially fillable trade\");\n        }\n        this._trades.push(encodeTrade(this._tokens, order, signature, {\n            executedAmount: executedAmount !== null && executedAmount !== void 0 ? executedAmount : 0,\n        }));\n    }\n    /**\n     * Signs an order and encodes a trade with that order.\n     *\n     * @param order The order to sign for the trade.\n     * @param owner The externally owned account that should sign the order.\n     * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n     * details.\n     * @param tradeExecution The execution details for the trade.\n     */\n    signEncodeTrade(order, owner, scheme, tradeExecution) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signature = yield signOrder(this.domain, order, owner, scheme);\n            this.encodeTrade(order, signature, tradeExecution);\n        });\n    }\n    /**\n     * Encodes the input interaction in the packed format accepted by the smart\n     * contract and adds it to the interactions encoded so far.\n     *\n     * @param stage The stage the interaction should be executed.\n     * @param interaction The interaction to encode.\n     */\n    encodeInteraction(interaction, stage = InteractionStage.INTRA) {\n        this._interactions[stage].push(normalizeInteraction(interaction));\n    }\n    /**\n     * Encodes order UIDs for gas refunds.\n     *\n     * @param settlement The address of the settlement contract.\n     * @param orderRefunds The order refunds to encode.\n     */\n    encodeOrderRefunds(orderRefunds) {\n        var _a, _b;\n        if (this.domain.verifyingContract === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        const filledAmounts = (_a = orderRefunds.filledAmounts) !== null && _a !== void 0 ? _a : [];\n        const preSignatures = (_b = orderRefunds.preSignatures) !== null && _b !== void 0 ? _b : [];\n        if (![...filledAmounts, ...preSignatures].every((orderUid) => ethers.utils.isHexString(orderUid, ORDER_UID_LENGTH))) {\n            throw new Error(\"one or more invalid order UIDs\");\n        }\n        this._orderRefunds.filledAmounts.push(...filledAmounts);\n        this._orderRefunds.preSignatures.push(...preSignatures);\n    }\n    /**\n     * Returns the encoded settlement parameters.\n     */\n    encodedSettlement(prices) {\n        return [\n            this.tokens,\n            this.clearingPrices(prices),\n            this.trades,\n            this.interactions,\n        ];\n    }\n    /**\n     * Returns an encoded settlement that exclusively performs setup interactions.\n     * This method can be used, for example, to set the settlement contract's\n     * allowances to other protocols it may interact with.\n     *\n     * @param interactions The list of setup interactions to encode.\n     */\n    static encodedSetup(...interactions) {\n        const encoder = new SettlementEncoder({ name: \"unused\" });\n        for (const interaction of interactions) {\n            encoder.encodeInteraction(interaction);\n        }\n        return encoder.encodedSettlement({});\n    }\n}\n/**\n * Decodes an order from a settlement trade.\n *\n * @param trade The trade to decode into an order.\n * @param tokens The list of token addresses as they appear in the settlement.\n * @returns The decoded order.\n */\nexport function decodeOrder(trade, tokens) {\n    const sellTokenIndex = BigNumber.from(trade.sellTokenIndex).toNumber();\n    const buyTokenIndex = BigNumber.from(trade.buyTokenIndex).toNumber();\n    if (Math.max(sellTokenIndex, buyTokenIndex) >= tokens.length) {\n        throw new Error(\"Invalid trade\");\n    }\n    return Object.assign({ sellToken: tokens[sellTokenIndex], buyToken: tokens[buyTokenIndex], receiver: trade.receiver, sellAmount: trade.sellAmount, buyAmount: trade.buyAmount, validTo: BigNumber.from(trade.validTo).toNumber(), appData: trade.appData, feeAmount: trade.feeAmount }, decodeOrderFlags(trade.flags));\n}\n//# sourceMappingURL=settlement.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, constants } from \"ethers\";\nimport fetch from \"node-fetch\";\nimport { normalizeOrder, OrderKind, } from \"./order\";\nimport { encodeSignatureData } from \"./settlement\";\nimport { SigningScheme } from \"./sign\";\nexport var Environment;\n(function (Environment) {\n    Environment[Environment[\"Dev\"] = 0] = \"Dev\";\n    Environment[Environment[\"Prod\"] = 1] = \"Prod\";\n})(Environment || (Environment = {}));\nexport const LIMIT_CONCURRENT_REQUESTS = 5;\nexport function apiUrl(environment, network) {\n    switch (environment) {\n        case Environment.Dev:\n            return `https://barn.api.cow.fi/${network}`;\n        case Environment.Prod:\n            return `https://api.cow.fi/${network}`;\n        default:\n            throw new Error(\"Invalid environment\");\n    }\n}\nexport var QuotePriceQuality;\n(function (QuotePriceQuality) {\n    QuotePriceQuality[\"FAST\"] = \"fast\";\n    QuotePriceQuality[\"OPTIMAL\"] = \"optimal\";\n})(QuotePriceQuality || (QuotePriceQuality = {}));\nexport var GetQuoteErrorType;\n(function (GetQuoteErrorType) {\n    GetQuoteErrorType[\"SellAmountDoesNotCoverFee\"] = \"SellAmountDoesNotCoverFee\";\n    GetQuoteErrorType[\"NoLiquidity\"] = \"NoLiquidity\";\n    // other errors are added when necessary\n})(GetQuoteErrorType || (GetQuoteErrorType = {}));\nfunction apiKind(kind) {\n    switch (kind) {\n        case OrderKind.SELL:\n            return \"sell\";\n        case OrderKind.BUY:\n            return \"buy\";\n        default:\n            throw new Error(`Unsupported kind ${kind}`);\n    }\n}\nfunction apiSigningScheme(scheme) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return \"eip712\";\n        case SigningScheme.ETHSIGN:\n            return \"ethsign\";\n        case SigningScheme.EIP1271:\n            return \"eip1271\";\n        case SigningScheme.PRESIGN:\n            return \"presign\";\n        default:\n            throw new Error(`Unsupported signing scheme ${scheme}`);\n    }\n}\nfunction call(route, baseUrl, init) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = `${baseUrl}/api/v1/${route}`;\n        const response = yield fetch(url, init);\n        const body = yield response.text();\n        if (!response.ok) {\n            const error = new Error(`Calling \"${url} ${JSON.stringify(init)} failed with ${response.status}: ${body}`);\n            try {\n                error.apiError = JSON.parse(body);\n            }\n            catch (_a) {\n                // no api error\n            }\n            throw error;\n        }\n        return JSON.parse(body);\n    });\n}\nfunction estimateTradeAmount({ sellToken, buyToken, kind, amount, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const side = kind == OrderKind.SELL\n            ? {\n                kind: OrderKind.SELL,\n                sellAmountAfterFee: amount,\n            }\n            : {\n                kind: OrderKind.BUY,\n                buyAmountAfterFee: amount,\n            };\n        const { quote } = yield getQuote({ baseUrl }, Object.assign({ from: constants.AddressZero, sellToken,\n            buyToken, priceQuality: QuotePriceQuality.FAST }, side));\n        // The services return the quote token used for the price. The quote token\n        // is checked to make sure that the returned price meets our expectations.\n        if (quote.buyToken.toLowerCase() !== buyToken.toLowerCase()) {\n            throw new Error(`Price returned for sell token ${sellToken} uses an incorrect quote token (${quote.buyToken.toLowerCase()} instead of ${buyToken.toLowerCase()})`);\n        }\n        const estimatedAmount = kind == OrderKind.SELL ? quote.buyAmount : quote.sellAmount;\n        return BigNumber.from(estimatedAmount);\n    });\n}\nfunction placeOrder({ order, signature, baseUrl, from, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const normalizedOrder = normalizeOrder(order);\n        return yield call(\"orders\", baseUrl, {\n            method: \"post\",\n            body: JSON.stringify({\n                sellToken: normalizedOrder.sellToken,\n                buyToken: normalizedOrder.buyToken,\n                sellAmount: BigNumber.from(normalizedOrder.sellAmount).toString(),\n                buyAmount: BigNumber.from(normalizedOrder.buyAmount).toString(),\n                validTo: normalizedOrder.validTo,\n                appData: normalizedOrder.appData,\n                feeAmount: BigNumber.from(normalizedOrder.feeAmount).toString(),\n                kind: apiKind(order.kind),\n                partiallyFillable: normalizedOrder.partiallyFillable,\n                signature: encodeSignatureData(signature),\n                signingScheme: apiSigningScheme(signature.scheme),\n                receiver: normalizedOrder.receiver,\n                from,\n            }),\n            headers: { \"Content-Type\": \"application/json\" },\n        });\n    });\n}\nfunction getExecutedSellAmount({ uid, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield call(`orders/${uid}`, baseUrl);\n        return BigNumber.from(response.executedSellAmount);\n    });\n}\nfunction getQuote({ baseUrl }, quote) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Convert BigNumber into JSON strings (native serialisation is a hex object)\n        if (quote.sellAmountBeforeFee) {\n            quote.sellAmountBeforeFee = (quote).sellAmountBeforeFee.toString();\n        }\n        if (quote.sellAmountAfterFee) {\n            quote.sellAmountAfterFee = (quote).sellAmountAfterFee.toString();\n        }\n        if (quote.buyAmountAfterFee) {\n            quote.buyAmountAfterFee = (quote).buyAmountAfterFee.toString();\n        }\n        return call(\"quote\", baseUrl, {\n            method: \"post\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(quote),\n        });\n    });\n}\nexport class Api {\n    constructor(network, baseUrlOrEnv) {\n        this.network = network;\n        let baseUrl;\n        if (typeof baseUrlOrEnv === \"string\") {\n            baseUrl = baseUrlOrEnv;\n        }\n        else {\n            baseUrl = apiUrl(baseUrlOrEnv, network);\n        }\n        this.baseUrl = baseUrl;\n    }\n    apiCallParams() {\n        return { network: this.network, baseUrl: this.baseUrl };\n    }\n    estimateTradeAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return estimateTradeAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    placeOrder(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return placeOrder(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getExecutedSellAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getExecutedSellAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getQuote(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getQuote(this.apiCallParams(), query);\n        });\n    }\n}\n//# sourceMappingURL=api.js.map","import { utils } from \"ethers\";\n/**\n * The salt used when deterministically deploying smart contracts.\n */\nexport const SALT = utils.formatBytes32String(\"Mattresses in Berlin!\");\n/**\n * The contract used to deploy contracts deterministically with CREATE2.\n * The address is chosen by the hardhat-deploy library.\n * It is the same in any EVM-based network.\n *\n * https://github.com/Arachnid/deterministic-deployment-proxy\n */\nexport const DEPLOYER_CONTRACT = \"0x4e59b44847b379578588920ca78fbf26c0b4956c\";\n/**\n * Dictionary containing all deployed contract names.\n */\nexport const CONTRACT_NAMES = {\n    authenticator: \"GPv2AllowListAuthentication\",\n    settlement: \"GPv2Settlement\",\n    tradeSimulator: \"GPv2TradeSimulator\",\n};\n/**\n * Computes the deterministic address at which the contract will be deployed.\n * This address does not depend on which network the contract is deployed to.\n *\n * @param contractName Name of the contract for which to find the address.\n * @param deploymentArguments Extra arguments that are necessary to deploy.\n * @returns The address that is expected to store the deployed code.\n */\nexport function deterministicDeploymentAddress({ abi, bytecode }, deploymentArguments) {\n    const contractInterface = new utils.Interface(abi);\n    const deployData = utils.hexConcat([\n        bytecode,\n        contractInterface.encodeDeploy(deploymentArguments),\n    ]);\n    return utils.getCreate2Address(DEPLOYER_CONTRACT, SALT, utils.keccak256(deployData));\n}\n//# sourceMappingURL=deploy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, Contract, ethers } from \"ethers\";\n/**\n * Compute an EIP-1967 slot for the specified name. The proxy contract used by\n * `hardhat-deploy` implements EIP-1967 (Standard Proxy Storage Slot).\n *\n * <https://eips.ethereum.org/EIPS/eip-1967>.\n */\nfunction slot(name) {\n    return ethers.utils.defaultAbiCoder.encode([\"bytes32\"], [BigNumber.from(ethers.utils.id(name)).sub(1)]);\n}\nconst IMPLEMENTATION_STORAGE_SLOT = slot(\"eip1967.proxy.implementation\");\nconst OWNER_STORAGE_SLOT = slot(\"eip1967.proxy.admin\");\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the contract storing the proxy implementation.\n */\nexport function implementationAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [implementation] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, IMPLEMENTATION_STORAGE_SLOT));\n        return implementation;\n    });\n}\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the administrator of the proxy.\n */\nexport function ownerAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [owner] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, OWNER_STORAGE_SLOT));\n        return owner;\n    });\n}\n/**\n * EIP-173 proxy ABI in \"human-readable ABI\" format. The proxy used by the\n * deployment plugin implements this interface, and copying it here avoids\n * pulling in `hardhat` as a dependency for just this ABI.\n *\n * <https://eips.ethereum.org/EIPS/eip-173#specification>\n */\nexport const EIP173_PROXY_ABI = [\n    \"event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)\",\n    \"function owner() view external returns(address)\",\n    \"function transferOwnership(address newOwner) external\",\n    \"function supportsInterface(bytes4 interfaceID) external view returns (bool)\",\n];\n/**\n * Returns the proxy interface for the specified address.\n *\n * @param contract The proxy contract to return a proxy interface for.\n * @returns A Ethers.js contract instance for interacting with the proxy.\n */\nexport function proxyInterface(contract) {\n    var _a;\n    return new Contract(contract.address, EIP173_PROXY_ABI, (_a = contract.signer) !== null && _a !== void 0 ? _a : contract.provider);\n}\n//# sourceMappingURL=proxy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\n/**\n * Balancer Vault partial ABI interface.\n *\n * This definition only contains the Vault methods that are used by GPv2 Vault\n * relayer. It is copied here to avoid relying on build artifacts.\n */\nexport const VAULT_INTERFACE = new ethers.utils.Interface([\n    \"function manageUserBalance((uint8, address, uint256, address, address)[])\",\n    \"function batchSwap(uint8, (bytes32, uint256, uint256, uint256, bytes)[], address[], (address, bool, address, bool), int256[], uint256)\",\n]);\n/**\n * Grants the required roles to the specified Vault relayer.\n *\n * This method is intended to be called by the Balancer Vault admin, and **not**\n * traders. It is included in the exported TypeScript library for completeness\n * and \"documentation\".\n *\n * @param authorizer The Vault authorizer contract that manages access.\n * @param vaultAddress The address to the Vault.\n * @param vaultRelayerAddress The address to the GPv2 Vault relayer contract.\n */\nexport function grantRequiredRoles(authorizer, vaultAddress, vaultRelayerAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const name in VAULT_INTERFACE.functions) {\n            yield authorizer.grantRole(ethers.utils.solidityKeccak256([\"uint256\", \"bytes4\"], [vaultAddress, VAULT_INTERFACE.getSighash(name)]), vaultRelayerAddress);\n        }\n    });\n}\n//# sourceMappingURL=vault.js.map","import { utils, providers, BigNumber } from 'ethers'\nimport {\n  COMPOSABLE_COW_CONTRACT_ADDRESS,\n  EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS,\n  SupportedChainId,\n} from '../common'\nimport { ExtensibleFallbackHandler__factory } from './generated'\nimport { BlockInfo, ConditionalOrderParams } from './types'\nimport { Order, OrderBalance, OrderKind } from '@wowswapfork/contracts'\nimport { GPv2Order } from './generated/ComposableCoW'\n\nconst ERC20_BALANCE_VALUES = ['erc20', '0x5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9']\nconst EXTERNAL_BALANCE_VALUES = ['external', '0xabee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632']\nconst INTERNAL_BALANCE_VALUES = ['internal', '0x4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce']\nconst SELL_KIND_VALUES = ['sell', '0xf3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775']\nconst BUY_KIND_VALUES = ['buy', '0x6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc']\n\n// Define the ABI tuple for the ConditionalOrderParams struct\nexport const CONDITIONAL_ORDER_PARAMS_ABI = ['tuple(address handler, bytes32 salt, bytes staticInput)']\n\nexport const DEFAULT_TOKEN_FORMATTER = (address: string, amount: BigNumber) => `${amount}@${address}`\n\nexport function isExtensibleFallbackHandler(handler: string, chainId: SupportedChainId): boolean {\n  return handler === EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId]\n}\n\nexport function isComposableCow(handler: string, chainId: SupportedChainId): boolean {\n  return handler === COMPOSABLE_COW_CONTRACT_ADDRESS[chainId]\n}\n\nexport async function getDomainVerifier(\n  safe: string,\n  domain: string,\n  chainId: SupportedChainId,\n  provider: providers.Provider\n): Promise<string> {\n  const contract = ExtensibleFallbackHandler__factory.connect(\n    EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId],\n    provider\n  )\n  return await contract.callStatic.domainVerifiers(safe, domain)\n}\n\nexport function createSetDomainVerifierTx(domain: string, verifier: string): string {\n  return ExtensibleFallbackHandler__factory.createInterface().encodeFunctionData('setDomainVerifier', [\n    domain,\n    verifier,\n  ])\n}\n\n/**\n * Encode the `ConditionalOrderParams` for the conditional order.\n *\n * @param params The `ConditionalOrderParams` struct representing the conditional order as taken from a merkle tree.\n * @returns The ABI-encoded conditional order.\n * @see ConditionalOrderParams\n */\nexport function encodeParams(params: ConditionalOrderParams): string {\n  return utils.defaultAbiCoder.encode(CONDITIONAL_ORDER_PARAMS_ABI, [params])\n}\n\n/**\n * Decode the `ConditionalOrderParams` for the conditional order.\n *\n * @param encoded The encoded conditional order.\n * @returns The decoded conditional order.\n */\nexport function decodeParams(encoded: string): ConditionalOrderParams {\n  const { handler, salt, staticInput } = utils.defaultAbiCoder.decode(CONDITIONAL_ORDER_PARAMS_ABI, encoded)[0]\n  return { handler, salt, staticInput }\n}\n\n/**\n * Helper method for validating ABI types.\n * @param types ABI types to validate against.\n * @param values The values to validate.\n * @returns {boolean} Whether the values are valid ABI for the given types.\n */\nexport function isValidAbi(types: readonly (string | utils.ParamType)[], values: any[]): boolean {\n  try {\n    utils.defaultAbiCoder.encode(types, values)\n  } catch (e) {\n    return false\n  }\n  return true\n}\n\nexport async function getBlockInfo(provider: providers.Provider): Promise<BlockInfo> {\n  const block = await provider.getBlock('latest')\n\n  return {\n    blockNumber: block.number,\n    blockTimestamp: block.timestamp,\n  }\n}\n\nexport function formatEpoch(epoch: number): string {\n  return new Date(epoch * 1000).toISOString()\n}\n\n/**\n * Convert a balance source/destination hash to a string\n *\n * @param balance balance source/destination hash\n * @returns string representation of the balance\n * @throws if the balance is not recognized\n */\nfunction balanceToString(balance: string) {\n  if (ERC20_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.ERC20\n  } else if (EXTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.EXTERNAL\n  } else if (INTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.INTERNAL\n  } else {\n    throw new Error(`Unknown balance type: ${balance}`)\n  }\n}\n\n/**\n * Convert an order kind hash to a string\n * @param kind of order in hash format\n * @returns string representation of the order kind\n */\nfunction kindToString(kind: string) {\n  if (SELL_KIND_VALUES.includes(kind)) {\n    return OrderKind.SELL\n  } else if (BUY_KIND_VALUES.includes(kind)) {\n    return OrderKind.BUY\n  } else {\n    throw new Error(`Unknown kind: ${kind}`)\n  }\n}\n\nexport function fromStructToOrder(order: GPv2Order.DataStruct): Order {\n  const {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    buyTokenBalance,\n    sellTokenBalance,\n    feeAmount,\n    kind,\n    receiver,\n    validTo,\n    partiallyFillable,\n    appData,\n  } = order\n\n  return {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    feeAmount,\n    receiver,\n    partiallyFillable,\n    appData,\n    validTo: Number(validTo),\n    kind: kindToString(kind.toString()),\n    sellTokenBalance: balanceToString(sellTokenBalance.toString()),\n    buyTokenBalance: balanceToString(buyTokenBalance.toString()),\n  }\n}\n","import { providers } from 'ethers'\nimport { COMPOSABLE_COW_CONTRACT_ADDRESS, SupportedChainId } from '../common'\nimport { ComposableCoW, ComposableCoW__factory } from './generated'\nimport { ComposableCoWInterface } from './generated/ComposableCoW'\n\nlet composableCowInterfaceCache: ComposableCoWInterface | undefined\nlet composableCowContractCache: ComposableCoW | undefined\n\nexport function getComposableCowInterface(): ComposableCoWInterface {\n  if (!composableCowInterfaceCache) {\n    composableCowInterfaceCache = ComposableCoW__factory.createInterface()\n  }\n\n  return composableCowInterfaceCache\n}\n\nexport function getComposableCow(chain: SupportedChainId, provider: providers.Provider): ComposableCoW {\n  if (!composableCowContractCache) {\n    composableCowContractCache = ComposableCoW__factory.connect(COMPOSABLE_COW_CONTRACT_ADDRESS[chain], provider)\n  }\n\n  return composableCowContractCache\n}\n","import { BigNumber, constants, ethers, utils } from 'ethers'\nimport { GPv2Order, IConditionalOrder } from './generated/ComposableCoW'\n\nimport { decodeParams, encodeParams, fromStructToOrder } from './utils'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  IsValidResult,\n  OwnerContext,\n  PollParams,\n  PollResult,\n  PollResultCode,\n  PollResultErrors,\n} from './types'\nimport { getComposableCow, getComposableCowInterface } from './contracts'\nimport { OrderBookApi, UID } from '../order-book'\nimport { computeOrderUid } from '../utils'\n\nconst orderBookCache: Record<string, OrderBookApi> = {}\n\n/**\n * An abstract base class from which all conditional orders should inherit.\n *\n * This class provides some basic functionality to help with handling conditional orders,\n * such as:\n * - Validating the conditional order\n * - Creating a human-readable string representation of the conditional order\n * - Serializing the conditional order for use with the `IConditionalOrder` struct\n * - Getting any dependencies for the conditional order\n * - Getting the off-chain input for the conditional order\n *\n * **NOTE**: Instances of conditional orders have an `id` property that is a `keccak256` hash of\n *           the serialized conditional order.\n */\nexport abstract class ConditionalOrder<D, S> {\n  public readonly handler: string\n  public readonly salt: string\n  public readonly data: D\n  public readonly staticInput: S\n  public readonly hasOffChainInput: boolean\n\n  /**\n   * A constructor that provides some basic validation for the conditional order.\n   *\n   * This constructor **MUST** be called by any class that inherits from `ConditionalOrder`.\n   *\n   * **NOTE**: The salt is optional and will be randomly generated if not provided.\n   * @param handler The address of the handler for the conditional order.\n   * @param salt A 32-byte string used to salt the conditional order.\n   * @param data The data of the order\n   * @param hasOffChainInput Whether the conditional order has off-chain input.\n   * @throws If the handler is not a valid ethereum address.\n   * @throws If the salt is not a valid 32-byte string.\n   */\n  constructor(params: ConditionalOrderArguments<D>) {\n    const { handler, salt = utils.keccak256(utils.randomBytes(32)), data, hasOffChainInput = false } = params\n    // Verify input to the constructor\n    // 1. Verify that the handler is a valid ethereum address\n    if (!ethers.utils.isAddress(handler)) {\n      throw new Error(`Invalid handler: ${handler}`)\n    }\n\n    // 2. Verify that the salt is a valid 32-byte string usable with ethers\n    if (!ethers.utils.isHexString(salt) || ethers.utils.hexDataLength(salt) !== 32) {\n      throw new Error(`Invalid salt: ${salt}`)\n    }\n\n    this.handler = handler\n    this.salt = salt\n    this.data = data\n    this.staticInput = this.transformDataToStruct(data)\n\n    this.hasOffChainInput = hasOffChainInput\n  }\n\n  // TODO: https://github.com/cowprotocol/cow-sdk/issues/155\n  abstract get isSingleOrder(): boolean\n\n  /**\n   * Get a descriptive name for the type of the conditional order (i.e twap, dca, etc).\n   *\n   * @returns {string} The concrete type of the conditional order.\n   */\n  abstract get orderType(): string\n\n  /**\n   * Get the context dependency for the conditional order.\n   *\n   * This is used when calling `createWithContext` or `setRootWithContext` on a ComposableCoW-enabled Safe.\n   * @returns The context dependency.\n   */\n  get context(): ContextFactory | undefined {\n    return undefined\n  }\n\n  assertIsValid(): void {\n    const isValidResult = this.isValid()\n    if (!isValidResult.isValid) {\n      throw new Error(`Invalid order: ${isValidResult.reason}`)\n    }\n  }\n\n  abstract isValid(): IsValidResult\n\n  /**\n   * Get the calldata for creating the conditional order.\n   *\n   * This will automatically determine whether or not to use `create` or `createWithContext` based on the\n   * order type's context dependency.\n   *\n   * **NOTE**: By default, this will cause the create to emit the `ConditionalOrderCreated` event.\n   * @returns The calldata for creating the conditional order.\n   */\n  get createCalldata(): string {\n    this.assertIsValid()\n\n    const context = this.context\n    const composableCow = getComposableCowInterface()\n    const paramsStruct: IConditionalOrder.ConditionalOrderParamsStruct = {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n\n    if (context) {\n      // Create (with context)\n      const contextArgsAbi = context.factoryArgs\n        ? utils.defaultAbiCoder.encode(context.factoryArgs.argsType, context.factoryArgs.args)\n        : '0x'\n      return composableCow.encodeFunctionData('createWithContext', [\n        paramsStruct,\n        context.address,\n        contextArgsAbi,\n        true,\n      ])\n    } else {\n      // Create\n      return composableCow.encodeFunctionData('create', [paramsStruct, true])\n    }\n  }\n\n  /**\n   * Get the calldata for removing a conditional order that was created as a single order.\n   * @returns The calldata for removing the conditional order.\n   */\n  get removeCalldata(): string {\n    this.assertIsValid()\n\n    return getComposableCowInterface().encodeFunctionData('remove', [this.id])\n  }\n\n  /**\n   * Calculate the id of the conditional order (which also happens to be the key used for `ctx` in the ComposableCoW contract).\n   *\n   * This is a `keccak256` hash of the serialized conditional order.\n   * @returns The id of the conditional order.\n   */\n  get id(): string {\n    return utils.keccak256(this.serialize())\n  }\n\n  /**\n   * The context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet\n   *\n   * The context, relates to the 'ctx' in the contract: https://github.com/cowprotocol/composable-cow/blob/c7fb85ab10c05e28a1632ba97a1749fb261fcdfb/src/interfaces/IConditionalOrder.sol#L38\n   */\n  protected get ctx(): string {\n    return this.isSingleOrder ? this.id : constants.HashZero\n  }\n\n  /**\n   * Get the `leaf` of the conditional order. This is the data that is used to create the merkle tree.\n   *\n   * For the purposes of this library, the `leaf` is the `ConditionalOrderParams` struct.\n   * @returns The `leaf` of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  get leaf(): ConditionalOrderParams {\n    return {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n  }\n\n  /**\n   * Calculate the id of the conditional order.\n   * @param leaf The `leaf` representing the conditional order.\n   * @returns The id of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  static leafToId(leaf: ConditionalOrderParams): string {\n    return utils.keccak256(encodeParams(leaf))\n  }\n\n  /**\n   * If the conditional order has off-chain input, return it!\n   *\n   * **NOTE**: This should be overridden by any conditional order that has off-chain input.\n   * @returns The off-chain input.\n   */\n  get offChainInput(): string {\n    return '0x'\n  }\n\n  /**\n   * Create a human-readable string representation of the conditional order.\n   *\n   * @param tokenFormatter An optional function that takes an address and an amount and returns a human-readable string.\n   */\n  abstract toString(tokenFormatter?: (address: string, amount: BigNumber) => string): string\n\n  /**\n   * Serializes the conditional order into it's ABI-encoded form.\n   *\n   * @returns The equivalent of `IConditionalOrder.Params` for the conditional order.\n   */\n  abstract serialize(): string\n\n  /**\n   * Encode the `staticInput` for the conditional order.\n   *\n   * @returns The ABI-encoded `staticInput` for the conditional order.\n   * @see ConditionalOrderParams\n   */\n  abstract encodeStaticInput(): string\n\n  /**\n   * A helper function for generically serializing a conditional order's static input.\n   *\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param data The order's data struct.\n   * @returns An ABI-encoded representation of the order's data struct.\n   */\n  protected encodeStaticInputHelper(orderDataTypes: string[], staticInput: S): string {\n    return utils.defaultAbiCoder.encode(orderDataTypes, [staticInput])\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   *\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  async poll(params: PollParams): Promise<PollResult> {\n    const { chainId, owner, provider, orderbookApiConfig } = params\n    const composableCow = getComposableCow(chainId, provider)\n\n    try {\n      const isValid = this.isValid()\n      // Do a validation first\n      if (!isValid.isValid) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `InvalidConditionalOrder. Reason: ${isValid.reason}`,\n        }\n      }\n\n      // Let the concrete Conditional Order decide about the poll result\n      const pollResult = await this.pollValidate(params)\n      if (pollResult) {\n        return pollResult\n      }\n\n      // Check if the owner authorized the order\n      const isAuthorized = await this.isAuthorized(params)\n      if (!isAuthorized) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `NotAuthorized: Order ${this.id} is not authorized for ${owner} on chain ${chainId}`,\n        }\n      }\n\n      // Lastly, try to get the tradeable order and signature\n      const [order, signature] = await composableCow.getTradeableOrderWithSignature(\n        owner,\n        this.leaf,\n        this.offChainInput,\n        []\n      )\n\n      let orderBookApi = orderBookCache[chainId]\n      if (!orderBookApi) {\n        orderBookApi = new OrderBookApi({ ...orderbookApiConfig, chainId })\n        orderBookCache[chainId] = orderBookApi\n      }\n\n      const orderUid = await computeOrderUid(chainId, owner, fromStructToOrder(order))\n\n      // Check if the order is already in the order book\n      const isOrderInOrderbook = await orderBookApi\n        .getOrder(orderUid)\n        .then(() => true)\n        .catch(() => false)\n\n      // Let the concrete Conditional Order decide about the poll result (in the case the order is already in the orderbook)\n      if (isOrderInOrderbook) {\n        const pollResult = await this.handlePollFailedAlreadyPresent(orderUid, order, params)\n        if (pollResult) {\n          return pollResult\n        }\n\n        return {\n          result: PollResultCode.TRY_NEXT_BLOCK,\n          reason: 'Order already in orderbook',\n        }\n      }\n\n      return {\n        result: PollResultCode.SUCCESS,\n        order,\n        signature,\n      }\n    } catch (error) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        error: error,\n      }\n    }\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param params owner context, to be able to check if the order is authorized\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  public isAuthorized(params: OwnerContext): Promise<boolean> {\n    const { chainId, owner, provider } = params\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.singleOrders(owner, this.id)\n  }\n\n  /**\n   * Checks the value in the cabinet for a given owner and chain\n   *\n   * @param params owner context, to be able to check the cabinet\n   */\n  public cabinet(params: OwnerContext): Promise<string> {\n    const { chainId, owner, provider } = params\n\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.cabinet(owner, this.ctx)\n  }\n\n  /**\n   * Allow concrete conditional orders to perform additional validation for the poll method.\n   *\n   * This will allow the concrete orders to decide when an order shouldn't be polled again. For example, if the orders is expired.\n   * It also allows to signal when should the next check be done. For example, an order could signal that the validations will fail until a certain time or block.\n   *\n   * @param params The poll parameters\n   *\n   * @returns undefined if the concrete order can't make a decision. Otherwise, it returns a PollResultErrors object.\n   */\n  protected abstract pollValidate(params: PollParams): Promise<PollResultErrors | undefined>\n\n  /**\n   * This method lets the concrete conditional order decide what to do if the order yielded in the polling is already present in the Orderbook API.\n   *\n   * The concrete conditional order will have a chance to schedule the next poll.\n   * For example, a TWAP order that has the current part already in the orderbook, can signal that the next poll should be done at the start time of the next part.\n   *\n   * @param params\n   */\n  protected abstract handlePollFailedAlreadyPresent(\n    orderUid: UID,\n    order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined>\n\n  /**\n   * Convert the struct that the contract expect as an encoded `staticInput` into a friendly data object modelling the smart order.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformStructToData(params: S): D\n\n  /**\n   * Converts a friendly data object modelling the smart order into the struct that the contract expect as an encoded `staticInput`.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformDataToStruct(params: D): S\n\n  /**\n   * A helper function for generically deserializing a conditional order.\n   * @param s The ABI-encoded `IConditionalOrder.Params` struct to deserialize.\n   * @param handler Address of the handler for the conditional order.\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param callback A callback function that takes the deserialized data struct and the salt and returns an instance of the class.\n   * @returns An instance of the conditional order class.\n   */\n  protected static deserializeHelper<T>(\n    s: string,\n    handler: string,\n    orderDataTypes: string[],\n    callback: (d: any, salt: string) => T\n  ): T {\n    try {\n      // First, decode the `IConditionalOrder.Params` struct\n      const { handler: recoveredHandler, salt, staticInput } = decodeParams(s)\n\n      // Second, verify that the recovered handler is the correct handler\n      if (!(recoveredHandler == handler)) throw new Error('HandlerMismatch')\n\n      // Third, decode the data struct\n      const [d] = utils.defaultAbiCoder.decode(orderDataTypes, staticInput)\n\n      // Create a new instance of the class\n      return callback(d, salt)\n    } catch (e: any) {\n      if (e.message === 'HandlerMismatch') {\n        throw e\n      } else {\n        throw new Error('InvalidSerializedConditionalOrder')\n      }\n    }\n  }\n}\n","import type { Order } from '@wowswapfork/contracts'\nimport type { SupportedChainId } from './common'\nimport { OrderSigningUtils } from './order-signing'\n\nexport async function computeOrderUid(chainId: SupportedChainId, owner: string, order: Order): Promise<string> {\n  const { computeOrderUid: _computeOrderUid } = await import('@wowswapfork/contracts')\n  const domain = await OrderSigningUtils.getDomain(chainId)\n\n  return _computeOrderUid(domain, order, owner)\n}\n","import { StandardMerkleTree } from '@openzeppelin/merkle-tree'\nimport { BigNumber, providers, utils } from 'ethers'\n\nimport { SupportedChainId } from '../common'\n\nimport { ComposableCoW, GPv2Order } from './generated/ComposableCoW'\nimport { ProofLocation, ProofWithParams, ConditionalOrderParams } from './types'\nimport { ConditionalOrder } from './ConditionalOrder'\nimport { getComposableCow } from './contracts'\n\nconst CONDITIONAL_ORDER_LEAF_ABI = ['address', 'bytes32', 'bytes']\n\nconst PAYLOAD_EMITTED_ABI = ['tuple(bytes32[] proof, tuple(address handler, bytes32 salt, bytes staticInput) params)[]']\n\nexport type Orders = Record<string, ConditionalOrder<unknown, unknown>>\n\n/**\n * Multiplexer for conditional orders - using `ComposableCoW`!\n *\n * This class provides functionality to:\n * - Generate a merkle tree of conditional orders\n * - Generate proofs for all orders in the merkle tree\n * - Save proofs, with the ability to omit / skip specific conditional orders\n * - Support for passing an optional upload function to upload the proofs to a decentralized storage network\n */\nexport class Multiplexer {\n  static orderTypeRegistry: Record<string, new (...args: unknown[]) => ConditionalOrder<unknown, unknown>> = {}\n\n  public chain: SupportedChainId\n  public location: ProofLocation\n\n  private orders: Orders = {}\n  private tree?: StandardMerkleTree<string[]>\n  private ctx?: string\n\n  /**\n   * @param chain The `chainId` for where we're using `ComposableCoW`.\n   * @param orders An optional array of conditional orders to initialize the merkle tree with.\n   * @param root An optional root to verify against.\n   * @param location The location of the proofs for the conditional orders.\n   */\n  constructor(\n    chain: SupportedChainId,\n    orders?: Orders,\n    root?: string,\n    location: ProofLocation = ProofLocation.PRIVATE\n  ) {\n    this.chain = chain\n    this.location = location\n\n    // If orders are provided, the length must be > 0\n    if (orders && Object.keys(orders).length === 0) {\n      throw new Error('orders must have non-zero length')\n    }\n\n    // If orders are provided, so must a root, and vice versa\n    if ((orders && !root) || (!orders && root)) {\n      throw new Error('orders cannot have undefined root')\n    }\n\n    // can only proceed past here if both orders and root are provided, or neither are\n\n    // validate that no unknown order types are provided\n    for (const orderKey in orders) {\n      if (orders.hasOwnProperty(orderKey)) {\n        const order = orders[orderKey]\n        if (!Multiplexer.orderTypeRegistry.hasOwnProperty(order.orderType)) {\n          throw new Error(`Unknown order type: ${order.orderType}`)\n        }\n      }\n    }\n\n    // If orders (and therefore the root) are provided, generate the merkle tree\n    if (orders) {\n      this.orders = orders\n\n      // if generate was successful, we can verify the root\n      if (this.getOrGenerateTree().root !== root) {\n        throw new Error('root mismatch')\n      }\n    }\n  }\n\n  // --- user facing serialization methods ---\n\n  /**\n   * Given a serialized multiplexer, create the multiplexer and rehydrate all conditional orders.\n   * Integrity of the multiplexer will be verified by generating the merkle tree and verifying\n   * the root.\n   *\n   * **NOTE**: Before using this method, you must register all conditional order types using `Multiplexer.registerOrderType`.\n   * @param s The serialized multiplexer.\n   * @returns The multiplexer with all conditional orders rehydrated.\n   * @throws If the multiplexer cannot be deserialized.\n   * @throws If the merkle tree cannot be generated.\n   * @throws If the merkle tree cannot be verified against the root.\n   */\n  static fromJSON(s: string): Multiplexer {\n    // reviver function to deserialize the orders\n    const reviver = (k: string, v: any) => {\n      if (k === 'orders' && typeof v === 'object' && v !== null) {\n        const orders: Orders = {}\n\n        for (const orderKey in v) {\n          if (v.hasOwnProperty(orderKey)) {\n            const { orderType, ...orderData } = v[orderKey]\n\n            if (Multiplexer.orderTypeRegistry.hasOwnProperty(orderType)) {\n              const OrderConstructor = Multiplexer.orderTypeRegistry[orderType]\n              orders[orderKey] = new OrderConstructor(orderData)\n            } else {\n              throw new Error(`Unknown order type: ${orderType}`)\n            }\n          }\n        }\n\n        return orders\n      }\n\n      // Make sure we deserialize `BigNumber` correctly\n      if (typeof v === 'object' && v !== null && v.hasOwnProperty('type') && v.hasOwnProperty('hex')) {\n        if (v.type === 'BigNumber') {\n          return BigNumber.from(v)\n        }\n      }\n\n      return v\n    }\n\n    const { chain, orders, root, location } = JSON.parse(s, reviver)\n    const m = new Multiplexer(chain, orders, root)\n    m.location = location\n    return m\n  }\n\n  /**\n   * Serialize the multiplexer to JSON.\n   *\n   * This will include all state necessary to reconstruct the multiplexer, including the root.\n   * @remarks This will **NOT** include the merkle tree.\n   * @returns The JSON representation of the multiplexer, including the root but excluding the merkle tree.\n   */\n  toJSON(): string {\n    const root = this.getOrGenerateTree().root\n\n    // serialize the multiplexer, including the root but excluding the merkle tree.\n    return JSON.stringify({ ...this, root }, (k, v) => {\n      // filter out the merkle tree\n      if (k === 'tree') return undefined\n      if (typeof v === 'object' && v !== null && 'orderType' in v) {\n        const conditionalOrder = v as ConditionalOrder<unknown, unknown>\n        return {\n          ...conditionalOrder,\n          orderType: conditionalOrder.orderType,\n        }\n      }\n      // We do not do any custom serialization of `BigNumber` in order to preserve it's type.\n      return v\n    })\n  }\n\n  // --- crud methods ---\n\n  /**\n   * Add a conditional order to the merkle tree.\n   * @param order The order to add to the merkle tree.\n   */\n  add<T, P>(order: ConditionalOrder<T, P>): void {\n    order.assertIsValid()\n\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  /**\n   * Remove a conditional order from the merkle tree.\n   * @param id The id of the `ConditionalOrder` to remove from the merkle tree.\n   */\n  remove(id: string): void {\n    delete this.orders[id]\n    this.reset()\n  }\n\n  /**\n   * Update a given conditional order in the merkle tree.\n   * @param id The id of the `ConditionalOrder` to update.\n   * @param updater A function that takes the existing `ConditionalOrder` and context, returning an updated `ConditionalOrder`.\n   */\n  update(\n    id: string,\n    updater: (order: ConditionalOrder<unknown, unknown>, ctx?: string) => ConditionalOrder<unknown, unknown>\n  ): void {\n    // copy the existing order and update it, given the existing context (if any)\n    const order = updater(this.orders[id], this.ctx)\n    // delete the existing order\n    delete this.orders[id]\n\n    // add the updated order\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  // --- accessors ---\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param id The `id` of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` with the given `id`.\n   */\n  getById(id: string): ConditionalOrder<unknown, unknown> {\n    return this.orders[id]\n  }\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param i The index of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` at the given index.\n   */\n  getByIndex(i: number): ConditionalOrder<unknown, unknown> {\n    return this.orders[this.orderIds[i]]\n  }\n\n  /**\n   * Get all the conditional order ids in the multiplexer.\n   */\n  get orderIds(): string[] {\n    return Object.keys(this.orders)\n  }\n\n  get root(): string {\n    return this.getOrGenerateTree().root\n  }\n\n  /**\n   * Retrieve the merkle tree of orders, or generate it if it doesn't exist.\n   *\n   * **CAUTION**: Developers of the SDK should prefer to use this method instead of generating the\n   *              merkle tree themselves. This method makes use of caching to avoid generating the\n   *              merkle tree needlessly.\n   * @throws If the merkle tree cannot be generated.\n   * @returns The merkle tree for the current set of conditional orders.\n   */\n  private getOrGenerateTree(): StandardMerkleTree<string[]> {\n    if (!this.tree) {\n      this.tree = StandardMerkleTree.of(\n        Object.values(this.orders).map((order) => [...Object.values(order.leaf)]),\n        CONDITIONAL_ORDER_LEAF_ABI\n      )\n    }\n\n    return this.tree\n  }\n\n  // --- serialization for watchtowers / indexers ---\n\n  /**\n   * The primary method for watch towers to use when deserializing the proofs and parameters for the conditional orders.\n   * @param s The serialized proofs with parameters for consumption by watchtowers / indexers.\n   * @returns The `ProofWithParams` array.\n   * @throws If the `ProofWithParams` array cannot be deserialized.\n   */\n  static decodeFromJSON(s: string): ProofWithParams[] {\n    // no need to rehydrate `BigNumber` as this is fully ABI encoded\n    return JSON.parse(s)\n  }\n\n  /**\n   * The primary entry point for dapps integrating with `ComposableCoW` to generate the proofs and\n   * parameters for the conditional orders.\n   *\n   * After populating the multiplexer with conditional orders, this method can be used to generate\n   * the proofs and parameters for the conditional orders. The returned `ProofStruct` can then be\n   * used with `setRoot` or `setRootWithContext` on a `ComposableCoW`-enabled Safe.\n   *\n   * @param filter {@link getProofs}\n   * @parma locFn A function that takes the off-chain encoded input, and returns the `location`\n   *        for the `ProofStruct`, and the `data` for the `ProofStruct`.\n   * @returns The ABI-encoded `ProofStruct` for `setRoot` and `setRootWithContext`.\n   */\n  async prepareProofStruct(\n    location: ProofLocation = this.location,\n    filter?: (v: string[]) => boolean,\n    uploader?: (offChainEncoded: string) => Promise<string>\n  ): Promise<ComposableCoW.ProofStruct> {\n    const data = async (): Promise<string> => {\n      switch (location) {\n        case ProofLocation.PRIVATE:\n          return '0x'\n        case ProofLocation.EMITTED:\n          return this.encodeToABI(filter)\n        case ProofLocation.SWARM:\n        case ProofLocation.WAKU:\n        case ProofLocation.IPFS:\n          if (!uploader) throw new Error('Must provide an uploader function')\n          try {\n            return await uploader(this.encodeToJSON(filter))\n          } catch (e) {\n            throw new Error(`Error uploading to decentralized storage ${location}: ${e}`)\n          }\n        default:\n          throw new Error('Unsupported location')\n      }\n    }\n\n    return await data()\n      .then((d) => {\n        try {\n          // validate that `d` is a valid `bytes` ready to be abi-encoded\n          utils.hexlify(utils.arrayify(d))\n\n          // if we get here, we have a valid `data` field for the `ProofStruct`\n          // This means that if there was an upload function, it was called and the upload was successful\n          // note: we don't check if the location has changed because we don't care\n          this.location = location\n\n          return {\n            location,\n            data: d,\n          }\n        } catch (e) {\n          throw new Error(`data returned by uploader is invalid`)\n        }\n      })\n      .catch((e) => {\n        throw new Error(`Error preparing proof struct: ${e}`)\n      })\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  static async poll(\n    owner: string,\n    p: ProofWithParams,\n    chain: SupportedChainId,\n    provider: providers.Provider,\n    offChainInputFn?: (owner: string, params: ConditionalOrderParams) => Promise<string>\n  ): Promise<[GPv2Order.DataStruct, string]> {\n    const composableCow = getComposableCow(chain, provider)\n\n    const offChainInput = offChainInputFn ? await offChainInputFn(owner, p.params) : '0x'\n    return await composableCow.getTradeableOrderWithSignature(owner, p.params, offChainInput, p.proof)\n  }\n\n  /**\n   * The primary entry point for dumping the proofs and parameters for the conditional orders.\n   *\n   * This is to be used by watchtowers / indexers to store the proofs and parameters for the\n   * conditional orders off-chain. The encoding returned by this method may **NOT** contain all\n   * proofs and parameters, depending on the `filter` provided, and therefore should not be used\n   * to rehydrate the multiplexer from a user's perspective.\n   * @param filter {@link getProofs}\n   * @returns A JSON-encoded string of the proofs and parameters for the conditional orders.\n   */\n  dumpProofs(filter?: (v: string[]) => boolean): string {\n    return this.encodeToJSON(filter)\n  }\n\n  dumpProofsAndParams(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    return this.getProofs(filter)\n  }\n\n  /**\n   * Get the proofs with parameters for the conditional orders in the merkle tree.\n   * @param filter A function that takes a conditional order and returns a boolean indicating\n   *               whether the order should be included in the proof.\n   * @returns An array of proofs and their order's parameters for the conditional orders in the\n   *          merkle tree.\n   */\n  private getProofs(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    // Get a list of all entry indices in the tree, excluding any that don't match the filter\n    return [...this.getOrGenerateTree().entries()]\n      .map(([i, v]) => {\n        if ((filter && filter(v)) || filter === undefined) {\n          return { idx: i, value: v }\n        } else {\n          return undefined\n        }\n      })\n      .reduce((acc: ProofWithParams[], x) => {\n        if (x) {\n          const p: ConditionalOrderParams = {\n            handler: x.value[0],\n            salt: x.value[1],\n            staticInput: x.value[2],\n          }\n          acc.push({\n            proof: this.getOrGenerateTree().getProof(x.idx),\n            params: p,\n          })\n        }\n        return acc\n      }, [])\n  }\n\n  /**\n   * ABI-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns ABI-encoded `data` for the `ProofStruct`.\n   */\n  private encodeToABI(filter?: (v: string[]) => boolean): string {\n    return utils.defaultAbiCoder.encode(PAYLOAD_EMITTED_ABI, [this.getProofs(filter)])\n  }\n\n  /**\n   * JSON-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns The JSON-encoded data for storage off-chain.\n   */\n  private encodeToJSON(filter?: (v: string[]) => boolean): string {\n    return JSON.stringify(this.getProofs(filter))\n  }\n\n  /**\n   * A helper to reset the merkle tree.\n   */\n  private reset(): void {\n    this.tree = undefined\n  }\n\n  /**\n   * Register a conditional order type with the multiplexer.\n   *\n   * **CAUTION**: This is required for using `Multiplexer.fromJSON` and `Multiplexer.toJSON`.\n   * @param orderType The order type to register.\n   * @param conditionalOrderClass The class to use for the given order type.\n   */\n  public static registerOrderType(\n    orderType: string,\n    conditionalOrderClass: new (...args: any[]) => ConditionalOrder<unknown, unknown>\n  ) {\n    Multiplexer.orderTypeRegistry[orderType] = conditionalOrderClass\n  }\n\n  /**\n   * Reset the order type registry.\n   */\n  public static resetOrderTypeRegistry() {\n    Multiplexer.orderTypeRegistry = {}\n  }\n}\n","import { BigNumber, constants, utils } from 'ethers'\n\nimport { ConditionalOrder } from '../ConditionalOrder'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  OwnerContext,\n  IsValidResult,\n  PollParams,\n  PollResultCode,\n  PollResultErrors,\n} from '../types'\nimport { encodeParams, formatEpoch, getBlockInfo, isValidAbi } from '../utils'\nimport { GPv2Order } from '../generated/ComposableCoW'\n\n// The type of Conditional Order\nconst TWAP_ORDER_TYPE = 'twap'\n// The address of the TWAP handler contract\nexport const TWAP_ADDRESS = '0x6cF1e9cA41f7611dEf408122793c358a3d11E5a5'\n/**\n * The address of the `CurrentBlockTimestampFactory` contract\n *\n * **NOTE**: This is used in the event that TWAP's have a `t0` of `0`.\n */\nexport const CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS = '0x52eD56Da04309Aca4c3FECC595298d80C2f16BAc'\n\nexport const MAX_UINT32 = BigNumber.from(2).pow(32).sub(1) // 2^32 - 1\nexport const MAX_FREQUENCY = BigNumber.from(365 * 24 * 60 * 60) // 1 year\n\n// Define the ABI tuple for the TWAPData struct\nconst TWAP_STRUCT_ABI = [\n  'tuple(address sellToken, address buyToken, address receiver, uint256 partSellAmount, uint256 minPartLimit, uint256 t0, uint256 n, uint256 t, uint256 span, bytes32 appData)',\n]\n\n/**\n * Base parameters for a TWAP order. Shared by:\n *   - TwapStruct (modelling the contract's struct used for `staticInput`).\n *   - TwapData (modelling the friendly SDK interface).\n */\nexport type TwapDataBase = {\n  /**\n   * which token to sell\n   */\n  readonly sellToken: string\n\n  /**\n   * which token to buy\n   */\n  readonly buyToken: string\n\n  /**\n   * who to send the tokens to\n   */\n  readonly receiver: string\n\n  /**\n   * Meta-data associated with the order. Normally would be the keccak256 hash of the document generated in http://github.com/cowprotocol/app-data\n   *\n   * This hash should have been uploaded to the API https://api.cow.fi/docs/#/default/put_api_v1_app_data__app_data_hash_ and potentially to other data availability protocols like IPFS.\n   *\n   */\n  readonly appData: string\n}\n\n/**\n * Parameters for a TWAP order, as expected by the contract's `staticInput`.\n */\nexport interface TwapStruct extends TwapDataBase {\n  /**\n   * amount of sellToken to sell in each part\n   */\n  readonly partSellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought in each part\n   */\n  readonly minPartLimit: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly t0: BigNumber\n\n  /**\n   * number of parts\n   */\n  readonly n: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly t: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly span: BigNumber\n}\n\n/**\n * Parameters for a TWAP order, made a little more user-friendly for SDK users.\n *\n * @see {@link TwapStruct} for the native struct.\n */\nexport interface TwapData extends TwapDataBase {\n  /**\n   * total amount of sellToken to sell across the entire TWAP\n   */\n  readonly sellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought across the entire TWAP\n   */\n  readonly buyAmount: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly startTime?: StartTime\n\n  /**\n   * number of parts\n   */\n  readonly numberOfParts: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly timeBetweenParts: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly durationOfPart?: DurationOfPart\n}\n\nexport type DurationOfPart =\n  | { durationType: DurationType.AUTO }\n  | { durationType: DurationType.LIMIT_DURATION; duration: BigNumber }\n\nexport enum DurationType {\n  AUTO = 'AUTO',\n  LIMIT_DURATION = 'LIMIT_DURATION',\n}\n\nexport type StartTime =\n  | { startType: StartTimeValue.AT_MINING_TIME }\n  | { startType: StartTimeValue.AT_EPOCH; epoch: BigNumber }\n\nexport enum StartTimeValue {\n  AT_MINING_TIME = 'AT_MINING_TIME',\n  AT_EPOCH = 'AT_EPOCH',\n}\n\nconst DEFAULT_START_TIME: StartTime = { startType: StartTimeValue.AT_MINING_TIME }\nconst DEFAULT_DURATION_OF_PART: DurationOfPart = { durationType: DurationType.AUTO }\n\n/**\n * `ComposableCoW` implementation of a TWAP order.\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nexport class Twap extends ConditionalOrder<TwapData, TwapStruct> {\n  isSingleOrder = true\n\n  /**\n   * @see {@link ConditionalOrder.constructor}\n   * @throws If the TWAP order is invalid.\n   * @throws If the TWAP order is not ABI-encodable.\n   * @throws If the handler is not the TWAP address.\n   */\n  constructor(params: ConditionalOrderArguments<TwapData>) {\n    const { handler, salt, data: staticInput, hasOffChainInput } = params\n\n    // First, verify that the handler is the TWAP address\n    if (handler !== TWAP_ADDRESS) throw new Error(`InvalidHandler: Expected: ${TWAP_ADDRESS}, provided: ${handler}`)\n\n    // Third, construct the base class using transformed parameters\n    super({ handler: TWAP_ADDRESS, salt, data: staticInput, hasOffChainInput })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromData(data: TwapData, salt?: string): Twap {\n    return new Twap({ handler: TWAP_ADDRESS, data, salt })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromParams(params: ConditionalOrderParams): Twap {\n    return Twap.deserialize(encodeParams(params))\n  }\n\n  /**\n   * Enforces that TWAPs will commence at the beginning of a block by use of the\n   * `CurrentBlockTimestampFactory` contract to provide the current block timestamp\n   * as the start time of the TWAP.\n   */\n  get context(): ContextFactory | undefined {\n    if (this.staticInput.t0.gt(0)) {\n      return super.context\n    } else {\n      return {\n        address: CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS,\n        factoryArgs: undefined,\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc {@link ConditionalOrder.orderType}\n   */\n  get orderType(): string {\n    return TWAP_ORDER_TYPE\n  }\n\n  /**\n   * Validate the TWAP order.\n   * @param data The TWAP order to validate.\n   * @returns Whether the TWAP order is valid.\n   * @throws If the TWAP order is invalid.\n   * @see {@link TwapStruct} for the native struct.\n   */\n  isValid(): IsValidResult {\n    const error = (() => {\n      const {\n        sellToken,\n        sellAmount,\n        buyToken,\n        buyAmount,\n        startTime = DEFAULT_START_TIME,\n        numberOfParts,\n        timeBetweenParts,\n        durationOfPart = DEFAULT_DURATION_OF_PART,\n      } = this.data\n\n      // Verify that the order params are logically valid\n      if (!(sellToken != buyToken)) return 'InvalidSameToken'\n      if (!(sellToken != constants.AddressZero && buyToken != constants.AddressZero)) return 'InvalidToken'\n      if (!sellAmount.gt(constants.Zero)) return 'InvalidSellAmount'\n      if (!buyAmount.gt(constants.Zero)) return 'InvalidMinBuyAmount'\n      if (startTime.startType === StartTimeValue.AT_EPOCH) {\n        const t0 = startTime.epoch\n        if (!(t0.gte(constants.Zero) && t0.lt(MAX_UINT32))) return 'InvalidStartTime'\n      }\n      if (!(numberOfParts.gt(constants.One) && numberOfParts.lte(MAX_UINT32))) return 'InvalidNumParts'\n      if (!(timeBetweenParts.gt(constants.Zero) && timeBetweenParts.lte(MAX_FREQUENCY))) return 'InvalidFrequency'\n      if (durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n        if (!durationOfPart.duration.lte(timeBetweenParts)) return 'InvalidSpan'\n      }\n\n      // Verify that the staticInput derived from the data is ABI-encodable\n      if (!isValidAbi(TWAP_STRUCT_ABI, [this.staticInput])) return 'InvalidData'\n\n      // No errors\n      return undefined\n    })()\n\n    return error ? { isValid: false, reason: error } : { isValid: true }\n  }\n\n  protected async startTimestamp(params: OwnerContext): Promise<number> {\n    const { startTime } = this.data\n\n    if (startTime?.startType === StartTimeValue.AT_EPOCH) {\n      return startTime.epoch.toNumber()\n    }\n\n    const cabinet = await this.cabinet(params)\n    const rawCabinetEpoch = utils.defaultAbiCoder.decode(['uint256'], cabinet)[0] as BigNumber\n\n    // Guard against out-of-range cabinet epoch\n    if (rawCabinetEpoch.gt(MAX_UINT32)) {\n      throw new Error(`Cabinet epoch out of range: ${rawCabinetEpoch.toString()}`)\n    }\n\n    // Convert the cabinet epoch (bignumber) to a number.\n    const cabinetEpoch = rawCabinetEpoch.toNumber()\n\n    if (cabinetEpoch === 0) {\n      throw new Error('Cabinet is not set. Required for TWAP orders that start at mining time.')\n    }\n\n    return cabinetEpoch\n  }\n\n  /**\n   * Given the start timestamp of the TWAP, calculate the end timestamp.\n   * @dev As usually the `endTimestamp` is used when determining a TWAP's validity, we don't\n   *      do any lookup to the blockchain to determine the start timestamp, as this has likely\n   *      already been done during the verification flow.\n   * @dev Beware to handle the case of `span != 0` ie. `durationOfPart.durationType !== DurationType.AUTO`.\n   * @param startTimestamp The start timestamp of the TWAP.\n   * @returns The timestamp at which the TWAP will end.\n   */\n  protected endTimestamp(startTimestamp: number): number {\n    const { numberOfParts, timeBetweenParts, durationOfPart } = this.data\n\n    if (durationOfPart && durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n      return startTimestamp + numberOfParts.sub(1).mul(timeBetweenParts).add(durationOfPart.duration).toNumber()\n    }\n\n    return startTimestamp + numberOfParts.mul(timeBetweenParts).toNumber()\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param owner The owner of the conditional order.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  protected async pollValidate(params: PollParams): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    try {\n      const startTimestamp = await this.startTimestamp(params)\n\n      if (startTimestamp > blockTimestamp) {\n        // The start time hasn't started\n        return {\n          result: PollResultCode.TRY_AT_EPOCH,\n          epoch: startTimestamp,\n          reason: `TWAP hasn't started yet. Starts at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        }\n      }\n\n      const expirationTimestamp = this.endTimestamp(startTimestamp)\n      if (blockTimestamp >= expirationTimestamp) {\n        // The order has expired\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `TWAP has expired. Expired at ${expirationTimestamp} (${formatEpoch(expirationTimestamp)})`,\n        }\n      }\n\n      return undefined\n    } catch (err: any) {\n      if (err?.message?.includes('Cabinet is not set')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}. User likely removed the order.`,\n        }\n      } else if (err?.message?.includes('Cabinet epoch out of range')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set correctly\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}`,\n        }\n      }\n\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `Unexpected error: ${err.message}`,\n        error: err,\n      }\n    }\n  }\n\n  /**\n   * Handles the error when the order is already present in the orderbook.\n   *\n   * Given the current part is in the book, it will signal to Watch Tower what to do:\n   *   - Wait until the next part starts\n   *   - Don't try again if current part is the last one\n   *\n   * NOTE: The error messages will refer to the parts 1-indexed, so first part is 1, second part is 2, etc.\n   */\n  protected async handlePollFailedAlreadyPresent(\n    _orderUid: string,\n    _order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    const timeBetweenParts = this.data.timeBetweenParts.toNumber()\n    const { numberOfParts } = this.data\n    const startTimestamp = await this.startTimestamp(params)\n\n    if (blockTimestamp < startTimestamp) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP part hash't started. First TWAP part start at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        error: undefined,\n      }\n    }\n    const expireTime = numberOfParts.mul(timeBetweenParts).add(startTimestamp).toNumber()\n    if (blockTimestamp >= expireTime) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP is expired. Expired at ${expireTime} (${formatEpoch(expireTime)})`,\n        error: undefined,\n      }\n    }\n\n    // Get current part number\n    const currentPartNumber = Math.floor((blockTimestamp - startTimestamp) / timeBetweenParts)\n\n    // If current part is the last one\n    if (currentPartNumber === numberOfParts.toNumber() - 1) {\n      return {\n        result: PollResultCode.DONT_TRY_AGAIN,\n        reason: `Current active TWAP part (${\n          currentPartNumber + 1\n        }/${numberOfParts}) is already in the Order Book. This was the last TWAP part, no more orders need to be placed`,\n      }\n    }\n\n    // Next part start time\n    const nextPartStartTime = startTimestamp + (currentPartNumber + 1) * timeBetweenParts\n\n    /**\n     * Given we know, that TWAP part that is due in the current block is already in the Orderbook,\n     * Then, we can safely instruct that we should wait until the next TWAP part starts\n     */\n    return {\n      result: PollResultCode.TRY_AT_EPOCH,\n      epoch: nextPartStartTime,\n      reason: `Current active TWAP part (${\n        currentPartNumber + 1\n      }/${numberOfParts}) is already in the Order Book. TWAP part ${\n        currentPartNumber + 2\n      } doesn't start until ${nextPartStartTime} (${formatEpoch(nextPartStartTime)})`,\n    }\n  }\n\n  /**\n   * Serialize the TWAP order into it's ABI-encoded form.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  serialize(): string {\n    return encodeParams(this.leaf)\n  }\n\n  /**\n   * Get the encoded static input for the TWAP order.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  encodeStaticInput(): string {\n    return super.encodeStaticInputHelper(TWAP_STRUCT_ABI, this.staticInput)\n  }\n\n  /**\n   * Deserialize a TWAP order from it's ABI-encoded form.\n   * @param {string} twapSerialized ABI-encoded TWAP order to deserialize.\n   * @returns A deserialized TWAP order.\n   */\n  static deserialize(twapSerialized: string): Twap {\n    return super.deserializeHelper(\n      twapSerialized,\n      TWAP_ADDRESS,\n      TWAP_STRUCT_ABI,\n      (struct: TwapStruct, salt: string) =>\n        new Twap({\n          handler: TWAP_ADDRESS,\n          salt,\n          data: transformStructToData(struct),\n        })\n    )\n  }\n\n  /**\n   * Create a human-readable string representation of the TWAP order.\n   * @returns {string} A human-readable string representation of the TWAP order.\n   */\n  toString(): string {\n    const {\n      sellAmount,\n      sellToken,\n      buyAmount,\n      buyToken,\n      numberOfParts,\n      startTime = DEFAULT_START_TIME,\n      timeBetweenParts,\n      durationOfPart = DEFAULT_DURATION_OF_PART,\n      receiver,\n      appData,\n    } = this.data\n\n    const startTimeFormatted =\n      startTime.startType === StartTimeValue.AT_MINING_TIME ? 'AT_MINING_TIME' : startTime.epoch.toNumber()\n    const durationOfPartFormatted =\n      durationOfPart.durationType === DurationType.AUTO ? 'AUTO' : durationOfPart.duration.toNumber()\n\n    const details = {\n      sellAmount: sellAmount.toString(),\n      sellToken,\n      buyAmount: buyAmount.toString(),\n      buyToken,\n      numberOfParts: numberOfParts.toString(),\n      startTime: startTimeFormatted,\n      timeBetweenParts: timeBetweenParts.toNumber(),\n      durationOfPart: durationOfPartFormatted,\n      receiver,\n      appData,\n    }\n\n    return `${this.orderType} (${this.id}): ${JSON.stringify(details)}`\n  }\n\n  /**\n   * Transform parameters into a native struct.\n   *\n   * @param {TwapData} data As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformDataToStruct(data: TwapData): TwapStruct {\n    return transformDataToStruct(data)\n  }\n\n  /**\n   * Transform parameters into a TWAP order struct.\n   *\n   * @param {TwapData} params As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformStructToData(struct: TwapStruct): TwapData {\n    return transformStructToData(struct)\n  }\n}\n\n/**\n * Transform parameters into a native struct.\n *\n * @param {TwapData} data As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformDataToStruct(data: TwapData): TwapStruct {\n  const {\n    sellAmount,\n    buyAmount,\n    numberOfParts,\n    startTime: startTime = DEFAULT_START_TIME,\n    timeBetweenParts,\n    durationOfPart = DEFAULT_DURATION_OF_PART,\n    ...rest\n  } = data\n\n  const { partSellAmount, minPartLimit } =\n    numberOfParts && !numberOfParts.isZero()\n      ? {\n          partSellAmount: sellAmount.div(numberOfParts),\n          minPartLimit: buyAmount.div(numberOfParts),\n        }\n      : {\n          partSellAmount: constants.Zero,\n          minPartLimit: constants.Zero,\n        }\n\n  const span = durationOfPart.durationType === DurationType.AUTO ? constants.Zero : durationOfPart.duration\n  const t0 = startTime.startType === StartTimeValue.AT_MINING_TIME ? constants.Zero : startTime.epoch\n\n  return {\n    partSellAmount,\n    minPartLimit,\n    t0,\n    n: numberOfParts,\n    t: timeBetweenParts,\n    span,\n    ...rest,\n  }\n}\n\n/**\n * Transform parameters into a TWAP order struct.\n *\n * @param {TwapData} params As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformStructToData(struct: TwapStruct): TwapData {\n  const { n: numberOfParts, partSellAmount, minPartLimit, t: timeBetweenParts, t0: startEpoch, span, ...rest } = struct\n\n  const durationOfPart: DurationOfPart = span.isZero()\n    ? { durationType: DurationType.AUTO }\n    : { durationType: DurationType.LIMIT_DURATION, duration: span }\n\n  const startTime: StartTime = span.isZero()\n    ? { startType: StartTimeValue.AT_MINING_TIME }\n    : { startType: StartTimeValue.AT_EPOCH, epoch: startEpoch }\n\n  return {\n    sellAmount: partSellAmount.mul(numberOfParts),\n    buyAmount: minPartLimit.mul(numberOfParts),\n    startTime,\n    numberOfParts,\n    timeBetweenParts,\n    durationOfPart,\n    ...rest,\n  }\n}\n","import { ConditionalOrderRegistry } from '../ConditionalOrderFactory'\nimport { TWAP_ADDRESS, Twap } from './Twap'\nexport * from './Twap'\n\nexport const DEFAULT_CONDITIONAL_ORDER_REGISTRY: ConditionalOrderRegistry = {\n  // Registry of all known order types\n  [TWAP_ADDRESS]: (params) => Twap.fromParams(params),\n}\n","import { type ConditionalOrder } from './ConditionalOrder'\nimport { ConditionalOrderParams } from './types'\n\nexport type FromParams<D, S> = (params: ConditionalOrderParams) => ConditionalOrder<D, S>\nexport type ConditionalOrderRegistry = Record<string, FromParams<unknown, unknown>>\n\nexport class ConditionalOrderFactory {\n  public knownOrderTypes\n\n  constructor(registry: ConditionalOrderRegistry) {\n    this.knownOrderTypes = registry\n  }\n\n  public fromParams(params: ConditionalOrderParams): ConditionalOrder<unknown, unknown> | undefined {\n    const { handler } = params\n\n    const factory = this.knownOrderTypes[handler]\n    if (!factory) {\n      return undefined\n    }\n\n    return factory(params)\n  }\n}\n","export const DEFAULT_IPFS_READ_URI = 'https://gnosis.mypinata.cloud/ipfs'\nexport const DEFAULT_IPFS_WRITE_URI = 'https://api.pinata.cloud'\n"],"names":["SupportedChainId","ENVS_LIST","DEFAULT_COW_API_CONTEXT","env","chainId","MAINNET","CowError","Error","constructor","message","error_code","super","this","GPv2Settlement","JSON","parse","BUY_ETH_ADDRESS","EXTENSIBLE_FALLBACK_HANDLER","COMPOSABLE_COW","ALL_SUPPORTED_CHAIN_IDS","GOERLI","GNOSIS_CHAIN","MUMBAI","COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS","reduce","acc","address","EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS","COMPOSABLE_COW_CONTRACT_ADDRESS","transformOrder","order","ethflowData","userValidTo","validTo","owner","onchainUser","sellToken","transformEthFlowOrder","dto","executedFeeAmount","executedSurplusFee","totalFee","addTotalFeeToOrder","request","baseUrl","path","query","method","body","rateLimiter","backoffOpts","headers","Accept","url","init","stringify","Promise","resolve","backOff","removeTokens","then","fetch","response","getResponseBody","responseBody","status","reject","OrderBookApiError","e","statusText","STATUS_CODES_TO_RETRY","DEFAULT_BACKOFF_OPTIONS","numOfAttempts","maxDelay","Infinity","jitter","retry","error","includes","DEFAULT_LIMITER_OPTIONS","tokensPerInterval","interval","_exit","_temp","_catch","contentType","get","toLowerCase","startsWith","json","_await$response$json","text","_await$response$text","console","_result3","undefined","ORDER_BOOK_PROD_CONFIG","ORDER_BOOK_STAGING_CONFIG","cleanObjectFromUndefinedValues","obj","Object","keys","key","val","OrderBookApi","context","RateLimiter","limiterOpts","getVersion","contextOverride","getTrades","orderUid","URLSearchParams","getOrders","offset","limit","toString","orders","map","getTxOrders","txHash","getOrder","getOrderMultiEnv","getContextWithOverride","otherEnvs","filter","i","attemptsCount","fallback","nextEnv","catch","getQuote","requestBody","sendSignedOrderCancellations","sendOrder","getNativePrice","tokenAddress","getTotalSurplus","getAppData","appDataHash","uploadAppData","fullAppData","getSolverCompetition","auctionIdorTx","getOrderLink","getApiBaseUrls","baseUrls","params","BuyTokenDestination","EcdsaSigningScheme","OnchainOrderData","placementError","OrderCancellationError","errorType","OrderClass","OrderKind","OrderPostError","OrderStatus","PriceEstimationError","PriceQuality","ReplaceOrderError","SellTokenSource","SigningScheme","OrderKind$1","OrderQuoteSideKindBuy","OrderQuoteSideKindSell","SigningScheme$1","TOTALS_QUERY","gql","LAST_DAYS_VOLUME_QUERY","LAST_HOURS_VOLUME_QUERY","SUBGRAPH_BASE_URL","SUBGRAPH_PROD_CONFIG","SUBGRAPH_STAGING_CONFIG","getSignUtils","require","OrderSigningUtils","signer","signOrder","static","signOrderCancellation","orderUids","signOrderCancellations","getDomain","_TypedDataEncoder","hashDomain","Order","name","type","ProofLocation","PollResultCode","_abi","inputs","internalType","stateMutability","anonymous","indexed","components","outputs","ComposableCoW__factory","utils","Interface","signerOrProvider","Contract","abi","ExtensibleFallbackHandler__factory","OrderBalance","global","self","window","getGlobal","module","exports","default","bind","Headers","Request","Response","ORDER_TYPE_FIELDS","CANCELLATIONS_TYPE_FIELDS","ORDER_TYPE_HASH","ethers","id","join","timestamp","t","getTime","hashify","h","padStart","hexZeroPad","normalizeBuyTokenBalance","balance","ERC20","EXTERNAL","INTERNAL","normalizeOrder","_a","_b","receiver","constants","AddressZero","assign","sellTokenBalance","appData","buyTokenBalance","hashTypedData","domain","types","data","hash","hashOrder","hashOrderCancellations","OrderCancellations","packOrderUidParams","orderDigest","solidityPack","normalizeInteraction","interaction","value","callData","isTypedDataSigner","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","result","done","apply","EIP1271_MAGICVALUE","hexDataSlice","PRE_SIGNED","ecdsaSignTypedData","scheme","signature","EIP712","_signTypedData","ETHSIGN","signMessage","arrayify","joinSignature","splitSignature","encodeEip1271SignatureData","verifier","decodeEip1271SignatureData","arrayifiedSignature","getAddress","hexlify","slice","InteractionStage","FLAG_MASKS","kind","options","SELL","BUY","partiallyFillable","signingScheme","EIP1271","PRESIGN","encodeFlag","flag","index","findIndex","search","decodeFlag","numberFlags","BigNumber","from","toNumber","Math","clz32","length","mask","decoded","encodeSigningScheme","decodeSigningScheme","flags","encodeOrderFlags","decodeOrderFlags","encodeTradeFlags","encodeSignatureData","sig","encodeTrade","tokens","executedAmount","tradeFlags","o","sellTokenIndex","buyTokenIndex","buyToken","sellAmount","buyAmount","feeAmount","TokenRegistry","_tokens","_tokenMap","addresses","token","tokenIndex","push","SettlementEncoder","_trades","_interactions","PRE","INTRA","POST","_orderRefunds","filledAmounts","preSignatures","trades","interactions","encodedOrderRefunds","settlement","verifyingContract","iface","functionName","target","encodeFunctionData","clearingPrices","prices","price","signEncodeTrade","tradeExecution","encodeInteraction","stage","encodeOrderRefunds","orderRefunds","every","isHexString","encodedSettlement","encoder","Environment","QuotePriceQuality","GetQuoteErrorType","apiUrl","environment","network","Dev","Prod","apiKind","apiSigningScheme","call","route","ok","apiError","quote","sellAmountBeforeFee","sellAmountAfterFee","buyAmountAfterFee","SALT","formatBytes32String","DEPLOYER_CONTRACT","slot","defaultAbiCoder","encode","sub","IMPLEMENTATION_STORAGE_SLOT","OWNER_STORAGE_SLOT","EIP173_PROXY_ABI","VAULT_INTERFACE","getBlockInfo","provider","getBlock","block","blockNumber","number","blockTimestamp","ERC20_BALANCE_VALUES","EXTERNAL_BALANCE_VALUES","INTERNAL_BALANCE_VALUES","SELL_KIND_VALUES","BUY_KIND_VALUES","CONDITIONAL_ORDER_PARAMS_ABI","encodeParams","decodeParams","encoded","handler","salt","staticInput","decode","isValidAbi","values","formatEpoch","epoch","Date","toISOString","balanceToString","kindToString","fromStructToOrder","Number","composableCowInterfaceCache","composableCowContractCache","getComposableCowInterface","createInterface","getComposableCow","chain","connect","orderBookCache","ConditionalOrder","hasOffChainInput","keccak256","randomBytes","isAddress","hexDataLength","transformDataToStruct","assertIsValid","isValidResult","isValid","reason","createCalldata","composableCow","paramsStruct","encodeStaticInput","contextArgsAbi","factoryArgs","argsType","args","removeCalldata","serialize","ctx","isSingleOrder","HashZero","leaf","offChainInput","encodeStaticInputHelper","orderDataTypes","poll","_this","orderbookApiConfig","pollValidate","pollResult","isAuthorized","getTradeableOrderWithSignature","orderBookApi","computeOrderUid","_computeOrderUid","isOrderInOrderbook","_temp2","_result","SUCCESS","handlePollFailedAlreadyPresent","_result$reason","TRY_NEXT_BLOCK","DONT_TRY_AGAIN","UNEXPECTED_ERROR","callStatic","singleOrders","cabinet","s","callback","recoveredHandler","d","CONDITIONAL_ORDER_LEAF_ABI","PAYLOAD_EMITTED_ABI","Multiplexer","root","location","PRIVATE","tree","orderKey","hasOwnProperty","orderTypeRegistry","orderType","getOrGenerateTree","reviver","k","v","orderData","OrderConstructor","m","toJSON","conditionalOrder","add","reset","remove","update","updater","getById","getByIndex","orderIds","StandardMerkleTree","of","prepareProofStruct","uploader","EMITTED","encodeToABI","SWARM","WAKU","IPFS","encodeToJSON","p","offChainInputFn","proof","dumpProofs","dumpProofsAndParams","getProofs","entries","idx","x","getProof","conditionalOrderClass","TWAP_ADDRESS","CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS","MAX_UINT32","pow","MAX_FREQUENCY","TWAP_STRUCT_ABI","DurationType","StartTimeValue","DEFAULT_START_TIME","startType","AT_MINING_TIME","DEFAULT_DURATION_OF_PART","durationType","AUTO","Twap","deserialize","t0","gt","startTime","numberOfParts","timeBetweenParts","durationOfPart","Zero","AT_EPOCH","gte","lt","One","lte","LIMIT_DURATION","duration","startTimestamp","rawCabinetEpoch","cabinetEpoch","endTimestamp","mul","_this2","_getBlockInfo","blockInfo","TRY_AT_EPOCH","expirationTimestamp","err","_orderUid","_order","_this3","_getBlockInfo2","expireTime","currentPartNumber","floor","nextPartStartTime","twapSerialized","deserializeHelper","struct","transformStructToData","startTimeFormatted","durationOfPartFormatted","details","rest","partSellAmount","minPartLimit","isZero","div","span","n","startEpoch","DEFAULT_CONDITIONAL_ORDER_REGISTRY","fromParams","baseUrlOrEnv","apiCallParams","estimateTradeAmount","amount","side","priceQuality","FAST","estimatedAmount","placeOrder","normalizedOrder","getExecutedSellAmount","uid","executedSellAmount","authenticator","tradeSimulator","registry","knownOrderTypes","factory","DEFAULT_TOKEN_FORMATTER","API_NAME","getTotals","runQuery","totals","getLastDaysVolume","days","getLastHoursVolume","hours","variables","_this4","getEnvConfigs","trade","max","verifyTypedData","verifyMessage","bytecode","deploymentArguments","contractInterface","deployData","hexConcat","encodeDeploy","getCreate2Address","bytes","view","DataView","buffer","subarray","getUint32","getDomainVerifier","safe","contract","domainVerifiers","authorizer","vaultAddress","vaultRelayerAddress","functions","grantRole","solidityKeccak256","getSighash","proxy","implementation","getStorageAt"],"mappings":"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ACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEK,WAAY,CACV,CACEJ,aAAc,6BACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,cACNC,KAAM,UAGVK,aAAc,kDACdN,KAAM,SACNC,KAAM,SAER,CACEK,aAAc,yBACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,OACNC,KAAM,SAER,CACEK,aAAc,OACdN,KAAM,WACNC,KAAM,SAGVD,KAAM,oBACNW,QAAS,GACTJ,gBAAiB,aACjBN,KAAM,YAER,CACEI,OAAQ,GACRL,KAAM,kBACNW,QAAS,CACP,CACEL,aAAc,UACdN,KAAM,GACNC,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEC,aAAc,UACdN,KAAM,QACNC,KAAM,WAER,CACES,WAAY,CACV,CACEJ,aAAc,6BACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,cACNC,KAAM,UAGVK,aAAc,kDACdN,KAAM,SACNC,KAAM,SAER,CACEK,aAAc,QACdN,KAAM,gBACNC,KAAM,SAER,CACEK,aAAc,YACdN,KAAM,QACNC,KAAM,cAGVD,KAAM,iCACNW,QAAS,CACP,CACED,WAAY,CACV,CACEJ,aAAc,kBACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,kBACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,aACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,SACdN,KAAM,UACNC,KAAM,UAER,CACEK,aAAc,UACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,OACdN,KAAM,oBACNC,KAAM,QAER,CACEK,aAAc,UACdN,KAA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"}