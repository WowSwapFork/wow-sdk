{"version":3,"file":"index-2075fe75.js","sources":["../src/common/chains.ts","../src/common/configs.ts","../src/common/cow-error.ts","../src/common/ipfs.ts","../src/common/consts.ts","../src/order-book/transformOrder.ts","../src/order-book/request.ts","../src/order-book/api.ts","../src/order-book/generated/models/BuyTokenDestination.ts","../src/order-book/generated/models/EcdsaSigningScheme.ts","../src/order-book/generated/models/OnchainOrderData.ts","../src/order-book/generated/models/OrderCancellationError.ts","../src/order-book/generated/models/OrderClass.ts","../src/order-book/generated/models/OrderKind.ts","../src/order-book/generated/models/OrderPostError.ts","../src/order-book/generated/models/OrderQuoteSideKindBuy.ts","../src/order-book/generated/models/OrderQuoteSideKindSell.ts","../src/order-book/generated/models/OrderStatus.ts","../src/order-book/generated/models/PriceEstimationError.ts","../src/order-book/generated/models/PriceQuality.ts","../src/order-book/generated/models/ReplaceOrderError.ts","../src/order-book/generated/models/SellTokenSource.ts","../src/order-book/generated/models/SigningScheme.ts","../src/subgraph/queries.ts","../src/subgraph/api.ts","../src/order-signing/orderSigningUtils.ts","../src/composable/types.ts","../src/composable/generated/factories/ComposableCoW__factory.ts","../src/composable/generated/factories/ExtensibleFallbackHandler__factory.ts","../node_modules/node-fetch/browser.js","../node_modules/@wowswapfork/contracts/lib/esm/order.js","../node_modules/@wowswapfork/contracts/lib/esm/interaction.js","../node_modules/@wowswapfork/contracts/lib/esm/types/ethers.js","../node_modules/@wowswapfork/contracts/lib/esm/sign.js","../node_modules/@wowswapfork/contracts/lib/esm/settlement.js","../node_modules/@wowswapfork/contracts/lib/esm/api.js","../node_modules/@wowswapfork/contracts/lib/esm/deploy.js","../node_modules/@wowswapfork/contracts/lib/esm/proxy.js","../node_modules/@wowswapfork/contracts/lib/esm/vault.js","../src/composable/utils.ts","../src/composable/contracts.ts","../src/composable/ConditionalOrder.ts","../src/utils.ts","../src/composable/Multiplexer.ts","../src/composable/ConditionalOrderFactory.ts","../src/composable/orderTypes/Twap.ts","../src/composable/orderTypes/index.ts"],"sourcesContent":["/**\n * Supported chains and their `chainId` for the SDK.\n * @enum\n */\nexport enum SupportedChainId {\n  MAINNET = 1,\n  GOERLI = 5,\n  GNOSIS_CHAIN = 100,\n  MUMBAI=80001\n}\n","import { SupportedChainId } from './chains'\nimport { BackoffOptions } from 'exponential-backoff'\nimport { RateLimiterOpts } from 'limiter/dist/esm'\n\n/**\n * IPFS configuration.\n *\n * For production use, consider using {@link Pinata: https://www.pinata.cloud/}\n * @property {string} [uri] The URI of the IPFS node to use.\n * @property {string} [writeUri] The URI of the IPFS node to use for writing.\n * @property {string} [readUri] The URI of the IPFS node to use for reading.\n * @property {string} [pinataApiKey] The API key to use for Pinata.\n * @property {string} [pinataApiSecret] The API secret to use for Pinata.\n */\nexport interface IpfsConfig {\n  uri?: string\n  writeUri?: string\n  readUri?: string\n  pinataApiKey?: string\n  pinataApiSecret?: string\n}\n\n/**\n * @property {RateLimiterOpts} [limiterOpts] The options to use for the rate limiter.\n * @property {BackoffOptions} [backoffOpts] The options to use for the backoff.\n */\nexport interface RequestOptions {\n  limiterOpts?: RateLimiterOpts\n  backoffOpts?: BackoffOptions\n}\n\n/**\n * The environment to use for the Cow API.\n */\nexport type CowEnv = 'prod' | 'staging'\n\n/**\n * Override some properties of the {@link ApiContext}.\n */\nexport type PartialApiContext = Partial<ApiContext>\n\n/**\n * @property {string} [1] The base URL for the mainnet API.\n * @property {string} [5] The base URL for the Goerli testnet API.\n * @property {string} [100] The base URL for the Gnosis Chain API.\n */\nexport type ApiBaseUrls = Record<SupportedChainId, string>\n\n/**\n * Define the context to use for the CoW Protocol API.\n *\n * CoW Protocol is a set of smart contracts and off-chain services, deployed on **multiple chains**.\n * {@link SupportedChainId Supported chains} are:\n * - Mainnet\n * - Goerli\n * - Gnosis Chain\n *\n * Each chain has it's own API, and each API has it's own base URL.\n *\n * Options may be selectively overridden by passing a {@link PartialApiContext} to the constructor.\n * @see {@link https://api.cow.fi/docs/#/}\n * @property {SupportedChainId} chainId The `chainId`` corresponding to this CoW Protocol API instance.\n * @property {CowEnv} env The environment that this context corresponds to.\n * @property {ApiBaseUrls} [baseUrls] URls that may be used to connect to this context.\n */\nexport interface ApiContext {\n  chainId: SupportedChainId\n  env: CowEnv\n  baseUrls?: ApiBaseUrls\n}\n\n/**\n * The list of available environments.\n */\nexport const ENVS_LIST: CowEnv[] = ['prod', 'staging']\n\n/**\n * The default CoW Protocol API context.\n */\nexport const DEFAULT_COW_API_CONTEXT: ApiContext = {\n  env: 'prod',\n  chainId: SupportedChainId.MAINNET,\n}\n","export class CowError extends Error {\n  error_code?: string\n\n  constructor(message: string, error_code?: string) {\n    super(message)\n    this.error_code = error_code\n  }\n}\n\nexport const logPrefix = 'cow-sdk:'\n","export const DEFAULT_IPFS_READ_URI = 'https://gnosis.mypinata.cloud/ipfs'\nexport const DEFAULT_IPFS_WRITE_URI = 'https://api.pinata.cloud'\n","import { SupportedChainId } from './chains'\nimport contractNetworks from '@wowswapfork/contracts/networks.json'\nconst { GPv2Settlement } = JSON.parse(contractNetworks as unknown as string) as typeof contractNetworks\n\nexport const BUY_ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'\nexport const EXTENSIBLE_FALLBACK_HANDLER = '0x2f55e8b20D0B9FEFA187AA7d00B6Cbe563605bF5'\nexport const COMPOSABLE_COW = '0x5d84eB96e4D57fB2a7945f32be7401237eD243ad'\n\n/**\n * The list of supported chains.\n */\nexport const ALL_SUPPORTED_CHAIN_IDS: SupportedChainId[] = [\n  SupportedChainId.MAINNET,\n  SupportedChainId.GOERLI,\n  SupportedChainId.GNOSIS_CHAIN,\n  SupportedChainId.MUMBAI,\n\n]\n\n/**\n * An object containing the addresses of the CoW Protocol settlement contracts for each supported chain.\n */\nexport const COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: GPv2Settlement[chainId].address,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ExtensibleFallbackHandler` contracts for each supported chain.\n */\nexport const EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: EXTENSIBLE_FALLBACK_HANDLER,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ComposableCow` contracts for each supported chain.\n */\nexport const COMPOSABLE_COW_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: COMPOSABLE_COW,\n  }),\n  {}\n)\n","import { BUY_ETH_ADDRESS } from '../common/consts'\nimport { Order } from './generated'\nimport { EnrichedOrder } from './types'\n\n/**\n * Apply programmatic transformations to an order.\n *\n * For example, transformations may be applied to an order to recognise it as a Native EthFlow order.\n * @param order to apply transformations to\n * @returns An order with the total fee added.\n */\nexport function transformOrder(order: Order): EnrichedOrder {\n  return transformEthFlowOrder(addTotalFeeToOrder(order))\n}\n\n/**\n * Add the total fee to the order.\n *\n * The `executedSurplusFee` represents exactly the fee that was charged (regardless of the fee\n * signed with the order). So, while the protocol currently does not allow placing a limit order\n * with any other fee than 0 - the backend is designed to support these kinds of orders for the\n * future.\n * @param dto The order to add the total fee to.\n * @returns The order with the total fee added.\n */\nfunction addTotalFeeToOrder(dto: Order): EnrichedOrder {\n  const { executedFeeAmount, executedSurplusFee } = dto\n  const totalFee = executedSurplusFee ?? executedFeeAmount\n\n  return {\n    ...dto,\n    totalFee,\n  }\n}\n\n/**\n * Transform order field for Native EthFlow orders\n *\n * A no-op for regular orders\n * For Native EthFlow, due to how the contract is setup:\n * - sellToken set to Native token address\n * - owner set to `onchainUser`\n * - validTo set to `ethflowData.userValidTo`\n */\nfunction transformEthFlowOrder(order: EnrichedOrder): EnrichedOrder {\n  const { ethflowData } = order\n\n  if (!ethflowData) {\n    return order\n  }\n\n  const { userValidTo: validTo } = ethflowData\n  const owner = order.onchainUser || order.owner\n  const sellToken = BUY_ETH_ADDRESS\n\n  return { ...order, validTo, owner, sellToken }\n}\n","import { backOff, BackoffOptions } from 'exponential-backoff'\nimport { RateLimiter, RateLimiterOpts } from 'limiter'\n\n/**\n * Error thrown when the CoW Protocol OrderBook API returns an error.\n */\nexport class OrderBookApiError<T = unknown> extends Error {\n  /**\n   * Error thrown when the CoW Protocol OrderBook API returns an error.\n   * @param response The response from the CoW Protocol OrderBook API.\n   * @param body The body of the response.\n   * @constructor\n   */\n  constructor(public readonly response: Response, public readonly body: T) {\n    super(typeof body === 'string' ? body : response.statusText)\n  }\n}\n\nconst REQUEST_TIMEOUT = 408\nconst TOO_EARLY = 425\nconst TOO_MANY_REQUESTS = 429\nconst INTERNAL_SERVER_ERROR = 500\nconst BAD_GATEWAY = 502\nconst SERVICE_UNAVAILABLE = 503\nconst GATEWAY_TIMEOUT = 504\n\nconst STATUS_CODES_TO_RETRY = [\n  REQUEST_TIMEOUT,\n  TOO_EARLY,\n  TOO_MANY_REQUESTS,\n  INTERNAL_SERVER_ERROR,\n  BAD_GATEWAY,\n  SERVICE_UNAVAILABLE,\n  GATEWAY_TIMEOUT,\n]\n\n/**\n * The default backoff options for CoW Protocol's API\n * @see {@link Backoff configuration: https://www.npmjs.com/package/@insertish/exponential-backoff}\n */\nexport const DEFAULT_BACKOFF_OPTIONS: BackoffOptions = {\n  numOfAttempts: 10,\n  maxDelay: Infinity,\n  jitter: 'none',\n  retry: (error: Error | OrderBookApiError) => {\n    if (error instanceof OrderBookApiError) {\n      return STATUS_CODES_TO_RETRY.includes(error.response.status)\n    }\n\n    return true\n  },\n}\n\n/**\n * The default rate limiter options for CoW Protocol's API.\n *\n * **CAUTION**: The CoW Protocol OrderBook API is limited to 5 requests per second per IP.\n */\nexport const DEFAULT_LIMITER_OPTIONS: RateLimiterOpts = {\n  tokensPerInterval: 5,\n  interval: 'second',\n}\n\n/**\n * Describe the parameters for a fetch request.\n */\nexport interface FetchParams {\n  path: string\n  method: 'GET' | 'POST' | 'DELETE' | 'PUT'\n  body?: unknown\n  query?: URLSearchParams\n}\n\nconst getResponseBody = async (response: Response): Promise<unknown> => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get('Content-Type')\n      if (contentType) {\n        if (contentType.toLowerCase().startsWith('application/json')) {\n          return await response.json()\n        } else {\n          return await response.text()\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  return undefined\n}\n\n/**\n * Helper function to make a rate-limited request to an API.\n * @param baseUrl The base URL of the API.\n * @param path The path of the request.\n * @param query The query parameters of the request.\n * @param method The HTTP method of the request.\n * @param body The body of the request.\n * @param rateLimiter The rate limiter to use.\n * @param backoffOpts The backoff options to use.\n * @returns The response of the request.\n * @throws If the API returns an error or if the request fails.\n */\nexport async function request<T>(\n  baseUrl: string,\n  { path, query, method, body }: FetchParams,\n  rateLimiter: RateLimiter,\n  backoffOpts: BackoffOptions\n): Promise<T> {\n  const queryString = query ? '?' + query : ''\n  const headers = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  }\n\n  const url = `${baseUrl}${path}${queryString}`\n  const bodyContent = (() => {\n    if (!body) return undefined\n\n    return typeof body === 'string' ? body : JSON.stringify(body)\n  })()\n  const init: RequestInit = {\n    method,\n    body: bodyContent,\n    headers,\n  }\n\n  return backOff<T>(async () => {\n    await rateLimiter.removeTokens(1)\n\n    const response = await fetch(url, init)\n    const responseBody = (await getResponseBody(response)) as T\n\n    // Successful response\n    if (response.status >= 200 && response.status < 300) {\n      return responseBody\n    }\n\n    return Promise.reject(new OrderBookApiError(response, responseBody))\n  }, backoffOpts)\n}\n","import 'cross-fetch/polyfill'\nimport {\n  Address,\n  AppDataHash,\n  AppDataObject,\n  NativePriceResponse,\n  Order,\n  OrderCancellations,\n  OrderCreation,\n  OrderQuoteRequest,\n  OrderQuoteResponse,\n  SolverCompetitionResponse,\n  TotalSurplus,\n  Trade,\n  TransactionHash,\n  UID,\n} from './generated'\nimport { CowError } from '../common/cow-error'\nimport {\n  ApiBaseUrls,\n  ApiContext,\n  CowEnv,\n  DEFAULT_COW_API_CONTEXT,\n  ENVS_LIST,\n  PartialApiContext,\n  RequestOptions,\n} from '../common/configs'\nimport { transformOrder } from './transformOrder'\nimport { EnrichedOrder } from './types'\nimport { SupportedChainId } from '../common/chains'\nimport { RateLimiter } from 'limiter'\nimport { DEFAULT_BACKOFF_OPTIONS, DEFAULT_LIMITER_OPTIONS, FetchParams, OrderBookApiError, request } from './request'\n\n/**\n * An object containing *production* environment base URLs for each supported `chainId`.\n * @see {@link https://api.cow.fi/docs/#/}\n */\nexport const ORDER_BOOK_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n}\n\n/**\n * An object containing *staging* environment base URLs for each supported `chainId`.\n */\nexport const ORDER_BOOK_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://barn.api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://barn.api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://barn.api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n\n}\n\nfunction cleanObjectFromUndefinedValues(obj: Record<string, string>): typeof obj {\n  return Object.keys(obj).reduce((acc, key) => {\n    const val = obj[key]\n    if (typeof val !== 'undefined') acc[key] = val\n    return acc\n  }, {} as typeof obj)\n}\n\n/**\n * The parameters for the `getOrders` request.\n */\nexport type GetOrdersRequest = {\n  owner: Address\n  offset?: number\n  limit?: number\n}\n\n/**\n * The CoW Protocol OrderBook API client.\n *\n * This is the main entry point for interacting with the CoW Protocol OrderBook API. The main advantage of using\n * this client is the batteries-included approach to interacting with the API. It handles:\n *\n * - Environment configuration (mainnet, staging, etc.)\n * - Rate limiting\n * - Retries\n * - Backoff\n * - Error handling\n * - Request signing\n * - Request validation\n *\n * @example\n *\n * ```typescript\n * import { OrderBookApi, OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * const quoteRequest = {\n *   sellToken: '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6', // WETH goerli\n *   buyToken: '0x02abbdbaaa7b1bb64b5c878f7ac17f8dda169532', // GNO goerli\n *   from: account,\n *   receiver: account,\n *   sellAmountBeforeFee: (0.4 * 10 ** 18).toString(), // 0.4 WETH\n *   kind: OrderQuoteSide.kind.SELL,\n * }\n *\n * const orderBookApi = new OrderBookApi({ chainId: SupportedChainId.GOERLI })\n *\n * async function main() {\n *     const { quote } = await orderBookApi.getQuote(quoteRequest)\n *\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n *\n * @see {@link Swagger documentation https://api.cow.fi/docs/#/}\n * @see {@link OrderBook API https://github.com/cowprotocol/services}\n */\nexport class OrderBookApi {\n  public context: ApiContext & RequestOptions\n\n  private rateLimiter: RateLimiter\n\n  /**\n   * Creates a new instance of the CoW Protocol OrderBook API client.\n   * @param context - The API context to use. If not provided, the default context will be used.\n   */\n  constructor(context: PartialApiContext & RequestOptions = {}) {\n    this.context = { ...DEFAULT_COW_API_CONTEXT, ...context }\n    this.rateLimiter = new RateLimiter(context.limiterOpts || DEFAULT_LIMITER_OPTIONS)\n  }\n\n  /**\n   * Get the version of the API.\n   * @param contextOverride Optional context override for this request.\n   * @returns The version of the API.\n   * @see {@link https://api.cow.fi/docs/#/default/get_api_v1_version}\n   */\n  getVersion(contextOverride: PartialApiContext = {}): Promise<string> {\n    return this.fetch({ path: '/api/v1/version', method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Get all the trades for either an `owner` **OR** `orderUid`.\n   *\n   * Given that an order *may* be partially fillable, it is possible that a discrete order (`orderUid`)\n   * may have *multiple* trades. Therefore, this method returns a list of trades, either for *all* the orders\n   * of a given `owner`, or for a discrete order (`orderUid`).\n   * @param request Either an `owner` or an `orderUid` **MUST** be specified.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of trades matching the request.\n   */\n  getTrades(\n    request: { owner?: Address; orderUid?: UID },\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<Trade>> {\n    if (request.owner && request.orderUid) {\n      return Promise.reject(new CowError('Cannot specify both owner and orderId'))\n    } else if (!request.owner && !request.orderUid) {\n      return Promise.reject(new CowError('Must specify either owner or orderId'))\n    }\n\n    const query = new URLSearchParams(cleanObjectFromUndefinedValues(request))\n\n    return this.fetch({ path: '/api/v1/trades', method: 'GET', query }, contextOverride)\n  }\n\n  /**\n   * Get a list of orders for a given `owner`.\n   * @param request The request parameters with `request.offset = 0` and `request.limit = 1000` by default.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link GetOrdersRequest}\n   * @see {@link EnrichedOrder}\n   */\n  getOrders(\n    { owner, offset = 0, limit = 1000 }: GetOrdersRequest,\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<EnrichedOrder>> {\n    const query = new URLSearchParams(\n      cleanObjectFromUndefinedValues({ offset: offset.toString(), limit: limit.toString() })\n    )\n\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/account/${owner}/orders`, method: 'GET', query },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get a list of orders from a given settlement transaction hash.\n   * @param txHash The transaction hash.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link EnrichedOrder}\n   */\n  getTxOrders(txHash: TransactionHash, contextOverride: PartialApiContext = {}): Promise<Array<EnrichedOrder>> {\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/transactions/${txHash}/orders`, method: 'GET' },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   */\n  getOrder(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    return this.fetch<Order>({ path: `/api/v1/orders/${orderUid}`, method: 'GET' }, contextOverride).then((order) => {\n      return transformOrder(order)\n    })\n  }\n\n  /**\n   * Attempt to get an order by its unique identifier, `orderUid`, from multiple environments.\n   *\n   * **NOTE**: The environment refers to either `prod` or `staging`. This allows a conveience method to\n   * attempt to get an order from both environments, in the event that the order is not found in the\n   * environment specified in the context.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   * @throws {OrderBookApiError} If the order is not found in any of the environments.\n   */\n  getOrderMultiEnv(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    const { env } = this.getContextWithOverride(contextOverride)\n    const otherEnvs = ENVS_LIST.filter((i) => i !== env)\n\n    let attemptsCount = 0\n\n    const fallback = (error: Error | OrderBookApiError): Promise<EnrichedOrder> => {\n      const nextEnv = otherEnvs[attemptsCount]\n\n      if (error instanceof OrderBookApiError && error.response.status === 404 && nextEnv) {\n        attemptsCount++\n\n        return this.getOrder(orderUid, { ...contextOverride, env: nextEnv }).catch(fallback)\n      }\n\n      return Promise.reject(error)\n    }\n\n    return this.getOrder(orderUid, { ...contextOverride, env }).catch(fallback)\n  }\n\n  /**\n   * Get a quote for an order.\n   * This allows for the calculation of the total cost of an order, including fees, before signing and submitting.\n   * @param requestBody The parameters for the order quote request.\n   * @param contextOverride Optional context override for this request.\n   * @returns A hydrated order matching the request ready to be signed.\n   */\n  getQuote(requestBody: OrderQuoteRequest, contextOverride: PartialApiContext = {}): Promise<OrderQuoteResponse> {\n    return this.fetch({ path: '/api/v1/quote', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Cancel one or more orders.\n   *\n   * **NOTE**: Cancellation is on a best-effort basis. Orders that are already in the process of being settled\n   * (ie. transaction has been submitted to chain by the solver) cannot not be cancelled.\n   * **CAUTION**: This method can only be used to cancel orders that were signed using `EIP-712` or `eth_sign (EIP-191)`.\n   * @param requestBody Orders to be cancelled and signed instructions to cancel them.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of order unique identifiers that were successfully cancelled.\n   */\n  sendSignedOrderCancellations(\n    requestBody: OrderCancellations,\n    contextOverride: PartialApiContext = {}\n  ): Promise<void> {\n    return this.fetch({ path: '/api/v1/orders', method: 'DELETE', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Submit an order to the order book.\n   * @param requestBody The signed order to be submitted.\n   * @param contextOverride Optional context override for this request.\n   * @returns The unique identifier of the order.\n   */\n  sendOrder(requestBody: OrderCreation, contextOverride: PartialApiContext = {}): Promise<UID> {\n    return this.fetch({ path: '/api/v1/orders', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Get the native price of a token.\n   *\n   * **NOTE**: The native price is the price of the token in the native currency of the chain. For example, on Ethereum\n   * this would be the price of the token in ETH.\n   * @param tokenAddress The address of the ERC-20 token.\n   * @param contextOverride Optional context override for this request.\n   * @returns The native price of the token.\n   */\n  getNativePrice(tokenAddress: Address, contextOverride: PartialApiContext = {}): Promise<NativePriceResponse> {\n    return this.fetch({ path: `/api/v1/token/${tokenAddress}/native_price`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Given a user's address, get the total surplus that they have earned.\n   * @param address The user's address\n   * @param contextOverride Optional context override for this request.\n   * @returns Calculated user's surplus\n   */\n  getTotalSurplus(address: Address, contextOverride: PartialApiContext = {}): Promise<TotalSurplus> {\n    return this.fetch({ path: `/api/v1/users/${address}/total_surplus`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Retrieve the full app data for a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param contextOverride Optional context override for this request.\n   * @returns Full app data that was uploaded\n   */\n  getAppData(appDataHash: AppDataHash, contextOverride: PartialApiContext = {}): Promise<AppDataObject> {\n    return this.fetch({ path: `/api/v1/app_data/${appDataHash}`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Upload the full app data that corresponds to a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param fullAppData Full app data to be uploaded\n   * @param contextOverride Optional context override for this request.\n   * @returns The string encoding of the full app data that was uploaded.\n   */\n  uploadAppData(\n    appDataHash: AppDataHash,\n    fullAppData: string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<AppDataObject> {\n    return this.fetch(\n      { path: `/api/v1/app_data/${appDataHash}`, method: 'PUT', body: { fullAppData } },\n      contextOverride\n    )\n  }\n\n  getSolverCompetition(auctionId: number, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  getSolverCompetition(txHash: string, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  /**\n   * Given an auction id or tx hash, get the details of the solver competition for that auction.\n   * @param auctionIdorTx auction id or tx hash corresponding to the auction\n   * @param contextOverride Optional context override for this request.\n   * @returns An object containing the solver competition details\n   */\n  getSolverCompetition(\n    auctionIdorTx: number | string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<SolverCompetitionResponse> {\n    return this.fetch(\n      {\n        path: `/api/v1/solver_competition${typeof auctionIdorTx === 'string' ? '/by_tx_hash' : ''}/${auctionIdorTx}`,\n        method: 'GET',\n      },\n      contextOverride\n    )\n  }\n\n  /**\n   * Generate an API endpoint for an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The API endpoint to get the order.\n   */\n  getOrderLink(orderUid: UID, contextOverride?: PartialApiContext): string {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    return this.getApiBaseUrls(env)[chainId] + `/api/v1/orders/${orderUid}`\n  }\n\n  /**\n   * Apply an override to the context for a request.\n   * @param contextOverride Optional context override for this request.\n   * @returns New context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext & RequestOptions {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the API endpoints given the environment.\n   * @param env The environment to get the base URLs for.\n   * @returns The base URLs for the API endpoints.\n   */\n  private getApiBaseUrls(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? ORDER_BOOK_PROD_CONFIG : ORDER_BOOK_STAGING_CONFIG\n  }\n\n  /**\n   * Make a request to the API.\n   * @param params The parameters for the request.\n   * @param contextOverride Optional context override for this request.\n   * @returns The response from the API.\n   */\n  private fetch<T>(params: FetchParams, contextOverride: PartialApiContext = {}): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getApiBaseUrls(env)[chainId]\n    const backoffOpts = this.context.backoffOpts || DEFAULT_BACKOFF_OPTIONS\n\n    return request(baseUrl, params, this.rateLimiter, backoffOpts)\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `buyToken` be transferred to?\n */\nexport enum BuyTokenDestination {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum EcdsaSigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nimport type { Address } from './Address';\n\nexport type OnchainOrderData = {\n    /**\n     * If orders are placed as on-chain orders, the owner of the order might\n     * be a smart contract, but not the user placing the order. The\n     * actual user will be provided in this field.\n     *\n     */\n    sender: Address;\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    placementError?: OnchainOrderData.placementError;\n};\n\nexport namespace OnchainOrderData {\n\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    export enum placementError {\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        VALID_TO_TOO_FAR_IN_FUTURE = 'ValidToTooFarInFuture',\n        PRE_VALIDATION_ERROR = 'PreValidationError',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderCancellationError = {\n    errorType: OrderCancellationError.errorType;\n    description: string;\n};\n\nexport namespace OrderCancellationError {\n\n    export enum errorType {\n        INVALID_SIGNATURE = 'InvalidSignature',\n        WRONG_OWNER = 'WrongOwner',\n        ORDER_NOT_FOUND = 'OrderNotFound',\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Order class.\n */\nexport enum OrderClass {\n    MARKET = 'market',\n    LIMIT = 'limit',\n    LIQUIDITY = 'liquidity',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Is this order a buy or sell?\n */\nexport enum OrderKind {\n    BUY = 'buy',\n    SELL = 'sell',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderPostError = {\n    errorType: OrderPostError.errorType;\n    description: string;\n};\n\nexport namespace OrderPostError {\n\n    export enum errorType {\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        INVALID_QUOTE = 'InvalidQuote',\n        MISSING_FROM = 'MissingFrom',\n        WRONG_OWNER = 'WrongOwner',\n        INVALID_EIP1271SIGNATURE = 'InvalidEip1271Signature',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        SELL_AMOUNT_OVERFLOW = 'SellAmountOverflow',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        ZERO_AMOUNT = 'ZeroAmount',\n        INCOMPATIBLE_SIGNING_SCHEME = 'IncompatibleSigningScheme',\n        TOO_MANY_LIMIT_ORDERS_UNSUPPORTED_BUY_TOKEN_DESTINATION = 'TooManyLimitOrders UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        INVALID_NATIVE_SELL_TOKEN_SAME_BUY_AND_SELL_TOKEN = 'InvalidNativeSellToken SameBuyAndSellToken',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        UNSUPPORTED_CUSTOM_INTERACTION_INVALID_APP_DATA = 'UnsupportedCustomInteraction InvalidAppData',\n        APP_DATA_HASH_MISMATCH = 'AppDataHashMismatch',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindBuy {\n    BUY = 'buy',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindSell {\n    SELL = 'sell',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * The current order status.\n */\nexport enum OrderStatus {\n    PRESIGNATURE_PENDING = 'presignaturePending',\n    OPEN = 'open',\n    FULFILLED = 'fulfilled',\n    CANCELLED = 'cancelled',\n    EXPIRED = 'expired',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type PriceEstimationError = {\n    errorType: PriceEstimationError.errorType;\n    description: string;\n};\n\nexport namespace PriceEstimationError {\n\n    export enum errorType {\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How good should the price estimate be?\n *\n * Fast: The price estimate is chosen among the fastest N price estimates.\n * Optimal: The price estimate is chosen among all price estimates.\n * Verified: The price estimate is chosen among all verified/simulated price estimates.\n *\n * **NOTE**: Orders are supposed to be created from `verified` price estimates.\n *\n */\nexport enum PriceQuality {\n    FAST = 'fast',\n    OPTIMAL = 'optimal',\n    VERIFIED = 'verified',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type ReplaceOrderError = {\n    errorType: ReplaceOrderError.errorType;\n    description: string;\n};\n\nexport namespace ReplaceOrderError {\n\n    export enum errorType {\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        WRONG_OWNER = 'WrongOwner',\n        SAME_BUY_AND_SELL_TOKEN = 'SameBuyAndSellToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_BUY_TOKEN_DESTINATION = 'UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `sellToken` be drawn from?\n */\nexport enum SellTokenSource {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n    EXTERNAL = 'external',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum SigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n    PRESIGN = 'presign',\n    EIP1271 = 'eip1271',\n}\n","import { gql } from 'graphql-request'\n\n/**\n * GraphQL query for the total number of tokens, orders, traders, settlements, volume, and fees.\n */\nexport const TOTALS_QUERY = gql`\n  query Totals {\n    totals {\n      tokens\n      orders\n      traders\n      settlements\n      volumeUsd\n      volumeEth\n      feesUsd\n      feesEth\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N days.\n * @param days The number of days to query.\n */\nexport const LAST_DAYS_VOLUME_QUERY = gql`\n  query LastDaysVolume($days: Int!) {\n    dailyTotals(orderBy: timestamp, orderDirection: desc, first: $days) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N hours.\n * @param hours The number of hours to query.\n */\nexport const LAST_HOURS_VOLUME_QUERY = gql`\n  query LastHoursVolume($hours: Int!) {\n    hourlyTotals(orderBy: timestamp, orderDirection: desc, first: $hours) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n","import { CowError } from '../common/cow-error'\nimport { LastDaysVolumeQuery, LastHoursVolumeQuery, TotalsQuery } from './graphql'\nimport { LAST_DAYS_VOLUME_QUERY, LAST_HOURS_VOLUME_QUERY, TOTALS_QUERY } from './queries'\nimport { DocumentNode } from 'graphql/index'\nimport { request, Variables } from 'graphql-request'\nimport { ApiContext, CowEnv, DEFAULT_COW_API_CONTEXT, ApiBaseUrls, PartialApiContext } from '../common/configs'\nimport { SupportedChainId } from '../common/chains'\n\nconst SUBGRAPH_BASE_URL = 'https://api.thegraph.com/subgraphs/name/cowprotocol'\n\n/**\n * CoW Protocol Production Subgraph API configuration.\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-goerli}\n */\nexport const SUBGRAPH_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc',\n  [SupportedChainId.GOERLI]: SUBGRAPH_BASE_URL + '/cow-goerli',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * CoW Protocol Staging Subgraph API configuration.\n * @deprecated\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-staging}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc-staging}\n */\nexport const SUBGRAPH_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow-staging',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc-staging',\n  [SupportedChainId.GOERLI]: '',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * TheGraph API client for CoW Protocol.\n */\nexport class SubgraphApi {\n  API_NAME = 'CoW Protocol Subgraph'\n\n  public context: ApiContext\n\n  /**\n   * Create a new CoW Protocol API instance.\n   * @param context Any properties of the {@link ApiContext} may be overridden by passing a {@link PartialApiContext}.\n   */\n  constructor(context: PartialApiContext = {}) {\n    this.context = {\n      ...DEFAULT_COW_API_CONTEXT,\n      ...context,\n    }\n  }\n\n  /**\n   * Query the totals from TheGraph for the CoW Protocol.\n   * @param contextOverride Override the context for this call only.\n   * @returns The totals for the CoW Protocol.\n   */\n  async getTotals(contextOverride: PartialApiContext = {}): Promise<TotalsQuery['totals'][0]> {\n    const response = await this.runQuery<TotalsQuery>(TOTALS_QUERY, undefined, contextOverride)\n    return response.totals[0]\n  }\n\n  /**\n   * Query the volume over the last N days from TheGraph for the CoW Protocol.\n   * @param {number} days The number of days to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N days.\n   */\n  async getLastDaysVolume(days: number, contextOverride: PartialApiContext = {}): Promise<LastDaysVolumeQuery> {\n    return this.runQuery<LastDaysVolumeQuery>(LAST_DAYS_VOLUME_QUERY, { days }, contextOverride)\n  }\n\n  /**\n   * Query the volume over the last N hours from TheGraph for the CoW Protocol.\n   * @param {number} hours The number of hours to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N hours.\n   */\n  async getLastHoursVolume(hours: number, contextOverride: PartialApiContext = {}): Promise<LastHoursVolumeQuery> {\n    return this.runQuery<LastHoursVolumeQuery>(LAST_HOURS_VOLUME_QUERY, { hours }, contextOverride)\n  }\n\n  /**\n   * Run a query against the CoW Protocol Subgraph.\n   * @param {string | DocumentNode} query GQL query string or DocumentNode.\n   * @param {Variables | undefined} variables To be passed to the query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns Results of the query.\n   * @throws {@link CowError} if the query fails.\n   */\n  async runQuery<T>(\n    query: string | DocumentNode,\n    variables: Variables | undefined = undefined,\n    contextOverride: PartialApiContext = {}\n  ): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getEnvConfigs(env)[chainId]\n\n    try {\n      return await request(baseUrl, query, variables)\n    } catch (error) {\n      console.error(`[subgraph:${this.API_NAME}]`, error)\n      throw new CowError(\n        `Error running query: ${query}. Variables: ${JSON.stringify(variables)}. API: ${baseUrl}. Inner Error: ${error}`\n      )\n    }\n  }\n\n  /**\n   * Override parts of the context for a specific call.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns {ApiContext} The context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the given environment.\n   * @param {CowEnv} env The environment to get the base URLs for.\n   * @returns {ApiBaseUrls} The base URLs for the given environment.\n   */\n  private getEnvConfigs(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? SUBGRAPH_PROD_CONFIG : SUBGRAPH_STAGING_CONFIG\n  }\n}\n","import type { SupportedChainId } from '../common'\nimport type { Signer } from '@ethersproject/abstract-signer'\nimport type { TypedDataDomain } from '@wowswapfork/contracts'\nimport type { SigningResult, UnsignedOrder } from './types'\n\nconst getSignUtils = () => import('./utils')\nconst ethersUtils = () => import('ethers/lib/utils')\n\n/**\n * Utility class for signing order intents and cancellations.\n *\n * @remarks This class only supports `eth_sign` and wallet-native EIP-712 signing. For use of\n *          `presign` and `eip1271` {@link https://docs.cow.fi/ | see the docs}.\n * @example\n *\n * ```typescript\n * import { OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * async function main() {\n *     const { order: Order } = { ... }\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n */\nexport class OrderSigningUtils {\n  /**\n   * Sign the order intent with the specified signer.\n   *\n   * @remarks If the API reports an error with the signature, it is likely to be due to an incorrectly\n   *          specified `chainId`. Please ensure that the `chainId` is correct for the network you are\n   *          using.\n   * @param {UnsignedOrder} order The unsigned order intent to be placed.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who is placing the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the order.\n   */\n  static async signOrder(order: UnsignedOrder, chainId: SupportedChainId, signer: Signer): Promise<SigningResult> {\n    const { signOrder } = await getSignUtils()\n    return signOrder(order, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of an order intent with the specified signer.\n   * @param {string} orderUid The unique identifier of the order to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainid` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellation(\n    orderUid: string,\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellation } = await getSignUtils()\n    return signOrderCancellation(orderUid, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of multiple order intents with the specified signer.\n   * @param {string[]} orderUids An array of `orderUid` to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intents.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellations(\n    orderUids: string[],\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellations } = await getSignUtils()\n    return signOrderCancellations(orderUids, chainId, signer)\n  }\n\n  /**\n   * Get the EIP-712 typed domain data being used for signing.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @return The EIP-712 typed domain data.\n   * @see https://eips.ethereum.org/EIPS/eip-712\n   */\n  static async getDomain(chainId: SupportedChainId): Promise<TypedDataDomain> {\n    const { getDomain } = await getSignUtils()\n    return getDomain(chainId)\n  }\n\n  /**\n   * Get the domain separator hash for the EIP-712 typed domain data being used for signing.\n   * @param chainId {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @returns A string representation of the EIP-712 typed domain data hash.\n   */\n  static async getDomainSeparator(chainId: SupportedChainId): Promise<string> {\n    const { getDomain } = await getSignUtils()\n    const { _TypedDataEncoder } = await ethersUtils()\n    return _TypedDataEncoder.hashDomain(getDomain(chainId))\n  }\n\n  /**\n   * Get the EIP-712 types used for signing a GPv2Order.Data struct. This is useful for when\n   * signing orders using smart contracts, whereby this SDK cannot do the EIP-1271 signing for you.\n   * @returns The EIP-712 types used for signing.\n   */\n  static getEIP712Types(): Record<string, any> {\n    return {\n      Order: [\n        { name: 'sellToken', type: 'address' },\n        { name: 'buyToken', type: 'address' },\n        { name: 'receiver', type: 'address' },\n        { name: 'sellAmount', type: 'uint256' },\n        { name: 'buyAmount', type: 'uint256' },\n        { name: 'validTo', type: 'uint32' },\n        { name: 'appData', type: 'bytes32' },\n        { name: 'feeAmount', type: 'uint256' },\n        { name: 'kind', type: 'string' },\n        { name: 'partiallyFillable', type: 'bool' },\n        { name: 'sellTokenBalance', type: 'string' },\n        { name: 'buyTokenBalance', type: 'string' },\n      ],\n    }\n  }\n}\n","import { OrderBookApi } from '../order-book'\nimport { SupportedChainId } from '../common'\nimport { GPv2Order } from './generated/ComposableCoW'\nimport { providers } from 'ethers'\n\nexport interface ConditionalOrderArguments<T> {\n  handler: string\n  data: T\n  salt?: string\n  hasOffChainInput?: boolean\n}\n\nexport type ConditionalOrderParams = {\n  readonly handler: string\n  readonly salt: string\n  readonly staticInput: string\n}\n\nexport enum ProofLocation {\n  // The location of the proofs is private to the caller.\n  PRIVATE = 0,\n  // The `data` field of the emitted `Proof` struct contains proofs + conditional order parameters.\n  EMITTED = 1,\n  // The `data` field of the emitted `Proof` struct contains the Swarm address (`bytes32`) of the proofs + conditional order parameters.\n  SWARM = 2,\n  // The `data` field is set to TBD.\n  WAKU = 3,\n  // The `data` field is set to TBD\n  RESERVED = 4,\n  // The `data` field of the emitted `Proof` struct contains the IPFS address (`bytes32`) of the proofs + conditional order parameters.\n  IPFS = 5,\n}\n\n/**\n * A factory and it's arguments that are called at transaction mining time to generate the context\n * for a conditional order(s).\n *\n * This allows to support the case where conditional orders may want to *commence* validity at the\n * time of transaction mining, like in the case of a `TWAP` executed by a DAO or `Safe` that takes\n * a reasonable amount of time to aggregate signatures or collect votes.\n *\n * @remarks This is used in conjunction with `setRootWithContext` or `createWithContext`.\n */\nexport type ContextFactory = {\n  // The address of the `IValueFactory` that will be used to resolve the context.\n  address: string\n  // Any arguments that will be passed to the `IValueFactory` to resolve the context.\n  factoryArgs?: {\n    args: unknown[]\n    argsType: string[]\n  }\n}\n\n/**\n * A struct for a proof that can be used with `setRoot` and `setRootWithContext` on a\n * ComposableCoW-enabled Safe.\n */\nexport type ProofStruct = {\n  // The location of the proof.\n  location: ProofLocation\n  // The data for the proof.\n  data: string | '0x'\n}\n\n/**\n * Payload for emitting a merkle root to a ComposableCoW-enabled Safe.\n *\n * If setting `ProofLocation.EMITTED`, this type should be used as the `data` in the `Proof` struct.\n */\nexport type PayloadLocationEmitted = {\n  // An array of conditional orders and their proofs.\n  proofs: ProofWithParams[]\n}\n\n/**\n * A proof for a conditional order and it's parameters.\n */\nexport type ProofWithParams = {\n  // The proof for the Merkle tree that contains the conditional order.\n  proof: string[]\n  // The parameters as expected by ABI encoding.\n  params: ConditionalOrderParams\n}\n\nexport type OwnerContext = {\n  owner: string\n  chainId: SupportedChainId\n  provider: providers.Provider\n}\n\nexport type PollParams = OwnerContext & {\n  offchainInput?: string\n  proof?: string[]\n\n  /**\n   * If present, it can be used for custom conditional order validations. If not present, the orders will need to get the block info themselves\n   */\n  blockInfo?: BlockInfo\n\n  /**\n   * Allows to optional pass the config of the orderbook API\n   */\n  orderbookApiConfig?: OrderBookApiConfig\n}\n\nexport type OrderBookApiConfig = Omit<ConstructorParameters<typeof OrderBookApi>[0], 'chainId'>\n\nexport type BlockInfo = {\n  blockNumber: number\n  blockTimestamp: number\n}\n\nexport type PollResult = PollResultSuccess | PollResultErrors\n\nexport type PollResultErrors =\n  | PollResultTryNextBlock\n  | PollResultTryOnBlock\n  | PollResultTryAtEpoch\n  | PollResultUnexpectedError\n  | PollResultDontTryAgain\n\nexport enum PollResultCode {\n  SUCCESS = 'SUCCESS',\n  UNEXPECTED_ERROR = 'UNEXPECTED_ERROR',\n  TRY_NEXT_BLOCK = 'TRY_NEXT_BLOCK',\n  TRY_ON_BLOCK = 'TRY_ON_BLOCK',\n  TRY_AT_EPOCH = 'TRY_AT_EPOCH',\n  DONT_TRY_AGAIN = 'DONT_TRY_AGAIN',\n}\nexport interface PollResultSuccess {\n  readonly result: PollResultCode.SUCCESS\n  readonly order: GPv2Order.DataStruct\n  readonly signature: string\n}\n\nexport interface PollResultUnexpectedError {\n  readonly result: PollResultCode.UNEXPECTED_ERROR\n  readonly error: unknown\n  reason?: string\n}\n\nexport interface PollResultTryNextBlock {\n  readonly result: PollResultCode.TRY_NEXT_BLOCK\n  reason?: string\n}\n\nexport interface PollResultTryOnBlock {\n  readonly result: PollResultCode.TRY_ON_BLOCK\n  readonly blockNumber: number\n  reason?: string\n}\n\nexport interface PollResultTryAtEpoch {\n  readonly result: PollResultCode.TRY_AT_EPOCH\n  /**\n   * The epoch after which it is ok to retry to to poll this order.\n   * The value is expressed as a Unix timestamp (in seconds).\n   *\n   * This epoch will be inclusive, meaning that it is ok to retry at the block mined precisely at this epoch or later.\n   */\n  readonly epoch: number\n  reason?: string\n}\n\nexport interface PollResultDontTryAgain {\n  readonly result: PollResultCode.DONT_TRY_AGAIN\n  reason?: string\n}\n\nexport type IsValidResult = IsValid | IsNotValid\nexport interface IsValid {\n  isValid: true\n}\nexport interface IsNotValid {\n  isValid: false\n  reason: string\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type { ComposableCoW, ComposableCoWInterface } from \"../ComposableCoW\";\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_settlement\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"InterfaceNotSupported\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidHandler\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ProofNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SingleOrderNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SwapGuardRestricted\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"ConditionalOrderCreated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"MerkleRootSet\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"SwapGuardSet\",\n    type: \"event\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"cabinet\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"create\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"createWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"domainSeparator\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"offchainInput\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"proof\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"getTradeableOrderWithSignature\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IERC20\",\n            name: \"sellToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"contract IERC20\",\n            name: \"buyToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"receiver\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"sellAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"buyAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint32\",\n            name: \"validTo\",\n            type: \"uint32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"appData\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"feeAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"kind\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bool\",\n            name: \"partiallyFillable\",\n            type: \"bool\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"sellTokenBalance\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"buyTokenBalance\",\n            type: \"bytes32\",\n          },\n        ],\n        internalType: \"struct GPv2Order.Data\",\n        name: \"order\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"hash\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"encodeData\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"payload\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSafeSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"singleOrderHash\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"remove\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"roots\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"setRoot\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"setRootWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"setSwapGuard\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"singleOrders\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"swapGuards\",\n    outputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ComposableCoW__factory {\n  static readonly abi = _abi;\n  static createInterface(): ComposableCoWInterface {\n    return new utils.Interface(_abi) as ComposableCoWInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ComposableCoW {\n    return new Contract(address, _abi, signerOrProvider) as ComposableCoW;\n  }\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type {\n  ExtensibleFallbackHandler,\n  ExtensibleFallbackHandlerInterface,\n} from \"../ExtensibleFallbackHandler\";\n\nconst _abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"verifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"AddedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"method\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AddedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"oldVerifier\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"ChangedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"oldMethod\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"ChangedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"RemovedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    stateMutability: \"nonpayable\",\n    type: \"fallback\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"domainVerifiers\",\n    outputs: [\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155BatchReceived\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC721Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeInterfaces\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeMethods\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"setDomainVerifier\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"setSafeMethod\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"supported\",\n        type: \"bool\",\n      },\n    ],\n    name: \"setSupportedInterface\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"_interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"handlerWithSelectors\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"setSupportedInterfaceBatch\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"supportsInterface\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ExtensibleFallbackHandler__factory {\n  static readonly abi = _abi;\n  static createInterface(): ExtensibleFallbackHandlerInterface {\n    return new utils.Interface(_abi) as ExtensibleFallbackHandlerInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ExtensibleFallbackHandler {\n    return new Contract(\n      address,\n      _abi,\n      signerOrProvider\n    ) as ExtensibleFallbackHandler;\n  }\n}\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;","import { ethers } from \"ethers\";\n/**\n * Marker address to indicate that an order is buying Ether.\n *\n * Note that this address is only has special meaning in the `buyToken` and will\n * be treated as a ERC20 token address in the `sellToken` position, causing the\n * settlement to revert.\n */\nexport const BUY_ETH_ADDRESS = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n/**\n * Order kind.\n */\nexport var OrderKind;\n(function (OrderKind) {\n    /**\n     * A sell order.\n     */\n    OrderKind[\"SELL\"] = \"sell\";\n    /**\n     * A buy order.\n     */\n    OrderKind[\"BUY\"] = \"buy\";\n})(OrderKind || (OrderKind = {}));\n/**\n * Order balance configuration.\n */\nexport var OrderBalance;\n(function (OrderBalance) {\n    /**\n     * Use ERC20 token balances.\n     */\n    OrderBalance[\"ERC20\"] = \"erc20\";\n    /**\n     * Use Balancer Vault external balances.\n     *\n     * This can only be specified specified for the sell balance and allows orders\n     * to re-use Vault ERC20 allowances. When specified for the buy balance, it\n     * will be treated as {@link OrderBalance.ERC20}.\n     */\n    OrderBalance[\"EXTERNAL\"] = \"external\";\n    /**\n     * Use Balancer Vault internal balances.\n     */\n    OrderBalance[\"INTERNAL\"] = \"internal\";\n})(OrderBalance || (OrderBalance = {}));\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_FIELDS = [\n    { name: \"sellToken\", type: \"address\" },\n    { name: \"buyToken\", type: \"address\" },\n    { name: \"receiver\", type: \"address\" },\n    { name: \"sellAmount\", type: \"uint256\" },\n    { name: \"buyAmount\", type: \"uint256\" },\n    { name: \"validTo\", type: \"uint32\" },\n    { name: \"appData\", type: \"bytes32\" },\n    { name: \"feeAmount\", type: \"uint256\" },\n    { name: \"kind\", type: \"string\" },\n    { name: \"partiallyFillable\", type: \"bool\" },\n    { name: \"sellTokenBalance\", type: \"string\" },\n    { name: \"buyTokenBalance\", type: \"string\" },\n];\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const CANCELLATIONS_TYPE_FIELDS = [\n    { name: \"orderUids\", type: \"bytes[]\" },\n];\n/**\n * The EIP-712 type hash for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_HASH = ethers.utils.id(`Order(${ORDER_TYPE_FIELDS.map(({ name, type }) => `${type} ${name}`).join(\",\")})`);\n/**\n * Normalizes a timestamp value to a Unix timestamp.\n * @param time The timestamp value to normalize.\n * @return Unix timestamp or number of seconds since the Unix Epoch.\n */\nexport function timestamp(t) {\n    return typeof t === \"number\" ? t : ~~(t.getTime() / 1000);\n}\n/**\n * Normalizes an app data value to a 32-byte hash.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function hashify(h) {\n    return typeof h === \"number\"\n        ? `0x${h.toString(16).padStart(64, \"0\")}`\n        : ethers.utils.hexZeroPad(h, 32);\n}\n/**\n * Normalizes the balance configuration for a buy token. Specifically, this\n * function ensures that {@link OrderBalance.EXTERNAL} gets normalized to\n * {@link OrderBalance.ERC20}.\n *\n * @param balance The balance configuration.\n * @returns The normalized balance configuration.\n */\nexport function normalizeBuyTokenBalance(balance) {\n    switch (balance) {\n        case undefined:\n        case OrderBalance.ERC20:\n        case OrderBalance.EXTERNAL:\n            return OrderBalance.ERC20;\n        case OrderBalance.INTERNAL:\n            return OrderBalance.INTERNAL;\n        default:\n            throw new Error(`invalid order balance ${balance}`);\n    }\n}\n/**\n * Normalizes an order for hashing and signing, so that it can be used with\n * Ethers.js for EIP-712 operations.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function normalizeOrder(order) {\n    var _a, _b;\n    if (order.receiver === ethers.constants.AddressZero) {\n        throw new Error(\"receiver cannot be address(0)\");\n    }\n    const normalizedOrder = Object.assign(Object.assign({}, order), { sellTokenBalance: (_a = order.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20, receiver: (_b = order.receiver) !== null && _b !== void 0 ? _b : ethers.constants.AddressZero, validTo: timestamp(order.validTo), appData: hashify(order.appData), buyTokenBalance: normalizeBuyTokenBalance(order.buyTokenBalance) });\n    return normalizedOrder;\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param types The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashTypedData(domain, types, data) {\n    return ethers.utils._TypedDataEncoder.hash(domain, types, data);\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param order The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrder(domain, order) {\n    return hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order));\n}\n/**\n * Compute the 32-byte signing hash for the specified cancellation.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUid The unique identifier of the order to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellation(domain, orderUid) {\n    return hashOrderCancellations(domain, [orderUid]);\n}\n/**\n * Compute the 32-byte signing hash for the specified order cancellations.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellations(domain, orderUids) {\n    return hashTypedData(domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids });\n}\n/**\n * The byte length of an order UID.\n */\nexport const ORDER_UID_LENGTH = 56;\n/**\n * Computes the order UID for an order and the given owner.\n */\nexport function computeOrderUid(domain, order, owner) {\n    return packOrderUidParams({\n        orderDigest: hashOrder(domain, order),\n        owner,\n        validTo: order.validTo,\n    });\n}\n/**\n * Compute the unique identifier describing a user order in the settlement\n * contract.\n *\n * @param OrderUidParams The parameters used for computing the order's unique\n * identifier.\n * @returns A string that unequivocally identifies the order of the user.\n */\nexport function packOrderUidParams({ orderDigest, owner, validTo, }) {\n    return ethers.utils.solidityPack([\"bytes32\", \"address\", \"uint32\"], [orderDigest, owner, timestamp(validTo)]);\n}\n/**\n * Extracts the order unique identifier parameters from the specified bytes.\n *\n * @param orderUid The order UID encoded as a hexadecimal string.\n * @returns The extracted order UID parameters.\n */\nexport function extractOrderUidParams(orderUid) {\n    const bytes = ethers.utils.arrayify(orderUid);\n    if (bytes.length != ORDER_UID_LENGTH) {\n        throw new Error(\"invalid order UID length\");\n    }\n    const view = new DataView(bytes.buffer);\n    return {\n        orderDigest: ethers.utils.hexlify(bytes.subarray(0, 32)),\n        owner: ethers.utils.getAddress(ethers.utils.hexlify(bytes.subarray(32, 52))),\n        validTo: view.getUint32(52),\n    };\n}\n//# sourceMappingURL=order.js.map","/**\n * Normalizes interaction data so that it is ready to be be ABI encoded.\n *\n * @param interaction The interaction to normalize.\n * @return The normalized interaction.\n */\nexport function normalizeInteraction(interaction) {\n    return Object.assign({ value: 0, callData: \"0x\" }, interaction);\n}\n/**\n * Normalizes data for many interactions so that they can be ABI encoded. This\n * calls [`normalizeInteraction`] for each interaction.\n *\n * @param interactions The interactions to normalize.\n * @return The normalized interactions.\n */\nexport function normalizeInteractions(interactions) {\n    return interactions.map(normalizeInteraction);\n}\n//# sourceMappingURL=interaction.js.map","/**\n * Checks whether the specified signer is a typed data signer.\n */\nexport function isTypedDataSigner(signer) {\n    return \"_signTypedData\" in signer;\n}\n/**\n * Checks whether the specified provider is a JSON RPC provider.\n */\nexport function isJsonRpcProvider(provider) {\n    return \"send\" in provider;\n}\n//# sourceMappingURL=ethers.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\nimport { ORDER_TYPE_FIELDS, CANCELLATIONS_TYPE_FIELDS, normalizeOrder, hashTypedData, } from \"./order\";\nimport { isTypedDataSigner, } from \"./types/ethers\";\n/**\n * Value returned by a call to `isValidSignature` if the signature was verified\n * successfully. The value is defined in the EIP-1271 standard as:\n * bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n */\nexport const EIP1271_MAGICVALUE = ethers.utils.hexDataSlice(ethers.utils.id(\"isValidSignature(bytes32,bytes)\"), 0, 4);\n/**\n * Marker value indicating a presignature is set.\n */\nexport const PRE_SIGNED = ethers.utils.id(\"GPv2Signing.Scheme.PreSign\");\n/**\n * The signing scheme used to sign the order.\n */\nexport var SigningScheme;\n(function (SigningScheme) {\n    /**\n     * The EIP-712 typed data signing scheme. This is the preferred scheme as it\n     * provides more infomation to wallets performing the signature on the data\n     * being signed.\n     *\n     * <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-domainseparator>\n     */\n    SigningScheme[SigningScheme[\"EIP712\"] = 0] = \"EIP712\";\n    /**\n     * Message signed using eth_sign RPC call.\n     */\n    SigningScheme[SigningScheme[\"ETHSIGN\"] = 1] = \"ETHSIGN\";\n    /**\n     * Smart contract signatures as defined in EIP-1271.\n     *\n     * <https://eips.ethereum.org/EIPS/eip-1271>\n     */\n    SigningScheme[SigningScheme[\"EIP1271\"] = 2] = \"EIP1271\";\n    /**\n     * Pre-signed order.\n     */\n    SigningScheme[SigningScheme[\"PRESIGN\"] = 3] = \"PRESIGN\";\n})(SigningScheme || (SigningScheme = {}));\nfunction ecdsaSignTypedData(scheme, owner, domain, types, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let signature = null;\n        switch (scheme) {\n            case SigningScheme.EIP712:\n                if (!isTypedDataSigner(owner)) {\n                    throw new Error(\"signer does not support signing typed data\");\n                }\n                signature = yield owner._signTypedData(domain, types, data);\n                break;\n            case SigningScheme.ETHSIGN:\n                signature = yield owner.signMessage(ethers.utils.arrayify(hashTypedData(domain, types, data)));\n                break;\n            default:\n                throw new Error(\"invalid signing scheme\");\n        }\n        // Passing the signature through split/join to normalize the `v` byte.\n        // Some wallets do not pad it with `27`, which causes a signature failure\n        // `splitSignature` pads it if needed, and `joinSignature` simply puts it back together\n        return ethers.utils.joinSignature(ethers.utils.splitSignature(signature));\n    });\n}\n/**\n * Returns the signature for the specified order with the signing scheme encoded\n * into the signature.\n *\n * @param domain The domain to sign the order for. This is used by the smart\n * contract to ensure orders can't be replayed across different applications,\n * but also different deployments (as the contract chain ID and address are\n * mixed into to the domain value).\n * @param order The order to sign.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the order.\n */\nexport function signOrder(domain, order, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order)),\n        };\n    });\n}\n/**\n * Returns the signature for cancelling a single order with the specified\n * signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUid The unique identifier of the order being cancelled.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellation(domain, orderUid, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return signOrderCancellations(domain, [orderUid], owner, scheme);\n    });\n}\n/**\n * Returns the signature for cancelling multiple orders by UID with the\n * specified signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellations(domain, orderUids, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids }),\n        };\n    });\n}\n/**\n * Encodes the necessary data required for the Gnosis Protocol contracts to\n * verify an EIP-1271 signature.\n *\n * @param signature The EIP-1271 signature data to encode.\n */\nexport function encodeEip1271SignatureData({ verifier, signature, }) {\n    return ethers.utils.solidityPack([\"address\", \"bytes\"], [verifier, signature]);\n}\n/**\n * Decodes a GPv2 EIP-1271-type signature into the actual EIP-1271 signature\n * and the verifier contract.\n *\n * @param signature The EIP-1271 signature data to decode.\n * @returns decodedSignature The decoded signature object, composed of an\n * EIP-1271 signature and a verifier.\n */\nexport function decodeEip1271SignatureData(signature) {\n    const arrayifiedSignature = ethers.utils.arrayify(signature);\n    const verifier = ethers.utils.getAddress(ethers.utils.hexlify(arrayifiedSignature.slice(0, 20)));\n    return {\n        verifier,\n        signature: arrayifiedSignature.slice(20),\n    };\n}\n//# sourceMappingURL=sign.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers, BigNumber } from \"ethers\";\nimport { normalizeInteraction, } from \"./interaction\";\nimport { ORDER_TYPE_FIELDS, ORDER_UID_LENGTH, OrderBalance, OrderKind, hashTypedData, normalizeBuyTokenBalance, normalizeOrder, } from \"./order\";\nimport { SigningScheme, encodeEip1271SignatureData, signOrder, decodeEip1271SignatureData, } from \"./sign\";\n/**\n * The stage an interaction should be executed in.\n */\nexport var InteractionStage;\n(function (InteractionStage) {\n    /**\n     * A pre-settlement intraction.\n     *\n     * The interaction will be executed before any trading occurs. This can be\n     * used, for example, to perform as EIP-2612 `permit` call for a user trading\n     * in the current settlement.\n     */\n    InteractionStage[InteractionStage[\"PRE\"] = 0] = \"PRE\";\n    /**\n     * An intra-settlement interaction.\n     *\n     * The interaction will be executed after all trade sell amounts are\n     * transferred into the settlement contract, but before the buy amounts are\n     * transferred out to the traders. This can be used, for example, to interact\n     * with on-chain AMMs.\n     */\n    InteractionStage[InteractionStage[\"INTRA\"] = 1] = \"INTRA\";\n    /**\n     * A post-settlement interaction.\n     *\n     * The interaction will be executed after all trading has completed.\n     */\n    InteractionStage[InteractionStage[\"POST\"] = 2] = \"POST\";\n})(InteractionStage || (InteractionStage = {}));\n/**\n * An object listing all flag options in order along with their bit offset.\n */\nexport const FLAG_MASKS = {\n    kind: {\n        offset: 0,\n        options: [OrderKind.SELL, OrderKind.BUY],\n    },\n    partiallyFillable: {\n        offset: 1,\n        options: [false, true],\n    },\n    sellTokenBalance: {\n        offset: 2,\n        options: [\n            OrderBalance.ERC20,\n            undefined,\n            OrderBalance.EXTERNAL,\n            OrderBalance.INTERNAL,\n        ],\n    },\n    buyTokenBalance: {\n        offset: 4,\n        options: [OrderBalance.ERC20, OrderBalance.INTERNAL],\n    },\n    signingScheme: {\n        offset: 5,\n        options: [\n            SigningScheme.EIP712,\n            SigningScheme.ETHSIGN,\n            SigningScheme.EIP1271,\n            SigningScheme.PRESIGN,\n        ],\n    },\n};\nfunction encodeFlag(key, flag) {\n    const index = FLAG_MASKS[key].options.findIndex((search) => search === flag);\n    if (index === undefined) {\n        throw new Error(`Bad key/value pair to encode: ${key}/${flag}`);\n    }\n    return index << FLAG_MASKS[key].offset;\n}\n// Counts the smallest mask needed to store the input options in the masked\n// bitfield.\nfunction mask(options) {\n    const num = options.length;\n    const bitCount = 32 - Math.clz32(num - 1);\n    return (1 << bitCount) - 1;\n}\nfunction decodeFlag(key, flag) {\n    const { offset, options } = FLAG_MASKS[key];\n    const numberFlags = BigNumber.from(flag).toNumber();\n    const index = (numberFlags >> offset) & mask(options);\n    // This type casting should not be needed\n    const decoded = options[index];\n    if (decoded === undefined || index < 0) {\n        throw new Error(`Invalid input flag for ${key}: 0b${numberFlags.toString(2)}`);\n    }\n    return decoded;\n}\n/**\n * Encodes signing scheme as a bitfield.\n *\n * @param scheme The signing scheme to encode.\n * @return The bitfield result.\n */\nexport function encodeSigningScheme(scheme) {\n    return encodeFlag(\"signingScheme\", scheme);\n}\n/**\n * Decodes signing scheme from a bitfield.\n *\n * @param flag The encoded order flag.\n * @return The decoded signing scheme.\n */\nexport function decodeSigningScheme(flags) {\n    return decodeFlag(\"signingScheme\", flags);\n}\n/**\n * Encodes order flags as a bitfield.\n *\n * @param flags The order flags to encode.\n * @return The bitfield result.\n */\nexport function encodeOrderFlags(flags) {\n    var _a;\n    return (encodeFlag(\"kind\", flags.kind) |\n        encodeFlag(\"partiallyFillable\", flags.partiallyFillable) |\n        encodeFlag(\"sellTokenBalance\", (_a = flags.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20) |\n        encodeFlag(\"buyTokenBalance\", normalizeBuyTokenBalance(flags.buyTokenBalance)));\n}\n/**\n * Decode order flags from a bitfield.\n *\n * @param flags The order flags encoded as a bitfield.\n * @return The decoded order flags.\n */\nexport function decodeOrderFlags(flags) {\n    return {\n        kind: decodeFlag(\"kind\", flags),\n        partiallyFillable: decodeFlag(\"partiallyFillable\", flags),\n        sellTokenBalance: decodeFlag(\"sellTokenBalance\", flags),\n        buyTokenBalance: decodeFlag(\"buyTokenBalance\", flags),\n    };\n}\n/**\n * Encodes trade flags as a bitfield.\n *\n * @param flags The trade flags to encode.\n * @return The bitfield result.\n */\nexport function encodeTradeFlags(flags) {\n    return encodeOrderFlags(flags) | encodeSigningScheme(flags.signingScheme);\n}\n/**\n * Decode trade flags from a bitfield.\n *\n * @param flags The trade flags encoded as a bitfield.\n * @return The bitfield result.\n */\nexport function decodeTradeFlags(flags) {\n    return Object.assign(Object.assign({}, decodeOrderFlags(flags)), { signingScheme: decodeSigningScheme(flags) });\n}\nexport function encodeSignatureData(sig) {\n    switch (sig.scheme) {\n        case SigningScheme.EIP712:\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.joinSignature(sig.data);\n        case SigningScheme.EIP1271:\n            return encodeEip1271SignatureData(sig.data);\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(sig.data);\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\nexport function decodeSignatureOwner(domain, order, scheme, sig) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return ethers.utils.verifyTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order), sig);\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.verifyMessage(ethers.utils.arrayify(hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order))), sig);\n        case SigningScheme.EIP1271:\n            return decodeEip1271SignatureData(sig).verifier;\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(ethers.utils.hexlify(sig));\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\n/**\n * Encodes a trade to be used with the settlement contract.\n */\nexport function encodeTrade(tokens, order, signature, { executedAmount }) {\n    const tradeFlags = Object.assign(Object.assign({}, order), { signingScheme: signature.scheme });\n    const o = normalizeOrder(order);\n    return {\n        sellTokenIndex: tokens.index(o.sellToken),\n        buyTokenIndex: tokens.index(o.buyToken),\n        receiver: o.receiver,\n        sellAmount: o.sellAmount,\n        buyAmount: o.buyAmount,\n        validTo: o.validTo,\n        appData: o.appData,\n        feeAmount: o.feeAmount,\n        flags: encodeTradeFlags(tradeFlags),\n        executedAmount,\n        signature: encodeSignatureData(signature),\n    };\n}\n/**\n * A class used for tracking tokens when encoding settlements.\n *\n * This is used as settlement trades reference tokens by index instead of\n * directly by address for multiple reasons:\n * - Reduce encoding size of orders to save on `calldata` gas.\n * - Direct access to a token's clearing price on settlement instead of\n *   requiring a search.\n */\nexport class TokenRegistry {\n    constructor() {\n        this._tokens = [];\n        this._tokenMap = {};\n    }\n    /**\n     * Gets the array of token addresses currently stored in the registry.\n     */\n    get addresses() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.slice();\n    }\n    /**\n     * Retrieves the token index for the specified token address. If the token is\n     * not in the registry, it will be added.\n     *\n     * @param token The token address to add to the registry.\n     * @return The token index.\n     */\n    index(token) {\n        // NOTE: Verify and normalize the address into a case-checksummed address.\n        // Not only does this ensure validity of the addresses early on, it also\n        // makes it so `0xff...f` and `0xFF..F` map to the same ID.\n        const tokenAddress = ethers.utils.getAddress(token);\n        let tokenIndex = this._tokenMap[tokenAddress];\n        if (tokenIndex === undefined) {\n            tokenIndex = this._tokens.length;\n            this._tokens.push(tokenAddress);\n            this._tokenMap[tokenAddress] = tokenIndex;\n        }\n        return tokenIndex;\n    }\n}\n/**\n * A class for building calldata for a settlement.\n *\n * The encoder ensures that token addresses are kept track of and performs\n * necessary computation in order to map each token addresses to IDs to\n * properly encode order parameters for trades.\n */\nexport class SettlementEncoder {\n    /**\n     * Creates a new settlement encoder instance.\n     * @param domain Domain used for signing orders. See {@link signOrder} for\n     * more details.\n     */\n    constructor(domain) {\n        this.domain = domain;\n        this._tokens = new TokenRegistry();\n        this._trades = [];\n        this._interactions = {\n            [InteractionStage.PRE]: [],\n            [InteractionStage.INTRA]: [],\n            [InteractionStage.POST]: [],\n        };\n        this._orderRefunds = {\n            filledAmounts: [],\n            preSignatures: [],\n        };\n    }\n    /**\n     * Gets the array of token addresses used by the currently encoded orders.\n     */\n    get tokens() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.addresses;\n    }\n    /**\n     * Gets the encoded trades.\n     */\n    get trades() {\n        return this._trades.slice();\n    }\n    /**\n     * Gets all encoded interactions for all stages.\n     *\n     * Note that order refund interactions are included as post-interactions.\n     */\n    get interactions() {\n        return [\n            this._interactions[InteractionStage.PRE].slice(),\n            this._interactions[InteractionStage.INTRA].slice(),\n            [\n                ...this._interactions[InteractionStage.POST],\n                ...this.encodedOrderRefunds,\n            ],\n        ];\n    }\n    /**\n     * Gets the order refunds encoded as interactions.\n     */\n    get encodedOrderRefunds() {\n        const { filledAmounts, preSignatures } = this._orderRefunds;\n        if (filledAmounts.length + preSignatures.length === 0) {\n            return [];\n        }\n        const settlement = this.domain.verifyingContract;\n        if (settlement === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        // NOTE: Avoid importing the full GPv2Settlement contract artifact just for\n        // a tiny snippet of the ABI. Unit and integration tests will catch any\n        // issues that may arise from this definition becoming out of date.\n        const iface = new ethers.utils.Interface([\n            \"function freeFilledAmountStorage(bytes[] orderUids)\",\n            \"function freePreSignatureStorage(bytes[] orderUids)\",\n        ]);\n        const interactions = [];\n        for (const [functionName, orderUids] of [\n            [\"freeFilledAmountStorage\", filledAmounts],\n            [\"freePreSignatureStorage\", preSignatures],\n        ].filter(([, orderUids]) => orderUids.length > 0)) {\n            interactions.push(normalizeInteraction({\n                target: settlement,\n                callData: iface.encodeFunctionData(functionName, [orderUids]),\n            }));\n        }\n        return interactions;\n    }\n    /**\n     * Returns a clearing price vector for the current settlement tokens from the\n     * provided price map.\n     *\n     * @param prices The price map from token address to price.\n     * @return The price vector.\n     */\n    clearingPrices(prices) {\n        return this.tokens.map((token) => {\n            const price = prices[token];\n            if (price === undefined) {\n                throw new Error(`missing price for token ${token}`);\n            }\n            return price;\n        });\n    }\n    /**\n     * Encodes a trade from a signed order and executed amount, appending it to\n     * the `calldata` bytes that are being built.\n     *\n     * Additionally, if the order references new tokens that the encoder has not\n     * yet seen, they are added to the tokens array.\n     *\n     * @param order The order of the trade to encode.\n     * @param signature The signature for the order data.\n     * @param tradeExecution The execution details for the trade.\n     */\n    encodeTrade(order, signature, { executedAmount } = {}) {\n        if (order.partiallyFillable && executedAmount === undefined) {\n            throw new Error(\"missing executed amount for partially fillable trade\");\n        }\n        this._trades.push(encodeTrade(this._tokens, order, signature, {\n            executedAmount: executedAmount !== null && executedAmount !== void 0 ? executedAmount : 0,\n        }));\n    }\n    /**\n     * Signs an order and encodes a trade with that order.\n     *\n     * @param order The order to sign for the trade.\n     * @param owner The externally owned account that should sign the order.\n     * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n     * details.\n     * @param tradeExecution The execution details for the trade.\n     */\n    signEncodeTrade(order, owner, scheme, tradeExecution) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signature = yield signOrder(this.domain, order, owner, scheme);\n            this.encodeTrade(order, signature, tradeExecution);\n        });\n    }\n    /**\n     * Encodes the input interaction in the packed format accepted by the smart\n     * contract and adds it to the interactions encoded so far.\n     *\n     * @param stage The stage the interaction should be executed.\n     * @param interaction The interaction to encode.\n     */\n    encodeInteraction(interaction, stage = InteractionStage.INTRA) {\n        this._interactions[stage].push(normalizeInteraction(interaction));\n    }\n    /**\n     * Encodes order UIDs for gas refunds.\n     *\n     * @param settlement The address of the settlement contract.\n     * @param orderRefunds The order refunds to encode.\n     */\n    encodeOrderRefunds(orderRefunds) {\n        var _a, _b;\n        if (this.domain.verifyingContract === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        const filledAmounts = (_a = orderRefunds.filledAmounts) !== null && _a !== void 0 ? _a : [];\n        const preSignatures = (_b = orderRefunds.preSignatures) !== null && _b !== void 0 ? _b : [];\n        if (![...filledAmounts, ...preSignatures].every((orderUid) => ethers.utils.isHexString(orderUid, ORDER_UID_LENGTH))) {\n            throw new Error(\"one or more invalid order UIDs\");\n        }\n        this._orderRefunds.filledAmounts.push(...filledAmounts);\n        this._orderRefunds.preSignatures.push(...preSignatures);\n    }\n    /**\n     * Returns the encoded settlement parameters.\n     */\n    encodedSettlement(prices) {\n        return [\n            this.tokens,\n            this.clearingPrices(prices),\n            this.trades,\n            this.interactions,\n        ];\n    }\n    /**\n     * Returns an encoded settlement that exclusively performs setup interactions.\n     * This method can be used, for example, to set the settlement contract's\n     * allowances to other protocols it may interact with.\n     *\n     * @param interactions The list of setup interactions to encode.\n     */\n    static encodedSetup(...interactions) {\n        const encoder = new SettlementEncoder({ name: \"unused\" });\n        for (const interaction of interactions) {\n            encoder.encodeInteraction(interaction);\n        }\n        return encoder.encodedSettlement({});\n    }\n}\n/**\n * Decodes an order from a settlement trade.\n *\n * @param trade The trade to decode into an order.\n * @param tokens The list of token addresses as they appear in the settlement.\n * @returns The decoded order.\n */\nexport function decodeOrder(trade, tokens) {\n    const sellTokenIndex = BigNumber.from(trade.sellTokenIndex).toNumber();\n    const buyTokenIndex = BigNumber.from(trade.buyTokenIndex).toNumber();\n    if (Math.max(sellTokenIndex, buyTokenIndex) >= tokens.length) {\n        throw new Error(\"Invalid trade\");\n    }\n    return Object.assign({ sellToken: tokens[sellTokenIndex], buyToken: tokens[buyTokenIndex], receiver: trade.receiver, sellAmount: trade.sellAmount, buyAmount: trade.buyAmount, validTo: BigNumber.from(trade.validTo).toNumber(), appData: trade.appData, feeAmount: trade.feeAmount }, decodeOrderFlags(trade.flags));\n}\n//# sourceMappingURL=settlement.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, constants } from \"ethers\";\nimport fetch from \"node-fetch\";\nimport { normalizeOrder, OrderKind, } from \"./order\";\nimport { encodeSignatureData } from \"./settlement\";\nimport { SigningScheme } from \"./sign\";\nexport var Environment;\n(function (Environment) {\n    Environment[Environment[\"Dev\"] = 0] = \"Dev\";\n    Environment[Environment[\"Prod\"] = 1] = \"Prod\";\n})(Environment || (Environment = {}));\nexport const LIMIT_CONCURRENT_REQUESTS = 5;\nexport function apiUrl(environment, network) {\n    switch (environment) {\n        case Environment.Dev:\n            return `https://barn.api.cow.fi/${network}`;\n        case Environment.Prod:\n            return `https://api.cow.fi/${network}`;\n        default:\n            throw new Error(\"Invalid environment\");\n    }\n}\nexport var QuotePriceQuality;\n(function (QuotePriceQuality) {\n    QuotePriceQuality[\"FAST\"] = \"fast\";\n    QuotePriceQuality[\"OPTIMAL\"] = \"optimal\";\n})(QuotePriceQuality || (QuotePriceQuality = {}));\nexport var GetQuoteErrorType;\n(function (GetQuoteErrorType) {\n    GetQuoteErrorType[\"SellAmountDoesNotCoverFee\"] = \"SellAmountDoesNotCoverFee\";\n    GetQuoteErrorType[\"NoLiquidity\"] = \"NoLiquidity\";\n    // other errors are added when necessary\n})(GetQuoteErrorType || (GetQuoteErrorType = {}));\nfunction apiKind(kind) {\n    switch (kind) {\n        case OrderKind.SELL:\n            return \"sell\";\n        case OrderKind.BUY:\n            return \"buy\";\n        default:\n            throw new Error(`Unsupported kind ${kind}`);\n    }\n}\nfunction apiSigningScheme(scheme) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return \"eip712\";\n        case SigningScheme.ETHSIGN:\n            return \"ethsign\";\n        case SigningScheme.EIP1271:\n            return \"eip1271\";\n        case SigningScheme.PRESIGN:\n            return \"presign\";\n        default:\n            throw new Error(`Unsupported signing scheme ${scheme}`);\n    }\n}\nfunction call(route, baseUrl, init) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = `${baseUrl}/api/v1/${route}`;\n        const response = yield fetch(url, init);\n        const body = yield response.text();\n        if (!response.ok) {\n            const error = new Error(`Calling \"${url} ${JSON.stringify(init)} failed with ${response.status}: ${body}`);\n            try {\n                error.apiError = JSON.parse(body);\n            }\n            catch (_a) {\n                // no api error\n            }\n            throw error;\n        }\n        return JSON.parse(body);\n    });\n}\nfunction estimateTradeAmount({ sellToken, buyToken, kind, amount, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const side = kind == OrderKind.SELL\n            ? {\n                kind: OrderKind.SELL,\n                sellAmountAfterFee: amount,\n            }\n            : {\n                kind: OrderKind.BUY,\n                buyAmountAfterFee: amount,\n            };\n        const { quote } = yield getQuote({ baseUrl }, Object.assign({ from: constants.AddressZero, sellToken,\n            buyToken, priceQuality: QuotePriceQuality.FAST }, side));\n        // The services return the quote token used for the price. The quote token\n        // is checked to make sure that the returned price meets our expectations.\n        if (quote.buyToken.toLowerCase() !== buyToken.toLowerCase()) {\n            throw new Error(`Price returned for sell token ${sellToken} uses an incorrect quote token (${quote.buyToken.toLowerCase()} instead of ${buyToken.toLowerCase()})`);\n        }\n        const estimatedAmount = kind == OrderKind.SELL ? quote.buyAmount : quote.sellAmount;\n        return BigNumber.from(estimatedAmount);\n    });\n}\nfunction placeOrder({ order, signature, baseUrl, from, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const normalizedOrder = normalizeOrder(order);\n        return yield call(\"orders\", baseUrl, {\n            method: \"post\",\n            body: JSON.stringify({\n                sellToken: normalizedOrder.sellToken,\n                buyToken: normalizedOrder.buyToken,\n                sellAmount: BigNumber.from(normalizedOrder.sellAmount).toString(),\n                buyAmount: BigNumber.from(normalizedOrder.buyAmount).toString(),\n                validTo: normalizedOrder.validTo,\n                appData: normalizedOrder.appData,\n                feeAmount: BigNumber.from(normalizedOrder.feeAmount).toString(),\n                kind: apiKind(order.kind),\n                partiallyFillable: normalizedOrder.partiallyFillable,\n                signature: encodeSignatureData(signature),\n                signingScheme: apiSigningScheme(signature.scheme),\n                receiver: normalizedOrder.receiver,\n                from,\n            }),\n            headers: { \"Content-Type\": \"application/json\" },\n        });\n    });\n}\nfunction getExecutedSellAmount({ uid, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield call(`orders/${uid}`, baseUrl);\n        return BigNumber.from(response.executedSellAmount);\n    });\n}\nfunction getQuote({ baseUrl }, quote) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Convert BigNumber into JSON strings (native serialisation is a hex object)\n        if (quote.sellAmountBeforeFee) {\n            quote.sellAmountBeforeFee = (quote).sellAmountBeforeFee.toString();\n        }\n        if (quote.sellAmountAfterFee) {\n            quote.sellAmountAfterFee = (quote).sellAmountAfterFee.toString();\n        }\n        if (quote.buyAmountAfterFee) {\n            quote.buyAmountAfterFee = (quote).buyAmountAfterFee.toString();\n        }\n        return call(\"quote\", baseUrl, {\n            method: \"post\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(quote),\n        });\n    });\n}\nexport class Api {\n    constructor(network, baseUrlOrEnv) {\n        this.network = network;\n        let baseUrl;\n        if (typeof baseUrlOrEnv === \"string\") {\n            baseUrl = baseUrlOrEnv;\n        }\n        else {\n            baseUrl = apiUrl(baseUrlOrEnv, network);\n        }\n        this.baseUrl = baseUrl;\n    }\n    apiCallParams() {\n        return { network: this.network, baseUrl: this.baseUrl };\n    }\n    estimateTradeAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return estimateTradeAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    placeOrder(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return placeOrder(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getExecutedSellAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getExecutedSellAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getQuote(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getQuote(this.apiCallParams(), query);\n        });\n    }\n}\n//# sourceMappingURL=api.js.map","import { utils } from \"ethers\";\n/**\n * The salt used when deterministically deploying smart contracts.\n */\nexport const SALT = utils.formatBytes32String(\"Mattresses in Berlin!\");\n/**\n * The contract used to deploy contracts deterministically with CREATE2.\n * The address is chosen by the hardhat-deploy library.\n * It is the same in any EVM-based network.\n *\n * https://github.com/Arachnid/deterministic-deployment-proxy\n */\nexport const DEPLOYER_CONTRACT = \"0x4e59b44847b379578588920ca78fbf26c0b4956c\";\n/**\n * Dictionary containing all deployed contract names.\n */\nexport const CONTRACT_NAMES = {\n    authenticator: \"GPv2AllowListAuthentication\",\n    settlement: \"GPv2Settlement\",\n    tradeSimulator: \"GPv2TradeSimulator\",\n};\n/**\n * Computes the deterministic address at which the contract will be deployed.\n * This address does not depend on which network the contract is deployed to.\n *\n * @param contractName Name of the contract for which to find the address.\n * @param deploymentArguments Extra arguments that are necessary to deploy.\n * @returns The address that is expected to store the deployed code.\n */\nexport function deterministicDeploymentAddress({ abi, bytecode }, deploymentArguments) {\n    const contractInterface = new utils.Interface(abi);\n    const deployData = utils.hexConcat([\n        bytecode,\n        contractInterface.encodeDeploy(deploymentArguments),\n    ]);\n    return utils.getCreate2Address(DEPLOYER_CONTRACT, SALT, utils.keccak256(deployData));\n}\n//# sourceMappingURL=deploy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, Contract, ethers } from \"ethers\";\n/**\n * Compute an EIP-1967 slot for the specified name. The proxy contract used by\n * `hardhat-deploy` implements EIP-1967 (Standard Proxy Storage Slot).\n *\n * <https://eips.ethereum.org/EIPS/eip-1967>.\n */\nfunction slot(name) {\n    return ethers.utils.defaultAbiCoder.encode([\"bytes32\"], [BigNumber.from(ethers.utils.id(name)).sub(1)]);\n}\nconst IMPLEMENTATION_STORAGE_SLOT = slot(\"eip1967.proxy.implementation\");\nconst OWNER_STORAGE_SLOT = slot(\"eip1967.proxy.admin\");\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the contract storing the proxy implementation.\n */\nexport function implementationAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [implementation] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, IMPLEMENTATION_STORAGE_SLOT));\n        return implementation;\n    });\n}\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the administrator of the proxy.\n */\nexport function ownerAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [owner] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, OWNER_STORAGE_SLOT));\n        return owner;\n    });\n}\n/**\n * EIP-173 proxy ABI in \"human-readable ABI\" format. The proxy used by the\n * deployment plugin implements this interface, and copying it here avoids\n * pulling in `hardhat` as a dependency for just this ABI.\n *\n * <https://eips.ethereum.org/EIPS/eip-173#specification>\n */\nexport const EIP173_PROXY_ABI = [\n    \"event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)\",\n    \"function owner() view external returns(address)\",\n    \"function transferOwnership(address newOwner) external\",\n    \"function supportsInterface(bytes4 interfaceID) external view returns (bool)\",\n];\n/**\n * Returns the proxy interface for the specified address.\n *\n * @param contract The proxy contract to return a proxy interface for.\n * @returns A Ethers.js contract instance for interacting with the proxy.\n */\nexport function proxyInterface(contract) {\n    var _a;\n    return new Contract(contract.address, EIP173_PROXY_ABI, (_a = contract.signer) !== null && _a !== void 0 ? _a : contract.provider);\n}\n//# sourceMappingURL=proxy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\n/**\n * Balancer Vault partial ABI interface.\n *\n * This definition only contains the Vault methods that are used by GPv2 Vault\n * relayer. It is copied here to avoid relying on build artifacts.\n */\nexport const VAULT_INTERFACE = new ethers.utils.Interface([\n    \"function manageUserBalance((uint8, address, uint256, address, address)[])\",\n    \"function batchSwap(uint8, (bytes32, uint256, uint256, uint256, bytes)[], address[], (address, bool, address, bool), int256[], uint256)\",\n]);\n/**\n * Grants the required roles to the specified Vault relayer.\n *\n * This method is intended to be called by the Balancer Vault admin, and **not**\n * traders. It is included in the exported TypeScript library for completeness\n * and \"documentation\".\n *\n * @param authorizer The Vault authorizer contract that manages access.\n * @param vaultAddress The address to the Vault.\n * @param vaultRelayerAddress The address to the GPv2 Vault relayer contract.\n */\nexport function grantRequiredRoles(authorizer, vaultAddress, vaultRelayerAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const name in VAULT_INTERFACE.functions) {\n            yield authorizer.grantRole(ethers.utils.solidityKeccak256([\"uint256\", \"bytes4\"], [vaultAddress, VAULT_INTERFACE.getSighash(name)]), vaultRelayerAddress);\n        }\n    });\n}\n//# sourceMappingURL=vault.js.map","import { utils, providers, BigNumber } from 'ethers'\nimport {\n  COMPOSABLE_COW_CONTRACT_ADDRESS,\n  EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS,\n  SupportedChainId,\n} from '../common'\nimport { ExtensibleFallbackHandler__factory } from './generated'\nimport { BlockInfo, ConditionalOrderParams } from './types'\nimport { Order, OrderBalance, OrderKind } from '@wowswapfork/contracts'\nimport { GPv2Order } from './generated/ComposableCoW'\n\nconst ERC20_BALANCE_VALUES = ['erc20', '0x5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9']\nconst EXTERNAL_BALANCE_VALUES = ['external', '0xabee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632']\nconst INTERNAL_BALANCE_VALUES = ['internal', '0x4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce']\nconst SELL_KIND_VALUES = ['sell', '0xf3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775']\nconst BUY_KIND_VALUES = ['buy', '0x6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc']\n\n// Define the ABI tuple for the ConditionalOrderParams struct\nexport const CONDITIONAL_ORDER_PARAMS_ABI = ['tuple(address handler, bytes32 salt, bytes staticInput)']\n\nexport const DEFAULT_TOKEN_FORMATTER = (address: string, amount: BigNumber) => `${amount}@${address}`\n\nexport function isExtensibleFallbackHandler(handler: string, chainId: SupportedChainId): boolean {\n  return handler === EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId]\n}\n\nexport function isComposableCow(handler: string, chainId: SupportedChainId): boolean {\n  return handler === COMPOSABLE_COW_CONTRACT_ADDRESS[chainId]\n}\n\nexport async function getDomainVerifier(\n  safe: string,\n  domain: string,\n  chainId: SupportedChainId,\n  provider: providers.Provider\n): Promise<string> {\n  const contract = ExtensibleFallbackHandler__factory.connect(\n    EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId],\n    provider\n  )\n  return await contract.callStatic.domainVerifiers(safe, domain)\n}\n\nexport function createSetDomainVerifierTx(domain: string, verifier: string): string {\n  return ExtensibleFallbackHandler__factory.createInterface().encodeFunctionData('setDomainVerifier', [\n    domain,\n    verifier,\n  ])\n}\n\n/**\n * Encode the `ConditionalOrderParams` for the conditional order.\n *\n * @param params The `ConditionalOrderParams` struct representing the conditional order as taken from a merkle tree.\n * @returns The ABI-encoded conditional order.\n * @see ConditionalOrderParams\n */\nexport function encodeParams(params: ConditionalOrderParams): string {\n  return utils.defaultAbiCoder.encode(CONDITIONAL_ORDER_PARAMS_ABI, [params])\n}\n\n/**\n * Decode the `ConditionalOrderParams` for the conditional order.\n *\n * @param encoded The encoded conditional order.\n * @returns The decoded conditional order.\n */\nexport function decodeParams(encoded: string): ConditionalOrderParams {\n  const { handler, salt, staticInput } = utils.defaultAbiCoder.decode(CONDITIONAL_ORDER_PARAMS_ABI, encoded)[0]\n  return { handler, salt, staticInput }\n}\n\n/**\n * Helper method for validating ABI types.\n * @param types ABI types to validate against.\n * @param values The values to validate.\n * @returns {boolean} Whether the values are valid ABI for the given types.\n */\nexport function isValidAbi(types: readonly (string | utils.ParamType)[], values: any[]): boolean {\n  try {\n    utils.defaultAbiCoder.encode(types, values)\n  } catch (e) {\n    return false\n  }\n  return true\n}\n\nexport async function getBlockInfo(provider: providers.Provider): Promise<BlockInfo> {\n  const block = await provider.getBlock('latest')\n\n  return {\n    blockNumber: block.number,\n    blockTimestamp: block.timestamp,\n  }\n}\n\nexport function formatEpoch(epoch: number): string {\n  return new Date(epoch * 1000).toISOString()\n}\n\n/**\n * Convert a balance source/destination hash to a string\n *\n * @param balance balance source/destination hash\n * @returns string representation of the balance\n * @throws if the balance is not recognized\n */\nfunction balanceToString(balance: string) {\n  if (ERC20_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.ERC20\n  } else if (EXTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.EXTERNAL\n  } else if (INTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.INTERNAL\n  } else {\n    throw new Error(`Unknown balance type: ${balance}`)\n  }\n}\n\n/**\n * Convert an order kind hash to a string\n * @param kind of order in hash format\n * @returns string representation of the order kind\n */\nfunction kindToString(kind: string) {\n  if (SELL_KIND_VALUES.includes(kind)) {\n    return OrderKind.SELL\n  } else if (BUY_KIND_VALUES.includes(kind)) {\n    return OrderKind.BUY\n  } else {\n    throw new Error(`Unknown kind: ${kind}`)\n  }\n}\n\nexport function fromStructToOrder(order: GPv2Order.DataStruct): Order {\n  const {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    buyTokenBalance,\n    sellTokenBalance,\n    feeAmount,\n    kind,\n    receiver,\n    validTo,\n    partiallyFillable,\n    appData,\n  } = order\n\n  return {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    feeAmount,\n    receiver,\n    partiallyFillable,\n    appData,\n    validTo: Number(validTo),\n    kind: kindToString(kind.toString()),\n    sellTokenBalance: balanceToString(sellTokenBalance.toString()),\n    buyTokenBalance: balanceToString(buyTokenBalance.toString()),\n  }\n}\n","import { providers } from 'ethers'\nimport { COMPOSABLE_COW_CONTRACT_ADDRESS, SupportedChainId } from '../common'\nimport { ComposableCoW, ComposableCoW__factory } from './generated'\nimport { ComposableCoWInterface } from './generated/ComposableCoW'\n\nlet composableCowInterfaceCache: ComposableCoWInterface | undefined\nlet composableCowContractCache: ComposableCoW | undefined\n\nexport function getComposableCowInterface(): ComposableCoWInterface {\n  if (!composableCowInterfaceCache) {\n    composableCowInterfaceCache = ComposableCoW__factory.createInterface()\n  }\n\n  return composableCowInterfaceCache\n}\n\nexport function getComposableCow(chain: SupportedChainId, provider: providers.Provider): ComposableCoW {\n  if (!composableCowContractCache) {\n    composableCowContractCache = ComposableCoW__factory.connect(COMPOSABLE_COW_CONTRACT_ADDRESS[chain], provider)\n  }\n\n  return composableCowContractCache\n}\n","import { BigNumber, constants, ethers, utils } from 'ethers'\nimport { GPv2Order, IConditionalOrder } from './generated/ComposableCoW'\n\nimport { decodeParams, encodeParams, fromStructToOrder } from './utils'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  IsValidResult,\n  OwnerContext,\n  PollParams,\n  PollResult,\n  PollResultCode,\n  PollResultErrors,\n} from './types'\nimport { getComposableCow, getComposableCowInterface } from './contracts'\nimport { OrderBookApi, UID } from '../order-book'\nimport { computeOrderUid } from '../utils'\n\nconst orderBookCache: Record<string, OrderBookApi> = {}\n\n/**\n * An abstract base class from which all conditional orders should inherit.\n *\n * This class provides some basic functionality to help with handling conditional orders,\n * such as:\n * - Validating the conditional order\n * - Creating a human-readable string representation of the conditional order\n * - Serializing the conditional order for use with the `IConditionalOrder` struct\n * - Getting any dependencies for the conditional order\n * - Getting the off-chain input for the conditional order\n *\n * **NOTE**: Instances of conditional orders have an `id` property that is a `keccak256` hash of\n *           the serialized conditional order.\n */\nexport abstract class ConditionalOrder<D, S> {\n  public readonly handler: string\n  public readonly salt: string\n  public readonly data: D\n  public readonly staticInput: S\n  public readonly hasOffChainInput: boolean\n\n  /**\n   * A constructor that provides some basic validation for the conditional order.\n   *\n   * This constructor **MUST** be called by any class that inherits from `ConditionalOrder`.\n   *\n   * **NOTE**: The salt is optional and will be randomly generated if not provided.\n   * @param handler The address of the handler for the conditional order.\n   * @param salt A 32-byte string used to salt the conditional order.\n   * @param data The data of the order\n   * @param hasOffChainInput Whether the conditional order has off-chain input.\n   * @throws If the handler is not a valid ethereum address.\n   * @throws If the salt is not a valid 32-byte string.\n   */\n  constructor(params: ConditionalOrderArguments<D>) {\n    const { handler, salt = utils.keccak256(utils.randomBytes(32)), data, hasOffChainInput = false } = params\n    // Verify input to the constructor\n    // 1. Verify that the handler is a valid ethereum address\n    if (!ethers.utils.isAddress(handler)) {\n      throw new Error(`Invalid handler: ${handler}`)\n    }\n\n    // 2. Verify that the salt is a valid 32-byte string usable with ethers\n    if (!ethers.utils.isHexString(salt) || ethers.utils.hexDataLength(salt) !== 32) {\n      throw new Error(`Invalid salt: ${salt}`)\n    }\n\n    this.handler = handler\n    this.salt = salt\n    this.data = data\n    this.staticInput = this.transformDataToStruct(data)\n\n    this.hasOffChainInput = hasOffChainInput\n  }\n\n  // TODO: https://github.com/cowprotocol/cow-sdk/issues/155\n  abstract get isSingleOrder(): boolean\n\n  /**\n   * Get a descriptive name for the type of the conditional order (i.e twap, dca, etc).\n   *\n   * @returns {string} The concrete type of the conditional order.\n   */\n  abstract get orderType(): string\n\n  /**\n   * Get the context dependency for the conditional order.\n   *\n   * This is used when calling `createWithContext` or `setRootWithContext` on a ComposableCoW-enabled Safe.\n   * @returns The context dependency.\n   */\n  get context(): ContextFactory | undefined {\n    return undefined\n  }\n\n  assertIsValid(): void {\n    const isValidResult = this.isValid()\n    if (!isValidResult.isValid) {\n      throw new Error(`Invalid order: ${isValidResult.reason}`)\n    }\n  }\n\n  abstract isValid(): IsValidResult\n\n  /**\n   * Get the calldata for creating the conditional order.\n   *\n   * This will automatically determine whether or not to use `create` or `createWithContext` based on the\n   * order type's context dependency.\n   *\n   * **NOTE**: By default, this will cause the create to emit the `ConditionalOrderCreated` event.\n   * @returns The calldata for creating the conditional order.\n   */\n  get createCalldata(): string {\n    this.assertIsValid()\n\n    const context = this.context\n    const composableCow = getComposableCowInterface()\n    const paramsStruct: IConditionalOrder.ConditionalOrderParamsStruct = {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n\n    if (context) {\n      // Create (with context)\n      const contextArgsAbi = context.factoryArgs\n        ? utils.defaultAbiCoder.encode(context.factoryArgs.argsType, context.factoryArgs.args)\n        : '0x'\n      return composableCow.encodeFunctionData('createWithContext', [\n        paramsStruct,\n        context.address,\n        contextArgsAbi,\n        true,\n      ])\n    } else {\n      // Create\n      return composableCow.encodeFunctionData('create', [paramsStruct, true])\n    }\n  }\n\n  /**\n   * Get the calldata for removing a conditional order that was created as a single order.\n   * @returns The calldata for removing the conditional order.\n   */\n  get removeCalldata(): string {\n    this.assertIsValid()\n\n    return getComposableCowInterface().encodeFunctionData('remove', [this.id])\n  }\n\n  /**\n   * Calculate the id of the conditional order (which also happens to be the key used for `ctx` in the ComposableCoW contract).\n   *\n   * This is a `keccak256` hash of the serialized conditional order.\n   * @returns The id of the conditional order.\n   */\n  get id(): string {\n    return utils.keccak256(this.serialize())\n  }\n\n  /**\n   * The context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet\n   *\n   * The context, relates to the 'ctx' in the contract: https://github.com/cowprotocol/composable-cow/blob/c7fb85ab10c05e28a1632ba97a1749fb261fcdfb/src/interfaces/IConditionalOrder.sol#L38\n   */\n  protected get ctx(): string {\n    return this.isSingleOrder ? this.id : constants.HashZero\n  }\n\n  /**\n   * Get the `leaf` of the conditional order. This is the data that is used to create the merkle tree.\n   *\n   * For the purposes of this library, the `leaf` is the `ConditionalOrderParams` struct.\n   * @returns The `leaf` of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  get leaf(): ConditionalOrderParams {\n    return {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n  }\n\n  /**\n   * Calculate the id of the conditional order.\n   * @param leaf The `leaf` representing the conditional order.\n   * @returns The id of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  static leafToId(leaf: ConditionalOrderParams): string {\n    return utils.keccak256(encodeParams(leaf))\n  }\n\n  /**\n   * If the conditional order has off-chain input, return it!\n   *\n   * **NOTE**: This should be overridden by any conditional order that has off-chain input.\n   * @returns The off-chain input.\n   */\n  get offChainInput(): string {\n    return '0x'\n  }\n\n  /**\n   * Create a human-readable string representation of the conditional order.\n   *\n   * @param tokenFormatter An optional function that takes an address and an amount and returns a human-readable string.\n   */\n  abstract toString(tokenFormatter?: (address: string, amount: BigNumber) => string): string\n\n  /**\n   * Serializes the conditional order into it's ABI-encoded form.\n   *\n   * @returns The equivalent of `IConditionalOrder.Params` for the conditional order.\n   */\n  abstract serialize(): string\n\n  /**\n   * Encode the `staticInput` for the conditional order.\n   *\n   * @returns The ABI-encoded `staticInput` for the conditional order.\n   * @see ConditionalOrderParams\n   */\n  abstract encodeStaticInput(): string\n\n  /**\n   * A helper function for generically serializing a conditional order's static input.\n   *\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param data The order's data struct.\n   * @returns An ABI-encoded representation of the order's data struct.\n   */\n  protected encodeStaticInputHelper(orderDataTypes: string[], staticInput: S): string {\n    return utils.defaultAbiCoder.encode(orderDataTypes, [staticInput])\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   *\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  async poll(params: PollParams): Promise<PollResult> {\n    const { chainId, owner, provider, orderbookApiConfig } = params\n    const composableCow = getComposableCow(chainId, provider)\n\n    try {\n      const isValid = this.isValid()\n      // Do a validation first\n      if (!isValid.isValid) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `InvalidConditionalOrder. Reason: ${isValid.reason}`,\n        }\n      }\n\n      // Let the concrete Conditional Order decide about the poll result\n      const pollResult = await this.pollValidate(params)\n      if (pollResult) {\n        return pollResult\n      }\n\n      // Check if the owner authorized the order\n      const isAuthorized = await this.isAuthorized(params)\n      if (!isAuthorized) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `NotAuthorized: Order ${this.id} is not authorized for ${owner} on chain ${chainId}`,\n        }\n      }\n\n      // Lastly, try to get the tradeable order and signature\n      const [order, signature] = await composableCow.getTradeableOrderWithSignature(\n        owner,\n        this.leaf,\n        this.offChainInput,\n        []\n      )\n\n      let orderBookApi = orderBookCache[chainId]\n      if (!orderBookApi) {\n        orderBookApi = new OrderBookApi({ ...orderbookApiConfig, chainId })\n        orderBookCache[chainId] = orderBookApi\n      }\n\n      const orderUid = await computeOrderUid(chainId, owner, fromStructToOrder(order))\n\n      // Check if the order is already in the order book\n      const isOrderInOrderbook = await orderBookApi\n        .getOrder(orderUid)\n        .then(() => true)\n        .catch(() => false)\n\n      // Let the concrete Conditional Order decide about the poll result (in the case the order is already in the orderbook)\n      if (isOrderInOrderbook) {\n        const pollResult = await this.handlePollFailedAlreadyPresent(orderUid, order, params)\n        if (pollResult) {\n          return pollResult\n        }\n\n        return {\n          result: PollResultCode.TRY_NEXT_BLOCK,\n          reason: 'Order already in orderbook',\n        }\n      }\n\n      return {\n        result: PollResultCode.SUCCESS,\n        order,\n        signature,\n      }\n    } catch (error) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        error: error,\n      }\n    }\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param params owner context, to be able to check if the order is authorized\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  public isAuthorized(params: OwnerContext): Promise<boolean> {\n    const { chainId, owner, provider } = params\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.singleOrders(owner, this.id)\n  }\n\n  /**\n   * Checks the value in the cabinet for a given owner and chain\n   *\n   * @param params owner context, to be able to check the cabinet\n   */\n  public cabinet(params: OwnerContext): Promise<string> {\n    const { chainId, owner, provider } = params\n\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.cabinet(owner, this.ctx)\n  }\n\n  /**\n   * Allow concrete conditional orders to perform additional validation for the poll method.\n   *\n   * This will allow the concrete orders to decide when an order shouldn't be polled again. For example, if the orders is expired.\n   * It also allows to signal when should the next check be done. For example, an order could signal that the validations will fail until a certain time or block.\n   *\n   * @param params The poll parameters\n   *\n   * @returns undefined if the concrete order can't make a decision. Otherwise, it returns a PollResultErrors object.\n   */\n  protected abstract pollValidate(params: PollParams): Promise<PollResultErrors | undefined>\n\n  /**\n   * This method lets the concrete conditional order decide what to do if the order yielded in the polling is already present in the Orderbook API.\n   *\n   * The concrete conditional order will have a chance to schedule the next poll.\n   * For example, a TWAP order that has the current part already in the orderbook, can signal that the next poll should be done at the start time of the next part.\n   *\n   * @param params\n   */\n  protected abstract handlePollFailedAlreadyPresent(\n    orderUid: UID,\n    order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined>\n\n  /**\n   * Convert the struct that the contract expect as an encoded `staticInput` into a friendly data object modelling the smart order.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformStructToData(params: S): D\n\n  /**\n   * Converts a friendly data object modelling the smart order into the struct that the contract expect as an encoded `staticInput`.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformDataToStruct(params: D): S\n\n  /**\n   * A helper function for generically deserializing a conditional order.\n   * @param s The ABI-encoded `IConditionalOrder.Params` struct to deserialize.\n   * @param handler Address of the handler for the conditional order.\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param callback A callback function that takes the deserialized data struct and the salt and returns an instance of the class.\n   * @returns An instance of the conditional order class.\n   */\n  protected static deserializeHelper<T>(\n    s: string,\n    handler: string,\n    orderDataTypes: string[],\n    callback: (d: any, salt: string) => T\n  ): T {\n    try {\n      // First, decode the `IConditionalOrder.Params` struct\n      const { handler: recoveredHandler, salt, staticInput } = decodeParams(s)\n\n      // Second, verify that the recovered handler is the correct handler\n      if (!(recoveredHandler == handler)) throw new Error('HandlerMismatch')\n\n      // Third, decode the data struct\n      const [d] = utils.defaultAbiCoder.decode(orderDataTypes, staticInput)\n\n      // Create a new instance of the class\n      return callback(d, salt)\n    } catch (e: any) {\n      if (e.message === 'HandlerMismatch') {\n        throw e\n      } else {\n        throw new Error('InvalidSerializedConditionalOrder')\n      }\n    }\n  }\n}\n","import type { Order } from '@wowswapfork/contracts'\nimport type { SupportedChainId } from './common'\nimport { OrderSigningUtils } from './order-signing'\n\nexport async function computeOrderUid(chainId: SupportedChainId, owner: string, order: Order): Promise<string> {\n  const { computeOrderUid: _computeOrderUid } = await import('@wowswapfork/contracts')\n  const domain = await OrderSigningUtils.getDomain(chainId)\n\n  return _computeOrderUid(domain, order, owner)\n}\n","import { StandardMerkleTree } from '@openzeppelin/merkle-tree'\nimport { BigNumber, providers, utils } from 'ethers'\n\nimport { SupportedChainId } from '../common'\n\nimport { ComposableCoW, GPv2Order } from './generated/ComposableCoW'\nimport { ProofLocation, ProofWithParams, ConditionalOrderParams } from './types'\nimport { ConditionalOrder } from './ConditionalOrder'\nimport { getComposableCow } from './contracts'\n\nconst CONDITIONAL_ORDER_LEAF_ABI = ['address', 'bytes32', 'bytes']\n\nconst PAYLOAD_EMITTED_ABI = ['tuple(bytes32[] proof, tuple(address handler, bytes32 salt, bytes staticInput) params)[]']\n\nexport type Orders = Record<string, ConditionalOrder<unknown, unknown>>\n\n/**\n * Multiplexer for conditional orders - using `ComposableCoW`!\n *\n * This class provides functionality to:\n * - Generate a merkle tree of conditional orders\n * - Generate proofs for all orders in the merkle tree\n * - Save proofs, with the ability to omit / skip specific conditional orders\n * - Support for passing an optional upload function to upload the proofs to a decentralized storage network\n */\nexport class Multiplexer {\n  static orderTypeRegistry: Record<string, new (...args: unknown[]) => ConditionalOrder<unknown, unknown>> = {}\n\n  public chain: SupportedChainId\n  public location: ProofLocation\n\n  private orders: Orders = {}\n  private tree?: StandardMerkleTree<string[]>\n  private ctx?: string\n\n  /**\n   * @param chain The `chainId` for where we're using `ComposableCoW`.\n   * @param orders An optional array of conditional orders to initialize the merkle tree with.\n   * @param root An optional root to verify against.\n   * @param location The location of the proofs for the conditional orders.\n   */\n  constructor(\n    chain: SupportedChainId,\n    orders?: Orders,\n    root?: string,\n    location: ProofLocation = ProofLocation.PRIVATE\n  ) {\n    this.chain = chain\n    this.location = location\n\n    // If orders are provided, the length must be > 0\n    if (orders && Object.keys(orders).length === 0) {\n      throw new Error('orders must have non-zero length')\n    }\n\n    // If orders are provided, so must a root, and vice versa\n    if ((orders && !root) || (!orders && root)) {\n      throw new Error('orders cannot have undefined root')\n    }\n\n    // can only proceed past here if both orders and root are provided, or neither are\n\n    // validate that no unknown order types are provided\n    for (const orderKey in orders) {\n      if (orders.hasOwnProperty(orderKey)) {\n        const order = orders[orderKey]\n        if (!Multiplexer.orderTypeRegistry.hasOwnProperty(order.orderType)) {\n          throw new Error(`Unknown order type: ${order.orderType}`)\n        }\n      }\n    }\n\n    // If orders (and therefore the root) are provided, generate the merkle tree\n    if (orders) {\n      this.orders = orders\n\n      // if generate was successful, we can verify the root\n      if (this.getOrGenerateTree().root !== root) {\n        throw new Error('root mismatch')\n      }\n    }\n  }\n\n  // --- user facing serialization methods ---\n\n  /**\n   * Given a serialized multiplexer, create the multiplexer and rehydrate all conditional orders.\n   * Integrity of the multiplexer will be verified by generating the merkle tree and verifying\n   * the root.\n   *\n   * **NOTE**: Before using this method, you must register all conditional order types using `Multiplexer.registerOrderType`.\n   * @param s The serialized multiplexer.\n   * @returns The multiplexer with all conditional orders rehydrated.\n   * @throws If the multiplexer cannot be deserialized.\n   * @throws If the merkle tree cannot be generated.\n   * @throws If the merkle tree cannot be verified against the root.\n   */\n  static fromJSON(s: string): Multiplexer {\n    // reviver function to deserialize the orders\n    const reviver = (k: string, v: any) => {\n      if (k === 'orders' && typeof v === 'object' && v !== null) {\n        const orders: Orders = {}\n\n        for (const orderKey in v) {\n          if (v.hasOwnProperty(orderKey)) {\n            const { orderType, ...orderData } = v[orderKey]\n\n            if (Multiplexer.orderTypeRegistry.hasOwnProperty(orderType)) {\n              const OrderConstructor = Multiplexer.orderTypeRegistry[orderType]\n              orders[orderKey] = new OrderConstructor(orderData)\n            } else {\n              throw new Error(`Unknown order type: ${orderType}`)\n            }\n          }\n        }\n\n        return orders\n      }\n\n      // Make sure we deserialize `BigNumber` correctly\n      if (typeof v === 'object' && v !== null && v.hasOwnProperty('type') && v.hasOwnProperty('hex')) {\n        if (v.type === 'BigNumber') {\n          return BigNumber.from(v)\n        }\n      }\n\n      return v\n    }\n\n    const { chain, orders, root, location } = JSON.parse(s, reviver)\n    const m = new Multiplexer(chain, orders, root)\n    m.location = location\n    return m\n  }\n\n  /**\n   * Serialize the multiplexer to JSON.\n   *\n   * This will include all state necessary to reconstruct the multiplexer, including the root.\n   * @remarks This will **NOT** include the merkle tree.\n   * @returns The JSON representation of the multiplexer, including the root but excluding the merkle tree.\n   */\n  toJSON(): string {\n    const root = this.getOrGenerateTree().root\n\n    // serialize the multiplexer, including the root but excluding the merkle tree.\n    return JSON.stringify({ ...this, root }, (k, v) => {\n      // filter out the merkle tree\n      if (k === 'tree') return undefined\n      if (typeof v === 'object' && v !== null && 'orderType' in v) {\n        const conditionalOrder = v as ConditionalOrder<unknown, unknown>\n        return {\n          ...conditionalOrder,\n          orderType: conditionalOrder.orderType,\n        }\n      }\n      // We do not do any custom serialization of `BigNumber` in order to preserve it's type.\n      return v\n    })\n  }\n\n  // --- crud methods ---\n\n  /**\n   * Add a conditional order to the merkle tree.\n   * @param order The order to add to the merkle tree.\n   */\n  add<T, P>(order: ConditionalOrder<T, P>): void {\n    order.assertIsValid()\n\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  /**\n   * Remove a conditional order from the merkle tree.\n   * @param id The id of the `ConditionalOrder` to remove from the merkle tree.\n   */\n  remove(id: string): void {\n    delete this.orders[id]\n    this.reset()\n  }\n\n  /**\n   * Update a given conditional order in the merkle tree.\n   * @param id The id of the `ConditionalOrder` to update.\n   * @param updater A function that takes the existing `ConditionalOrder` and context, returning an updated `ConditionalOrder`.\n   */\n  update(\n    id: string,\n    updater: (order: ConditionalOrder<unknown, unknown>, ctx?: string) => ConditionalOrder<unknown, unknown>\n  ): void {\n    // copy the existing order and update it, given the existing context (if any)\n    const order = updater(this.orders[id], this.ctx)\n    // delete the existing order\n    delete this.orders[id]\n\n    // add the updated order\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  // --- accessors ---\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param id The `id` of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` with the given `id`.\n   */\n  getById(id: string): ConditionalOrder<unknown, unknown> {\n    return this.orders[id]\n  }\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param i The index of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` at the given index.\n   */\n  getByIndex(i: number): ConditionalOrder<unknown, unknown> {\n    return this.orders[this.orderIds[i]]\n  }\n\n  /**\n   * Get all the conditional order ids in the multiplexer.\n   */\n  get orderIds(): string[] {\n    return Object.keys(this.orders)\n  }\n\n  get root(): string {\n    return this.getOrGenerateTree().root\n  }\n\n  /**\n   * Retrieve the merkle tree of orders, or generate it if it doesn't exist.\n   *\n   * **CAUTION**: Developers of the SDK should prefer to use this method instead of generating the\n   *              merkle tree themselves. This method makes use of caching to avoid generating the\n   *              merkle tree needlessly.\n   * @throws If the merkle tree cannot be generated.\n   * @returns The merkle tree for the current set of conditional orders.\n   */\n  private getOrGenerateTree(): StandardMerkleTree<string[]> {\n    if (!this.tree) {\n      this.tree = StandardMerkleTree.of(\n        Object.values(this.orders).map((order) => [...Object.values(order.leaf)]),\n        CONDITIONAL_ORDER_LEAF_ABI\n      )\n    }\n\n    return this.tree\n  }\n\n  // --- serialization for watchtowers / indexers ---\n\n  /**\n   * The primary method for watch towers to use when deserializing the proofs and parameters for the conditional orders.\n   * @param s The serialized proofs with parameters for consumption by watchtowers / indexers.\n   * @returns The `ProofWithParams` array.\n   * @throws If the `ProofWithParams` array cannot be deserialized.\n   */\n  static decodeFromJSON(s: string): ProofWithParams[] {\n    // no need to rehydrate `BigNumber` as this is fully ABI encoded\n    return JSON.parse(s)\n  }\n\n  /**\n   * The primary entry point for dapps integrating with `ComposableCoW` to generate the proofs and\n   * parameters for the conditional orders.\n   *\n   * After populating the multiplexer with conditional orders, this method can be used to generate\n   * the proofs and parameters for the conditional orders. The returned `ProofStruct` can then be\n   * used with `setRoot` or `setRootWithContext` on a `ComposableCoW`-enabled Safe.\n   *\n   * @param filter {@link getProofs}\n   * @parma locFn A function that takes the off-chain encoded input, and returns the `location`\n   *        for the `ProofStruct`, and the `data` for the `ProofStruct`.\n   * @returns The ABI-encoded `ProofStruct` for `setRoot` and `setRootWithContext`.\n   */\n  async prepareProofStruct(\n    location: ProofLocation = this.location,\n    filter?: (v: string[]) => boolean,\n    uploader?: (offChainEncoded: string) => Promise<string>\n  ): Promise<ComposableCoW.ProofStruct> {\n    const data = async (): Promise<string> => {\n      switch (location) {\n        case ProofLocation.PRIVATE:\n          return '0x'\n        case ProofLocation.EMITTED:\n          return this.encodeToABI(filter)\n        case ProofLocation.SWARM:\n        case ProofLocation.WAKU:\n        case ProofLocation.IPFS:\n          if (!uploader) throw new Error('Must provide an uploader function')\n          try {\n            return await uploader(this.encodeToJSON(filter))\n          } catch (e) {\n            throw new Error(`Error uploading to decentralized storage ${location}: ${e}`)\n          }\n        default:\n          throw new Error('Unsupported location')\n      }\n    }\n\n    return await data()\n      .then((d) => {\n        try {\n          // validate that `d` is a valid `bytes` ready to be abi-encoded\n          utils.hexlify(utils.arrayify(d))\n\n          // if we get here, we have a valid `data` field for the `ProofStruct`\n          // This means that if there was an upload function, it was called and the upload was successful\n          // note: we don't check if the location has changed because we don't care\n          this.location = location\n\n          return {\n            location,\n            data: d,\n          }\n        } catch (e) {\n          throw new Error(`data returned by uploader is invalid`)\n        }\n      })\n      .catch((e) => {\n        throw new Error(`Error preparing proof struct: ${e}`)\n      })\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  static async poll(\n    owner: string,\n    p: ProofWithParams,\n    chain: SupportedChainId,\n    provider: providers.Provider,\n    offChainInputFn?: (owner: string, params: ConditionalOrderParams) => Promise<string>\n  ): Promise<[GPv2Order.DataStruct, string]> {\n    const composableCow = getComposableCow(chain, provider)\n\n    const offChainInput = offChainInputFn ? await offChainInputFn(owner, p.params) : '0x'\n    return await composableCow.getTradeableOrderWithSignature(owner, p.params, offChainInput, p.proof)\n  }\n\n  /**\n   * The primary entry point for dumping the proofs and parameters for the conditional orders.\n   *\n   * This is to be used by watchtowers / indexers to store the proofs and parameters for the\n   * conditional orders off-chain. The encoding returned by this method may **NOT** contain all\n   * proofs and parameters, depending on the `filter` provided, and therefore should not be used\n   * to rehydrate the multiplexer from a user's perspective.\n   * @param filter {@link getProofs}\n   * @returns A JSON-encoded string of the proofs and parameters for the conditional orders.\n   */\n  dumpProofs(filter?: (v: string[]) => boolean): string {\n    return this.encodeToJSON(filter)\n  }\n\n  dumpProofsAndParams(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    return this.getProofs(filter)\n  }\n\n  /**\n   * Get the proofs with parameters for the conditional orders in the merkle tree.\n   * @param filter A function that takes a conditional order and returns a boolean indicating\n   *               whether the order should be included in the proof.\n   * @returns An array of proofs and their order's parameters for the conditional orders in the\n   *          merkle tree.\n   */\n  private getProofs(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    // Get a list of all entry indices in the tree, excluding any that don't match the filter\n    return [...this.getOrGenerateTree().entries()]\n      .map(([i, v]) => {\n        if ((filter && filter(v)) || filter === undefined) {\n          return { idx: i, value: v }\n        } else {\n          return undefined\n        }\n      })\n      .reduce((acc: ProofWithParams[], x) => {\n        if (x) {\n          const p: ConditionalOrderParams = {\n            handler: x.value[0],\n            salt: x.value[1],\n            staticInput: x.value[2],\n          }\n          acc.push({\n            proof: this.getOrGenerateTree().getProof(x.idx),\n            params: p,\n          })\n        }\n        return acc\n      }, [])\n  }\n\n  /**\n   * ABI-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns ABI-encoded `data` for the `ProofStruct`.\n   */\n  private encodeToABI(filter?: (v: string[]) => boolean): string {\n    return utils.defaultAbiCoder.encode(PAYLOAD_EMITTED_ABI, [this.getProofs(filter)])\n  }\n\n  /**\n   * JSON-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns The JSON-encoded data for storage off-chain.\n   */\n  private encodeToJSON(filter?: (v: string[]) => boolean): string {\n    return JSON.stringify(this.getProofs(filter))\n  }\n\n  /**\n   * A helper to reset the merkle tree.\n   */\n  private reset(): void {\n    this.tree = undefined\n  }\n\n  /**\n   * Register a conditional order type with the multiplexer.\n   *\n   * **CAUTION**: This is required for using `Multiplexer.fromJSON` and `Multiplexer.toJSON`.\n   * @param orderType The order type to register.\n   * @param conditionalOrderClass The class to use for the given order type.\n   */\n  public static registerOrderType(\n    orderType: string,\n    conditionalOrderClass: new (...args: any[]) => ConditionalOrder<unknown, unknown>\n  ) {\n    Multiplexer.orderTypeRegistry[orderType] = conditionalOrderClass\n  }\n\n  /**\n   * Reset the order type registry.\n   */\n  public static resetOrderTypeRegistry() {\n    Multiplexer.orderTypeRegistry = {}\n  }\n}\n","import { type ConditionalOrder } from './ConditionalOrder'\nimport { ConditionalOrderParams } from './types'\n\nexport type FromParams<D, S> = (params: ConditionalOrderParams) => ConditionalOrder<D, S>\nexport type ConditionalOrderRegistry = Record<string, FromParams<unknown, unknown>>\n\nexport class ConditionalOrderFactory {\n  public knownOrderTypes\n\n  constructor(registry: ConditionalOrderRegistry) {\n    this.knownOrderTypes = registry\n  }\n\n  public fromParams(params: ConditionalOrderParams): ConditionalOrder<unknown, unknown> | undefined {\n    const { handler } = params\n\n    const factory = this.knownOrderTypes[handler]\n    if (!factory) {\n      return undefined\n    }\n\n    return factory(params)\n  }\n}\n","import { BigNumber, constants, utils } from 'ethers'\n\nimport { ConditionalOrder } from '../ConditionalOrder'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  OwnerContext,\n  IsValidResult,\n  PollParams,\n  PollResultCode,\n  PollResultErrors,\n} from '../types'\nimport { encodeParams, formatEpoch, getBlockInfo, isValidAbi } from '../utils'\nimport { GPv2Order } from '../generated/ComposableCoW'\n\n// The type of Conditional Order\nconst TWAP_ORDER_TYPE = 'twap'\n// The address of the TWAP handler contract\nexport const TWAP_ADDRESS = '0x6cF1e9cA41f7611dEf408122793c358a3d11E5a5'\n/**\n * The address of the `CurrentBlockTimestampFactory` contract\n *\n * **NOTE**: This is used in the event that TWAP's have a `t0` of `0`.\n */\nexport const CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS = '0x52eD56Da04309Aca4c3FECC595298d80C2f16BAc'\n\nexport const MAX_UINT32 = BigNumber.from(2).pow(32).sub(1) // 2^32 - 1\nexport const MAX_FREQUENCY = BigNumber.from(365 * 24 * 60 * 60) // 1 year\n\n// Define the ABI tuple for the TWAPData struct\nconst TWAP_STRUCT_ABI = [\n  'tuple(address sellToken, address buyToken, address receiver, uint256 partSellAmount, uint256 minPartLimit, uint256 t0, uint256 n, uint256 t, uint256 span, bytes32 appData)',\n]\n\n/**\n * Base parameters for a TWAP order. Shared by:\n *   - TwapStruct (modelling the contract's struct used for `staticInput`).\n *   - TwapData (modelling the friendly SDK interface).\n */\nexport type TwapDataBase = {\n  /**\n   * which token to sell\n   */\n  readonly sellToken: string\n\n  /**\n   * which token to buy\n   */\n  readonly buyToken: string\n\n  /**\n   * who to send the tokens to\n   */\n  readonly receiver: string\n\n  /**\n   * Meta-data associated with the order. Normally would be the keccak256 hash of the document generated in http://github.com/cowprotocol/app-data\n   *\n   * This hash should have been uploaded to the API https://api.cow.fi/docs/#/default/put_api_v1_app_data__app_data_hash_ and potentially to other data availability protocols like IPFS.\n   *\n   */\n  readonly appData: string\n}\n\n/**\n * Parameters for a TWAP order, as expected by the contract's `staticInput`.\n */\nexport interface TwapStruct extends TwapDataBase {\n  /**\n   * amount of sellToken to sell in each part\n   */\n  readonly partSellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought in each part\n   */\n  readonly minPartLimit: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly t0: BigNumber\n\n  /**\n   * number of parts\n   */\n  readonly n: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly t: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly span: BigNumber\n}\n\n/**\n * Parameters for a TWAP order, made a little more user-friendly for SDK users.\n *\n * @see {@link TwapStruct} for the native struct.\n */\nexport interface TwapData extends TwapDataBase {\n  /**\n   * total amount of sellToken to sell across the entire TWAP\n   */\n  readonly sellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought across the entire TWAP\n   */\n  readonly buyAmount: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly startTime?: StartTime\n\n  /**\n   * number of parts\n   */\n  readonly numberOfParts: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly timeBetweenParts: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly durationOfPart?: DurationOfPart\n}\n\nexport type DurationOfPart =\n  | { durationType: DurationType.AUTO }\n  | { durationType: DurationType.LIMIT_DURATION; duration: BigNumber }\n\nexport enum DurationType {\n  AUTO = 'AUTO',\n  LIMIT_DURATION = 'LIMIT_DURATION',\n}\n\nexport type StartTime =\n  | { startType: StartTimeValue.AT_MINING_TIME }\n  | { startType: StartTimeValue.AT_EPOCH; epoch: BigNumber }\n\nexport enum StartTimeValue {\n  AT_MINING_TIME = 'AT_MINING_TIME',\n  AT_EPOCH = 'AT_EPOCH',\n}\n\nconst DEFAULT_START_TIME: StartTime = { startType: StartTimeValue.AT_MINING_TIME }\nconst DEFAULT_DURATION_OF_PART: DurationOfPart = { durationType: DurationType.AUTO }\n\n/**\n * `ComposableCoW` implementation of a TWAP order.\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nexport class Twap extends ConditionalOrder<TwapData, TwapStruct> {\n  isSingleOrder = true\n\n  /**\n   * @see {@link ConditionalOrder.constructor}\n   * @throws If the TWAP order is invalid.\n   * @throws If the TWAP order is not ABI-encodable.\n   * @throws If the handler is not the TWAP address.\n   */\n  constructor(params: ConditionalOrderArguments<TwapData>) {\n    const { handler, salt, data: staticInput, hasOffChainInput } = params\n\n    // First, verify that the handler is the TWAP address\n    if (handler !== TWAP_ADDRESS) throw new Error(`InvalidHandler: Expected: ${TWAP_ADDRESS}, provided: ${handler}`)\n\n    // Third, construct the base class using transformed parameters\n    super({ handler: TWAP_ADDRESS, salt, data: staticInput, hasOffChainInput })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromData(data: TwapData, salt?: string): Twap {\n    return new Twap({ handler: TWAP_ADDRESS, data, salt })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromParams(params: ConditionalOrderParams): Twap {\n    return Twap.deserialize(encodeParams(params))\n  }\n\n  /**\n   * Enforces that TWAPs will commence at the beginning of a block by use of the\n   * `CurrentBlockTimestampFactory` contract to provide the current block timestamp\n   * as the start time of the TWAP.\n   */\n  get context(): ContextFactory | undefined {\n    if (this.staticInput.t0.gt(0)) {\n      return super.context\n    } else {\n      return {\n        address: CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS,\n        factoryArgs: undefined,\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc {@link ConditionalOrder.orderType}\n   */\n  get orderType(): string {\n    return TWAP_ORDER_TYPE\n  }\n\n  /**\n   * Validate the TWAP order.\n   * @param data The TWAP order to validate.\n   * @returns Whether the TWAP order is valid.\n   * @throws If the TWAP order is invalid.\n   * @see {@link TwapStruct} for the native struct.\n   */\n  isValid(): IsValidResult {\n    const error = (() => {\n      const {\n        sellToken,\n        sellAmount,\n        buyToken,\n        buyAmount,\n        startTime = DEFAULT_START_TIME,\n        numberOfParts,\n        timeBetweenParts,\n        durationOfPart = DEFAULT_DURATION_OF_PART,\n      } = this.data\n\n      // Verify that the order params are logically valid\n      if (!(sellToken != buyToken)) return 'InvalidSameToken'\n      if (!(sellToken != constants.AddressZero && buyToken != constants.AddressZero)) return 'InvalidToken'\n      if (!sellAmount.gt(constants.Zero)) return 'InvalidSellAmount'\n      if (!buyAmount.gt(constants.Zero)) return 'InvalidMinBuyAmount'\n      if (startTime.startType === StartTimeValue.AT_EPOCH) {\n        const t0 = startTime.epoch\n        if (!(t0.gte(constants.Zero) && t0.lt(MAX_UINT32))) return 'InvalidStartTime'\n      }\n      if (!(numberOfParts.gt(constants.One) && numberOfParts.lte(MAX_UINT32))) return 'InvalidNumParts'\n      if (!(timeBetweenParts.gt(constants.Zero) && timeBetweenParts.lte(MAX_FREQUENCY))) return 'InvalidFrequency'\n      if (durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n        if (!durationOfPart.duration.lte(timeBetweenParts)) return 'InvalidSpan'\n      }\n\n      // Verify that the staticInput derived from the data is ABI-encodable\n      if (!isValidAbi(TWAP_STRUCT_ABI, [this.staticInput])) return 'InvalidData'\n\n      // No errors\n      return undefined\n    })()\n\n    return error ? { isValid: false, reason: error } : { isValid: true }\n  }\n\n  protected async startTimestamp(params: OwnerContext): Promise<number> {\n    const { startTime } = this.data\n\n    if (startTime?.startType === StartTimeValue.AT_EPOCH) {\n      return startTime.epoch.toNumber()\n    }\n\n    const cabinet = await this.cabinet(params)\n    const rawCabinetEpoch = utils.defaultAbiCoder.decode(['uint256'], cabinet)[0] as BigNumber\n\n    // Guard against out-of-range cabinet epoch\n    if (rawCabinetEpoch.gt(MAX_UINT32)) {\n      throw new Error(`Cabinet epoch out of range: ${rawCabinetEpoch.toString()}`)\n    }\n\n    // Convert the cabinet epoch (bignumber) to a number.\n    const cabinetEpoch = rawCabinetEpoch.toNumber()\n\n    if (cabinetEpoch === 0) {\n      throw new Error('Cabinet is not set. Required for TWAP orders that start at mining time.')\n    }\n\n    return cabinetEpoch\n  }\n\n  /**\n   * Given the start timestamp of the TWAP, calculate the end timestamp.\n   * @dev As usually the `endTimestamp` is used when determining a TWAP's validity, we don't\n   *      do any lookup to the blockchain to determine the start timestamp, as this has likely\n   *      already been done during the verification flow.\n   * @dev Beware to handle the case of `span != 0` ie. `durationOfPart.durationType !== DurationType.AUTO`.\n   * @param startTimestamp The start timestamp of the TWAP.\n   * @returns The timestamp at which the TWAP will end.\n   */\n  protected endTimestamp(startTimestamp: number): number {\n    const { numberOfParts, timeBetweenParts, durationOfPart } = this.data\n\n    if (durationOfPart && durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n      return startTimestamp + numberOfParts.sub(1).mul(timeBetweenParts).add(durationOfPart.duration).toNumber()\n    }\n\n    return startTimestamp + numberOfParts.mul(timeBetweenParts).toNumber()\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param owner The owner of the conditional order.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  protected async pollValidate(params: PollParams): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    try {\n      const startTimestamp = await this.startTimestamp(params)\n\n      if (startTimestamp > blockTimestamp) {\n        // The start time hasn't started\n        return {\n          result: PollResultCode.TRY_AT_EPOCH,\n          epoch: startTimestamp,\n          reason: `TWAP hasn't started yet. Starts at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        }\n      }\n\n      const expirationTimestamp = this.endTimestamp(startTimestamp)\n      if (blockTimestamp >= expirationTimestamp) {\n        // The order has expired\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `TWAP has expired. Expired at ${expirationTimestamp} (${formatEpoch(expirationTimestamp)})`,\n        }\n      }\n\n      return undefined\n    } catch (err: any) {\n      if (err?.message?.includes('Cabinet is not set')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}. User likely removed the order.`,\n        }\n      } else if (err?.message?.includes('Cabinet epoch out of range')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set correctly\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}`,\n        }\n      }\n\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `Unexpected error: ${err.message}`,\n        error: err,\n      }\n    }\n  }\n\n  /**\n   * Handles the error when the order is already present in the orderbook.\n   *\n   * Given the current part is in the book, it will signal to Watch Tower what to do:\n   *   - Wait until the next part starts\n   *   - Don't try again if current part is the last one\n   *\n   * NOTE: The error messages will refer to the parts 1-indexed, so first part is 1, second part is 2, etc.\n   */\n  protected async handlePollFailedAlreadyPresent(\n    _orderUid: string,\n    _order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    const timeBetweenParts = this.data.timeBetweenParts.toNumber()\n    const { numberOfParts } = this.data\n    const startTimestamp = await this.startTimestamp(params)\n\n    if (blockTimestamp < startTimestamp) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP part hash't started. First TWAP part start at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        error: undefined,\n      }\n    }\n    const expireTime = numberOfParts.mul(timeBetweenParts).add(startTimestamp).toNumber()\n    if (blockTimestamp >= expireTime) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP is expired. Expired at ${expireTime} (${formatEpoch(expireTime)})`,\n        error: undefined,\n      }\n    }\n\n    // Get current part number\n    const currentPartNumber = Math.floor((blockTimestamp - startTimestamp) / timeBetweenParts)\n\n    // If current part is the last one\n    if (currentPartNumber === numberOfParts.toNumber() - 1) {\n      return {\n        result: PollResultCode.DONT_TRY_AGAIN,\n        reason: `Current active TWAP part (${\n          currentPartNumber + 1\n        }/${numberOfParts}) is already in the Order Book. This was the last TWAP part, no more orders need to be placed`,\n      }\n    }\n\n    // Next part start time\n    const nextPartStartTime = startTimestamp + (currentPartNumber + 1) * timeBetweenParts\n\n    /**\n     * Given we know, that TWAP part that is due in the current block is already in the Orderbook,\n     * Then, we can safely instruct that we should wait until the next TWAP part starts\n     */\n    return {\n      result: PollResultCode.TRY_AT_EPOCH,\n      epoch: nextPartStartTime,\n      reason: `Current active TWAP part (${\n        currentPartNumber + 1\n      }/${numberOfParts}) is already in the Order Book. TWAP part ${\n        currentPartNumber + 2\n      } doesn't start until ${nextPartStartTime} (${formatEpoch(nextPartStartTime)})`,\n    }\n  }\n\n  /**\n   * Serialize the TWAP order into it's ABI-encoded form.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  serialize(): string {\n    return encodeParams(this.leaf)\n  }\n\n  /**\n   * Get the encoded static input for the TWAP order.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  encodeStaticInput(): string {\n    return super.encodeStaticInputHelper(TWAP_STRUCT_ABI, this.staticInput)\n  }\n\n  /**\n   * Deserialize a TWAP order from it's ABI-encoded form.\n   * @param {string} twapSerialized ABI-encoded TWAP order to deserialize.\n   * @returns A deserialized TWAP order.\n   */\n  static deserialize(twapSerialized: string): Twap {\n    return super.deserializeHelper(\n      twapSerialized,\n      TWAP_ADDRESS,\n      TWAP_STRUCT_ABI,\n      (struct: TwapStruct, salt: string) =>\n        new Twap({\n          handler: TWAP_ADDRESS,\n          salt,\n          data: transformStructToData(struct),\n        })\n    )\n  }\n\n  /**\n   * Create a human-readable string representation of the TWAP order.\n   * @returns {string} A human-readable string representation of the TWAP order.\n   */\n  toString(): string {\n    const {\n      sellAmount,\n      sellToken,\n      buyAmount,\n      buyToken,\n      numberOfParts,\n      startTime = DEFAULT_START_TIME,\n      timeBetweenParts,\n      durationOfPart = DEFAULT_DURATION_OF_PART,\n      receiver,\n      appData,\n    } = this.data\n\n    const startTimeFormatted =\n      startTime.startType === StartTimeValue.AT_MINING_TIME ? 'AT_MINING_TIME' : startTime.epoch.toNumber()\n    const durationOfPartFormatted =\n      durationOfPart.durationType === DurationType.AUTO ? 'AUTO' : durationOfPart.duration.toNumber()\n\n    const details = {\n      sellAmount: sellAmount.toString(),\n      sellToken,\n      buyAmount: buyAmount.toString(),\n      buyToken,\n      numberOfParts: numberOfParts.toString(),\n      startTime: startTimeFormatted,\n      timeBetweenParts: timeBetweenParts.toNumber(),\n      durationOfPart: durationOfPartFormatted,\n      receiver,\n      appData,\n    }\n\n    return `${this.orderType} (${this.id}): ${JSON.stringify(details)}`\n  }\n\n  /**\n   * Transform parameters into a native struct.\n   *\n   * @param {TwapData} data As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformDataToStruct(data: TwapData): TwapStruct {\n    return transformDataToStruct(data)\n  }\n\n  /**\n   * Transform parameters into a TWAP order struct.\n   *\n   * @param {TwapData} params As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformStructToData(struct: TwapStruct): TwapData {\n    return transformStructToData(struct)\n  }\n}\n\n/**\n * Transform parameters into a native struct.\n *\n * @param {TwapData} data As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformDataToStruct(data: TwapData): TwapStruct {\n  const {\n    sellAmount,\n    buyAmount,\n    numberOfParts,\n    startTime: startTime = DEFAULT_START_TIME,\n    timeBetweenParts,\n    durationOfPart = DEFAULT_DURATION_OF_PART,\n    ...rest\n  } = data\n\n  const { partSellAmount, minPartLimit } =\n    numberOfParts && !numberOfParts.isZero()\n      ? {\n          partSellAmount: sellAmount.div(numberOfParts),\n          minPartLimit: buyAmount.div(numberOfParts),\n        }\n      : {\n          partSellAmount: constants.Zero,\n          minPartLimit: constants.Zero,\n        }\n\n  const span = durationOfPart.durationType === DurationType.AUTO ? constants.Zero : durationOfPart.duration\n  const t0 = startTime.startType === StartTimeValue.AT_MINING_TIME ? constants.Zero : startTime.epoch\n\n  return {\n    partSellAmount,\n    minPartLimit,\n    t0,\n    n: numberOfParts,\n    t: timeBetweenParts,\n    span,\n    ...rest,\n  }\n}\n\n/**\n * Transform parameters into a TWAP order struct.\n *\n * @param {TwapData} params As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformStructToData(struct: TwapStruct): TwapData {\n  const { n: numberOfParts, partSellAmount, minPartLimit, t: timeBetweenParts, t0: startEpoch, span, ...rest } = struct\n\n  const durationOfPart: DurationOfPart = span.isZero()\n    ? { durationType: DurationType.AUTO }\n    : { durationType: DurationType.LIMIT_DURATION, duration: span }\n\n  const startTime: StartTime = span.isZero()\n    ? { startType: StartTimeValue.AT_MINING_TIME }\n    : { startType: StartTimeValue.AT_EPOCH, epoch: startEpoch }\n\n  return {\n    sellAmount: partSellAmount.mul(numberOfParts),\n    buyAmount: minPartLimit.mul(numberOfParts),\n    startTime,\n    numberOfParts,\n    timeBetweenParts,\n    durationOfPart,\n    ...rest,\n  }\n}\n","import { ConditionalOrderRegistry } from '../ConditionalOrderFactory'\nimport { TWAP_ADDRESS, Twap } from './Twap'\nexport * from './Twap'\n\nexport const DEFAULT_CONDITIONAL_ORDER_REGISTRY: ConditionalOrderRegistry = {\n  // Registry of all known order types\n  [TWAP_ADDRESS]: (params) => Twap.fromParams(params),\n}\n"],"names":["SupportedChainId","ENVS_LIST","DEFAULT_COW_API_CONTEXT","env","chainId","MAINNET","CowError","Error","constructor","message","error_code","super","this","logPrefix","DEFAULT_IPFS_READ_URI","DEFAULT_IPFS_WRITE_URI","GPv2Settlement","JSON","parse","BUY_ETH_ADDRESS","EXTENSIBLE_FALLBACK_HANDLER","COMPOSABLE_COW","ALL_SUPPORTED_CHAIN_IDS","GOERLI","GNOSIS_CHAIN","MUMBAI","COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS","reduce","acc","address","EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS","COMPOSABLE_COW_CONTRACT_ADDRESS","transformOrder","order","ethflowData","userValidTo","validTo","owner","onchainUser","sellToken","transformEthFlowOrder","dto","executedFeeAmount","executedSurplusFee","totalFee","addTotalFeeToOrder","request","baseUrl","path","query","method","body","rateLimiter","backoffOpts","headers","Accept","url","init","stringify","Promise","resolve","backOff","removeTokens","then","fetch","response","getResponseBody","responseBody","status","reject","OrderBookApiError","e","statusText","STATUS_CODES_TO_RETRY","DEFAULT_BACKOFF_OPTIONS","numOfAttempts","maxDelay","Infinity","jitter","retry","error","includes","DEFAULT_LIMITER_OPTIONS","tokensPerInterval","interval","_exit","_temp","_catch","contentType","get","toLowerCase","startsWith","json","_await$response$json","text","_await$response$text","console","_result3","undefined","ORDER_BOOK_PROD_CONFIG","ORDER_BOOK_STAGING_CONFIG","cleanObjectFromUndefinedValues","obj","Object","keys","key","val","OrderBookApi","context","RateLimiter","limiterOpts","getVersion","contextOverride","getTrades","orderUid","URLSearchParams","getOrders","offset","limit","toString","orders","map","getTxOrders","txHash","getOrder","getOrderMultiEnv","getContextWithOverride","otherEnvs","filter","i","attemptsCount","fallback","nextEnv","catch","getQuote","requestBody","sendSignedOrderCancellations","sendOrder","getNativePrice","tokenAddress","getTotalSurplus","getAppData","appDataHash","uploadAppData","fullAppData","getSolverCompetition","auctionIdorTx","getOrderLink","getApiBaseUrls","baseUrls","params","BuyTokenDestination","EcdsaSigningScheme","OnchainOrderData","OrderCancellationError","OrderClass","OrderKind","OrderPostError","OrderQuoteSideKindBuy","OrderQuoteSideKindSell","OrderStatus","PriceEstimationError","PriceQuality","ReplaceOrderError","SellTokenSource","SigningScheme","placementError","errorType","TOTALS_QUERY","gql","LAST_DAYS_VOLUME_QUERY","LAST_HOURS_VOLUME_QUERY","SUBGRAPH_BASE_URL","SUBGRAPH_PROD_CONFIG","SUBGRAPH_STAGING_CONFIG","SubgraphApi","API_NAME","getTotals","runQuery","totals","getLastDaysVolume","days","getLastHoursVolume","hours","variables","_this4","getEnvConfigs","getSignUtils","import","OrderSigningUtils","signer","signOrder","static","signOrderCancellation","orderUids","signOrderCancellations","getDomain","_TypedDataEncoder","hashDomain","Order","name","type","ProofLocation","PollResultCode","_abi","inputs","internalType","stateMutability","anonymous","indexed","components","outputs","ComposableCoW__factory","utils","Interface","signerOrProvider","Contract","abi","ExtensibleFallbackHandler__factory","global","self","window","getGlobal","module","exports","default","bind","Headers","Request","Response","OrderBalance","ORDER_TYPE_FIELDS","CANCELLATIONS_TYPE_FIELDS","ORDER_TYPE_HASH","ethers","id","join","timestamp","t","getTime","hashify","h","padStart","hexZeroPad","normalizeBuyTokenBalance","balance","ERC20","EXTERNAL","INTERNAL","normalizeOrder","_a","_b","receiver","constants","AddressZero","assign","sellTokenBalance","appData","buyTokenBalance","hashTypedData","domain","types","data","hash","hashOrder","hashOrderCancellation","hashOrderCancellations","OrderCancellations","ORDER_UID_LENGTH","computeOrderUid","packOrderUidParams","orderDigest","solidityPack","extractOrderUidParams","bytes","arrayify","length","view","DataView","buffer","hexlify","subarray","getAddress","getUint32","normalizeInteraction","interaction","value","callData","normalizeInteractions","interactions","isTypedDataSigner","isJsonRpcProvider","provider","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","result","done","apply","EIP1271_MAGICVALUE","hexDataSlice","PRE_SIGNED","InteractionStage","ecdsaSignTypedData","scheme","signature","EIP712","_signTypedData","ETHSIGN","signMessage","joinSignature","splitSignature","encodeEip1271SignatureData","verifier","decodeEip1271SignatureData","arrayifiedSignature","slice","FLAG_MASKS","kind","options","SELL","BUY","partiallyFillable","signingScheme","EIP1271","PRESIGN","encodeFlag","flag","index","findIndex","search","decodeFlag","numberFlags","BigNumber","from","toNumber","Math","clz32","mask","decoded","encodeSigningScheme","decodeSigningScheme","flags","encodeOrderFlags","decodeOrderFlags","encodeTradeFlags","decodeTradeFlags","encodeSignatureData","sig","decodeSignatureOwner","verifyTypedData","verifyMessage","encodeTrade","tokens","executedAmount","tradeFlags","o","sellTokenIndex","buyTokenIndex","buyToken","sellAmount","buyAmount","feeAmount","TokenRegistry","_tokens","_tokenMap","addresses","token","tokenIndex","push","SettlementEncoder","_trades","_interactions","PRE","INTRA","POST","_orderRefunds","filledAmounts","preSignatures","trades","encodedOrderRefunds","settlement","verifyingContract","iface","functionName","target","encodeFunctionData","clearingPrices","prices","price","signEncodeTrade","tradeExecution","encodeInteraction","stage","encodeOrderRefunds","orderRefunds","every","isHexString","encodedSettlement","encoder","decodeOrder","trade","max","Environment","LIMIT_CONCURRENT_REQUESTS","apiUrl","environment","network","Dev","Prod","QuotePriceQuality","GetQuoteErrorType","apiKind","apiSigningScheme","call","route","ok","apiError","quote","sellAmountBeforeFee","sellAmountAfterFee","buyAmountAfterFee","Api","baseUrlOrEnv","apiCallParams","estimateTradeAmount","amount","side","priceQuality","FAST","placeOrder","normalizedOrder","getExecutedSellAmount","uid","executedSellAmount","SALT","formatBytes32String","DEPLOYER_CONTRACT","CONTRACT_NAMES","authenticator","tradeSimulator","deterministicDeploymentAddress","bytecode","deploymentArguments","contractInterface","deployData","hexConcat","encodeDeploy","getCreate2Address","keccak256","slot","defaultAbiCoder","encode","sub","IMPLEMENTATION_STORAGE_SLOT","OWNER_STORAGE_SLOT","implementationAddress","proxy","implementation","decode","getStorageAt","ownerAddress","EIP173_PROXY_ABI","proxyInterface","contract","VAULT_INTERFACE","grantRequiredRoles","authorizer","vaultAddress","vaultRelayerAddress","functions","grantRole","solidityKeccak256","getSighash","getBlockInfo","getBlock","block","blockNumber","number","blockTimestamp","getDomainVerifier","safe","connect","callStatic","domainVerifiers","ERC20_BALANCE_VALUES","EXTERNAL_BALANCE_VALUES","INTERNAL_BALANCE_VALUES","SELL_KIND_VALUES","BUY_KIND_VALUES","CONDITIONAL_ORDER_PARAMS_ABI","DEFAULT_TOKEN_FORMATTER","isExtensibleFallbackHandler","handler","isComposableCow","createSetDomainVerifierTx","createInterface","encodeParams","decodeParams","encoded","salt","staticInput","isValidAbi","values","formatEpoch","epoch","Date","toISOString","balanceToString","kindToString","fromStructToOrder","Number","composableCowInterfaceCache","composableCowContractCache","getComposableCowInterface","getComposableCow","chain","orderBookCache","ConditionalOrder","hasOffChainInput","randomBytes","isAddress","hexDataLength","transformDataToStruct","assertIsValid","isValidResult","isValid","reason","createCalldata","composableCow","paramsStruct","encodeStaticInput","contextArgsAbi","factoryArgs","argsType","args","removeCalldata","serialize","ctx","isSingleOrder","HashZero","leaf","offChainInput","encodeStaticInputHelper","orderDataTypes","poll","_this","orderbookApiConfig","pollValidate","pollResult","isAuthorized","getTradeableOrderWithSignature","orderBookApi","_computeOrderUid","isOrderInOrderbook","_temp2","_result","SUCCESS","handlePollFailedAlreadyPresent","TRY_NEXT_BLOCK","DONT_TRY_AGAIN","UNEXPECTED_ERROR","singleOrders","cabinet","s","callback","recoveredHandler","d","CONDITIONAL_ORDER_LEAF_ABI","PAYLOAD_EMITTED_ABI","Multiplexer","root","location","PRIVATE","tree","orderKey","hasOwnProperty","orderTypeRegistry","orderType","getOrGenerateTree","reviver","k","v","orderData","OrderConstructor","m","toJSON","conditionalOrder","add","reset","remove","update","updater","getById","getByIndex","orderIds","StandardMerkleTree","of","prepareProofStruct","uploader","EMITTED","encodeToABI","SWARM","WAKU","IPFS","encodeToJSON","p","offChainInputFn","proof","dumpProofs","dumpProofsAndParams","getProofs","entries","idx","x","getProof","conditionalOrderClass","ConditionalOrderFactory","registry","knownOrderTypes","fromParams","factory","TWAP_ADDRESS","CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS","MAX_UINT32","pow","MAX_FREQUENCY","TWAP_STRUCT_ABI","DurationType","StartTimeValue","DEFAULT_START_TIME","startType","AT_MINING_TIME","DEFAULT_DURATION_OF_PART","durationType","AUTO","Twap","deserialize","t0","gt","startTime","numberOfParts","timeBetweenParts","durationOfPart","Zero","AT_EPOCH","gte","lt","One","lte","LIMIT_DURATION","duration","startTimestamp","rawCabinetEpoch","cabinetEpoch","endTimestamp","mul","_this2","_getBlockInfo","blockInfo","TRY_AT_EPOCH","expirationTimestamp","err","_orderUid","_order","_this3","_getBlockInfo2","expireTime","currentPartNumber","floor","nextPartStartTime","twapSerialized","deserializeHelper","struct","transformStructToData","startTimeFormatted","durationOfPartFormatted","details","rest","partSellAmount","minPartLimit","isZero","div","n","span","startEpoch","DEFAULT_CONDITIONAL_ORDER_REGISTRY"],"mappings":"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,CACEL,aAAc,UACdN,KAAM,GACNC,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEC,aAAc,UACdN,KAAM,QACNC,KAAM,WAER,CACES,WAAY,CACV,CACEJ,aAAc,6BACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,cACNC,KAAM,UAGVK,aAAc,kDACdN,KAAM,SACNC,KAAM,SAER,CACEK,aAAc,QACdN,KAAM,gBACNC,KAAM,SAER,CACEK,aAAc,YACdN,KAAM,QACNC,KAAM,cAGVD,KAAM,iCACNW,QAAS,CACP,CACED,WAAY,CACV,CACEJ,aAAc,kBACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,kBACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,aACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,SACdN,KAAM,UACNC,KAAM,UAER,CACEK,aAAc,UACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,OACdN,KAAM,oBACNC,KAAM,QAER,CACEK,aAAc,UACdN,KAAM,mBACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,kBACNC,KAAM,YAGVK,aAAc,wBACdN,KAAM,QACNC,KAAM,SAER,CACEK,aAAc,QACdN,KAAM,YACNC,KAAM,UAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEK,WAAY,CACV,CACEJ,aAAc,6BACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,cACNC,KAAM,UAGVK,aAAc,kDACdN,KAAM,SACNC,KAAM,UAGVD,KAAM,OACNW,QAAS,CACP,CACEL,aAAc,UACdN,KAAM,GACNC,KAAM,YAGVM,g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"}