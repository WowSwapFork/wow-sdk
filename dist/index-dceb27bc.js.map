{"version":3,"file":"index-dceb27bc.js","sources":["../src/common/chains.ts","../src/common/configs.ts","../src/common/cow-error.ts","../src/common/ipfs.ts","../src/common/consts.ts","../src/order-book/transformOrder.ts","../src/order-book/request.ts","../src/order-book/api.ts","../src/order-book/generated/models/BuyTokenDestination.ts","../src/order-book/generated/models/EcdsaSigningScheme.ts","../src/order-book/generated/models/OnchainOrderData.ts","../src/order-book/generated/models/OrderCancellationError.ts","../src/order-book/generated/models/OrderClass.ts","../src/order-book/generated/models/OrderKind.ts","../src/order-book/generated/models/OrderPostError.ts","../src/order-book/generated/models/OrderQuoteSideKindBuy.ts","../src/order-book/generated/models/OrderQuoteSideKindSell.ts","../src/order-book/generated/models/OrderStatus.ts","../src/order-book/generated/models/PriceEstimationError.ts","../src/order-book/generated/models/PriceQuality.ts","../src/order-book/generated/models/ReplaceOrderError.ts","../src/order-book/generated/models/SellTokenSource.ts","../src/order-book/generated/models/SigningScheme.ts","../src/subgraph/queries.ts","../src/subgraph/api.ts","../src/order-signing/orderSigningUtils.ts","../src/composable/types.ts","../src/composable/generated/factories/ComposableCoW__factory.ts","../src/composable/generated/factories/ExtensibleFallbackHandler__factory.ts","../node_modules/node-fetch/browser.js","../node_modules/@wowswapfork/contracts/lib/esm/order.js","../node_modules/@wowswapfork/contracts/lib/esm/interaction.js","../node_modules/@wowswapfork/contracts/lib/esm/types/ethers.js","../node_modules/@wowswapfork/contracts/lib/esm/sign.js","../node_modules/@wowswapfork/contracts/lib/esm/settlement.js","../node_modules/@wowswapfork/contracts/lib/esm/api.js","../node_modules/@wowswapfork/contracts/lib/esm/deploy.js","../node_modules/@wowswapfork/contracts/lib/esm/proxy.js","../node_modules/@wowswapfork/contracts/lib/esm/vault.js","../src/composable/utils.ts","../src/composable/contracts.ts","../src/composable/ConditionalOrder.ts","../src/utils.ts","../src/composable/Multiplexer.ts","../src/composable/ConditionalOrderFactory.ts","../src/composable/orderTypes/Twap.ts","../src/composable/orderTypes/index.ts"],"sourcesContent":["/**\n * Supported chains and their `chainId` for the SDK.\n * @enum\n */\nexport enum SupportedChainId {\n  MAINNET = 1,\n  GOERLI = 5,\n  GNOSIS_CHAIN = 100,\n  MUMBAI=80001\n}\n","import { SupportedChainId } from './chains'\nimport { BackoffOptions } from 'exponential-backoff'\nimport { RateLimiterOpts } from 'limiter/dist/esm'\n\n/**\n * IPFS configuration.\n *\n * For production use, consider using {@link Pinata: https://www.pinata.cloud/}\n * @property {string} [uri] The URI of the IPFS node to use.\n * @property {string} [writeUri] The URI of the IPFS node to use for writing.\n * @property {string} [readUri] The URI of the IPFS node to use for reading.\n * @property {string} [pinataApiKey] The API key to use for Pinata.\n * @property {string} [pinataApiSecret] The API secret to use for Pinata.\n */\nexport interface IpfsConfig {\n  uri?: string\n  writeUri?: string\n  readUri?: string\n  pinataApiKey?: string\n  pinataApiSecret?: string\n}\n\n/**\n * @property {RateLimiterOpts} [limiterOpts] The options to use for the rate limiter.\n * @property {BackoffOptions} [backoffOpts] The options to use for the backoff.\n */\nexport interface RequestOptions {\n  limiterOpts?: RateLimiterOpts\n  backoffOpts?: BackoffOptions\n}\n\n/**\n * The environment to use for the Cow API.\n */\nexport type CowEnv = 'prod' | 'staging'\n\n/**\n * Override some properties of the {@link ApiContext}.\n */\nexport type PartialApiContext = Partial<ApiContext>\n\n/**\n * @property {string} [1] The base URL for the mainnet API.\n * @property {string} [5] The base URL for the Goerli testnet API.\n * @property {string} [100] The base URL for the Gnosis Chain API.\n */\nexport type ApiBaseUrls = Record<SupportedChainId, string>\n\n/**\n * Define the context to use for the CoW Protocol API.\n *\n * CoW Protocol is a set of smart contracts and off-chain services, deployed on **multiple chains**.\n * {@link SupportedChainId Supported chains} are:\n * - Mainnet\n * - Goerli\n * - Gnosis Chain\n *\n * Each chain has it's own API, and each API has it's own base URL.\n *\n * Options may be selectively overridden by passing a {@link PartialApiContext} to the constructor.\n * @see {@link https://api.cow.fi/docs/#/}\n * @property {SupportedChainId} chainId The `chainId`` corresponding to this CoW Protocol API instance.\n * @property {CowEnv} env The environment that this context corresponds to.\n * @property {ApiBaseUrls} [baseUrls] URls that may be used to connect to this context.\n */\nexport interface ApiContext {\n  chainId: SupportedChainId\n  env: CowEnv\n  baseUrls?: ApiBaseUrls\n}\n\n/**\n * The list of available environments.\n */\nexport const ENVS_LIST: CowEnv[] = ['prod', 'staging']\n\n/**\n * The default CoW Protocol API context.\n */\nexport const DEFAULT_COW_API_CONTEXT: ApiContext = {\n  env: 'prod',\n  chainId: SupportedChainId.MAINNET,\n}\n","export class CowError extends Error {\n  error_code?: string\n\n  constructor(message: string, error_code?: string) {\n    super(message)\n    this.error_code = error_code\n  }\n}\n\nexport const logPrefix = 'cow-sdk:'\n","export const DEFAULT_IPFS_READ_URI = 'https://gnosis.mypinata.cloud/ipfs'\nexport const DEFAULT_IPFS_WRITE_URI = 'https://api.pinata.cloud'\n","import { SupportedChainId } from './chains'\nimport contractNetworks from '@wowswapfork/contracts/networks.json'\nconst { GPv2Settlement } = JSON.parse(contractNetworks as unknown as string) as typeof contractNetworks\n\nexport const BUY_ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'\nexport const EXTENSIBLE_FALLBACK_HANDLER = '0x2f55e8b20D0B9FEFA187AA7d00B6Cbe563605bF5'\nexport const COMPOSABLE_COW = '0x5d84eB96e4D57fB2a7945f32be7401237eD243ad'\n\n/**\n * The list of supported chains.\n */\nexport const ALL_SUPPORTED_CHAIN_IDS: SupportedChainId[] = [\n  SupportedChainId.MAINNET,\n  SupportedChainId.GOERLI,\n  SupportedChainId.GNOSIS_CHAIN,\n  SupportedChainId.MUMBAI,\n\n]\n\n/**\n * An object containing the addresses of the CoW Protocol settlement contracts for each supported chain.\n */\nexport const COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: GPv2Settlement[chainId].address,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ExtensibleFallbackHandler` contracts for each supported chain.\n */\nexport const EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: EXTENSIBLE_FALLBACK_HANDLER,\n  }),\n  {}\n)\n\n/**\n * An object containing the addresses of the `ComposableCow` contracts for each supported chain.\n */\nexport const COMPOSABLE_COW_CONTRACT_ADDRESS = ALL_SUPPORTED_CHAIN_IDS.reduce<Record<number, string>>(\n  (acc, chainId) => ({\n    ...acc,\n    [chainId]: COMPOSABLE_COW,\n  }),\n  {}\n)\n","import { BUY_ETH_ADDRESS } from '../common/consts'\nimport { Order } from './generated'\nimport { EnrichedOrder } from './types'\n\n/**\n * Apply programmatic transformations to an order.\n *\n * For example, transformations may be applied to an order to recognise it as a Native EthFlow order.\n * @param order to apply transformations to\n * @returns An order with the total fee added.\n */\nexport function transformOrder(order: Order): EnrichedOrder {\n  return transformEthFlowOrder(addTotalFeeToOrder(order))\n}\n\n/**\n * Add the total fee to the order.\n *\n * The `executedSurplusFee` represents exactly the fee that was charged (regardless of the fee\n * signed with the order). So, while the protocol currently does not allow placing a limit order\n * with any other fee than 0 - the backend is designed to support these kinds of orders for the\n * future.\n * @param dto The order to add the total fee to.\n * @returns The order with the total fee added.\n */\nfunction addTotalFeeToOrder(dto: Order): EnrichedOrder {\n  const { executedFeeAmount, executedSurplusFee } = dto\n  const totalFee = executedSurplusFee ?? executedFeeAmount\n\n  return {\n    ...dto,\n    totalFee,\n  }\n}\n\n/**\n * Transform order field for Native EthFlow orders\n *\n * A no-op for regular orders\n * For Native EthFlow, due to how the contract is setup:\n * - sellToken set to Native token address\n * - owner set to `onchainUser`\n * - validTo set to `ethflowData.userValidTo`\n */\nfunction transformEthFlowOrder(order: EnrichedOrder): EnrichedOrder {\n  const { ethflowData } = order\n\n  if (!ethflowData) {\n    return order\n  }\n\n  const { userValidTo: validTo } = ethflowData\n  const owner = order.onchainUser || order.owner\n  const sellToken = BUY_ETH_ADDRESS\n\n  return { ...order, validTo, owner, sellToken }\n}\n","import { backOff, BackoffOptions } from 'exponential-backoff'\nimport { RateLimiter, RateLimiterOpts } from 'limiter'\n\n/**\n * Error thrown when the CoW Protocol OrderBook API returns an error.\n */\nexport class OrderBookApiError<T = unknown> extends Error {\n  /**\n   * Error thrown when the CoW Protocol OrderBook API returns an error.\n   * @param response The response from the CoW Protocol OrderBook API.\n   * @param body The body of the response.\n   * @constructor\n   */\n  constructor(public readonly response: Response, public readonly body: T) {\n    super(typeof body === 'string' ? body : response.statusText)\n  }\n}\n\nconst REQUEST_TIMEOUT = 408\nconst TOO_EARLY = 425\nconst TOO_MANY_REQUESTS = 429\nconst INTERNAL_SERVER_ERROR = 500\nconst BAD_GATEWAY = 502\nconst SERVICE_UNAVAILABLE = 503\nconst GATEWAY_TIMEOUT = 504\n\nconst STATUS_CODES_TO_RETRY = [\n  REQUEST_TIMEOUT,\n  TOO_EARLY,\n  TOO_MANY_REQUESTS,\n  INTERNAL_SERVER_ERROR,\n  BAD_GATEWAY,\n  SERVICE_UNAVAILABLE,\n  GATEWAY_TIMEOUT,\n]\n\n/**\n * The default backoff options for CoW Protocol's API\n * @see {@link Backoff configuration: https://www.npmjs.com/package/@insertish/exponential-backoff}\n */\nexport const DEFAULT_BACKOFF_OPTIONS: BackoffOptions = {\n  numOfAttempts: 10,\n  maxDelay: Infinity,\n  jitter: 'none',\n  retry: (error: Error | OrderBookApiError) => {\n    if (error instanceof OrderBookApiError) {\n      return STATUS_CODES_TO_RETRY.includes(error.response.status)\n    }\n\n    return true\n  },\n}\n\n/**\n * The default rate limiter options for CoW Protocol's API.\n *\n * **CAUTION**: The CoW Protocol OrderBook API is limited to 5 requests per second per IP.\n */\nexport const DEFAULT_LIMITER_OPTIONS: RateLimiterOpts = {\n  tokensPerInterval: 5,\n  interval: 'second',\n}\n\n/**\n * Describe the parameters for a fetch request.\n */\nexport interface FetchParams {\n  path: string\n  method: 'GET' | 'POST' | 'DELETE' | 'PUT'\n  body?: unknown\n  query?: URLSearchParams\n}\n\nconst getResponseBody = async (response: Response): Promise<unknown> => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get('Content-Type')\n      if (contentType) {\n        if (contentType.toLowerCase().startsWith('application/json')) {\n          return await response.json()\n        } else {\n          return await response.text()\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  return undefined\n}\n\n/**\n * Helper function to make a rate-limited request to an API.\n * @param baseUrl The base URL of the API.\n * @param path The path of the request.\n * @param query The query parameters of the request.\n * @param method The HTTP method of the request.\n * @param body The body of the request.\n * @param rateLimiter The rate limiter to use.\n * @param backoffOpts The backoff options to use.\n * @returns The response of the request.\n * @throws If the API returns an error or if the request fails.\n */\nexport async function request<T>(\n  baseUrl: string,\n  { path, query, method, body }: FetchParams,\n  rateLimiter: RateLimiter,\n  backoffOpts: BackoffOptions\n): Promise<T> {\n  const queryString = query ? '?' + query : ''\n  const headers = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  }\n\n  const url = `${baseUrl}${path}${queryString}`\n  const bodyContent = (() => {\n    if (!body) return undefined\n\n    return typeof body === 'string' ? body : JSON.stringify(body)\n  })()\n  const init: RequestInit = {\n    method,\n    body: bodyContent,\n    headers,\n  }\n\n  return backOff<T>(async () => {\n    await rateLimiter.removeTokens(1)\n\n    const response = await fetch(url, init)\n    const responseBody = (await getResponseBody(response)) as T\n\n    // Successful response\n    if (response.status >= 200 && response.status < 300) {\n      return responseBody\n    }\n\n    return Promise.reject(new OrderBookApiError(response, responseBody))\n  }, backoffOpts)\n}\n","import 'cross-fetch/polyfill'\nimport {\n  Address,\n  AppDataHash,\n  AppDataObject,\n  NativePriceResponse,\n  Order,\n  OrderCancellations,\n  OrderCreation,\n  OrderQuoteRequest,\n  OrderQuoteResponse,\n  SolverCompetitionResponse,\n  TotalSurplus,\n  Trade,\n  TransactionHash,\n  UID,\n} from './generated'\nimport { CowError } from '../common/cow-error'\nimport {\n  ApiBaseUrls,\n  ApiContext,\n  CowEnv,\n  DEFAULT_COW_API_CONTEXT,\n  ENVS_LIST,\n  PartialApiContext,\n  RequestOptions,\n} from '../common/configs'\nimport { transformOrder } from './transformOrder'\nimport { EnrichedOrder } from './types'\nimport { SupportedChainId } from '../common/chains'\nimport { RateLimiter } from 'limiter'\nimport { DEFAULT_BACKOFF_OPTIONS, DEFAULT_LIMITER_OPTIONS, FetchParams, OrderBookApiError, request } from './request'\n\n/**\n * An object containing *production* environment base URLs for each supported `chainId`.\n * @see {@link https://api.cow.fi/docs/#/}\n */\nexport const ORDER_BOOK_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n}\n\n/**\n * An object containing *staging* environment base URLs for each supported `chainId`.\n */\nexport const ORDER_BOOK_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: 'https://barn.api.cow.fi/mainnet',\n  [SupportedChainId.GNOSIS_CHAIN]: 'https://barn.api.cow.fi/xdai',\n  [SupportedChainId.GOERLI]: 'https://barn.api.cow.fi/goerli',\n  [SupportedChainId.MUMBAI]:'http://localhost:8080'\n\n}\n\nfunction cleanObjectFromUndefinedValues(obj: Record<string, string>): typeof obj {\n  return Object.keys(obj).reduce((acc, key) => {\n    const val = obj[key]\n    if (typeof val !== 'undefined') acc[key] = val\n    return acc\n  }, {} as typeof obj)\n}\n\n/**\n * The parameters for the `getOrders` request.\n */\nexport type GetOrdersRequest = {\n  owner: Address\n  offset?: number\n  limit?: number\n}\n\n/**\n * The CoW Protocol OrderBook API client.\n *\n * This is the main entry point for interacting with the CoW Protocol OrderBook API. The main advantage of using\n * this client is the batteries-included approach to interacting with the API. It handles:\n *\n * - Environment configuration (mainnet, staging, etc.)\n * - Rate limiting\n * - Retries\n * - Backoff\n * - Error handling\n * - Request signing\n * - Request validation\n *\n * @example\n *\n * ```typescript\n * import { OrderBookApi, OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * const quoteRequest = {\n *   sellToken: '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6', // WETH goerli\n *   buyToken: '0x02abbdbaaa7b1bb64b5c878f7ac17f8dda169532', // GNO goerli\n *   from: account,\n *   receiver: account,\n *   sellAmountBeforeFee: (0.4 * 10 ** 18).toString(), // 0.4 WETH\n *   kind: OrderQuoteSide.kind.SELL,\n * }\n *\n * const orderBookApi = new OrderBookApi({ chainId: SupportedChainId.GOERLI })\n *\n * async function main() {\n *     const { quote } = await orderBookApi.getQuote(quoteRequest)\n *\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n *\n * @see {@link Swagger documentation https://api.cow.fi/docs/#/}\n * @see {@link OrderBook API https://github.com/cowprotocol/services}\n */\nexport class OrderBookApi {\n  public context: ApiContext & RequestOptions\n\n  private rateLimiter: RateLimiter\n\n  /**\n   * Creates a new instance of the CoW Protocol OrderBook API client.\n   * @param context - The API context to use. If not provided, the default context will be used.\n   */\n  constructor(context: PartialApiContext & RequestOptions = {}) {\n    this.context = { ...DEFAULT_COW_API_CONTEXT, ...context }\n    this.rateLimiter = new RateLimiter(context.limiterOpts || DEFAULT_LIMITER_OPTIONS)\n  }\n\n  /**\n   * Get the version of the API.\n   * @param contextOverride Optional context override for this request.\n   * @returns The version of the API.\n   * @see {@link https://api.cow.fi/docs/#/default/get_api_v1_version}\n   */\n  getVersion(contextOverride: PartialApiContext = {}): Promise<string> {\n    return this.fetch({ path: '/api/v1/version', method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Get all the trades for either an `owner` **OR** `orderUid`.\n   *\n   * Given that an order *may* be partially fillable, it is possible that a discrete order (`orderUid`)\n   * may have *multiple* trades. Therefore, this method returns a list of trades, either for *all* the orders\n   * of a given `owner`, or for a discrete order (`orderUid`).\n   * @param request Either an `owner` or an `orderUid` **MUST** be specified.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of trades matching the request.\n   */\n  getTrades(\n    request: { owner?: Address; orderUid?: UID },\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<Trade>> {\n    if (request.owner && request.orderUid) {\n      return Promise.reject(new CowError('Cannot specify both owner and orderId'))\n    } else if (!request.owner && !request.orderUid) {\n      return Promise.reject(new CowError('Must specify either owner or orderId'))\n    }\n\n    const query = new URLSearchParams(cleanObjectFromUndefinedValues(request))\n\n    return this.fetch({ path: '/api/v1/trades', method: 'GET', query }, contextOverride)\n  }\n\n  /**\n   * Get a list of orders for a given `owner`.\n   * @param request The request parameters with `request.offset = 0` and `request.limit = 1000` by default.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link GetOrdersRequest}\n   * @see {@link EnrichedOrder}\n   */\n  getOrders(\n    { owner, offset = 0, limit = 1000 }: GetOrdersRequest,\n    contextOverride: PartialApiContext = {}\n  ): Promise<Array<EnrichedOrder>> {\n    const query = new URLSearchParams(\n      cleanObjectFromUndefinedValues({ offset: offset.toString(), limit: limit.toString() })\n    )\n\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/account/${owner}/orders`, method: 'GET', query },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get a list of orders from a given settlement transaction hash.\n   * @param txHash The transaction hash.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of orders matching the request.\n   * @see {@link EnrichedOrder}\n   */\n  getTxOrders(txHash: TransactionHash, contextOverride: PartialApiContext = {}): Promise<Array<EnrichedOrder>> {\n    return this.fetch<Array<EnrichedOrder>>(\n      { path: `/api/v1/transactions/${txHash}/orders`, method: 'GET' },\n      contextOverride\n    ).then((orders) => {\n      return orders.map(transformOrder)\n    })\n  }\n\n  /**\n   * Get an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   */\n  getOrder(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    return this.fetch<Order>({ path: `/api/v1/orders/${orderUid}`, method: 'GET' }, contextOverride).then((order) => {\n      return transformOrder(order)\n    })\n  }\n\n  /**\n   * Attempt to get an order by its unique identifier, `orderUid`, from multiple environments.\n   *\n   * **NOTE**: The environment refers to either `prod` or `staging`. This allows a conveience method to\n   * attempt to get an order from both environments, in the event that the order is not found in the\n   * environment specified in the context.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The order matching the request.\n   * @throws {OrderBookApiError} If the order is not found in any of the environments.\n   */\n  getOrderMultiEnv(orderUid: UID, contextOverride: PartialApiContext = {}): Promise<EnrichedOrder> {\n    const { env } = this.getContextWithOverride(contextOverride)\n    const otherEnvs = ENVS_LIST.filter((i) => i !== env)\n\n    let attemptsCount = 0\n\n    const fallback = (error: Error | OrderBookApiError): Promise<EnrichedOrder> => {\n      const nextEnv = otherEnvs[attemptsCount]\n\n      if (error instanceof OrderBookApiError && error.response.status === 404 && nextEnv) {\n        attemptsCount++\n\n        return this.getOrder(orderUid, { ...contextOverride, env: nextEnv }).catch(fallback)\n      }\n\n      return Promise.reject(error)\n    }\n\n    return this.getOrder(orderUid, { ...contextOverride, env }).catch(fallback)\n  }\n\n  /**\n   * Get a quote for an order.\n   * This allows for the calculation of the total cost of an order, including fees, before signing and submitting.\n   * @param requestBody The parameters for the order quote request.\n   * @param contextOverride Optional context override for this request.\n   * @returns A hydrated order matching the request ready to be signed.\n   */\n  getQuote(requestBody: OrderQuoteRequest, contextOverride: PartialApiContext = {}): Promise<OrderQuoteResponse> {\n    return this.fetch({ path: '/api/v1/quote', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Cancel one or more orders.\n   *\n   * **NOTE**: Cancellation is on a best-effort basis. Orders that are already in the process of being settled\n   * (ie. transaction has been submitted to chain by the solver) cannot not be cancelled.\n   * **CAUTION**: This method can only be used to cancel orders that were signed using `EIP-712` or `eth_sign (EIP-191)`.\n   * @param requestBody Orders to be cancelled and signed instructions to cancel them.\n   * @param contextOverride Optional context override for this request.\n   * @returns A list of order unique identifiers that were successfully cancelled.\n   */\n  sendSignedOrderCancellations(\n    requestBody: OrderCancellations,\n    contextOverride: PartialApiContext = {}\n  ): Promise<void> {\n    return this.fetch({ path: '/api/v1/orders', method: 'DELETE', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Submit an order to the order book.\n   * @param requestBody The signed order to be submitted.\n   * @param contextOverride Optional context override for this request.\n   * @returns The unique identifier of the order.\n   */\n  sendOrder(requestBody: OrderCreation, contextOverride: PartialApiContext = {}): Promise<UID> {\n    return this.fetch({ path: '/api/v1/orders', method: 'POST', body: requestBody }, contextOverride)\n  }\n\n  /**\n   * Get the native price of a token.\n   *\n   * **NOTE**: The native price is the price of the token in the native currency of the chain. For example, on Ethereum\n   * this would be the price of the token in ETH.\n   * @param tokenAddress The address of the ERC-20 token.\n   * @param contextOverride Optional context override for this request.\n   * @returns The native price of the token.\n   */\n  getNativePrice(tokenAddress: Address, contextOverride: PartialApiContext = {}): Promise<NativePriceResponse> {\n    return this.fetch({ path: `/api/v1/token/${tokenAddress}/native_price`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Given a user's address, get the total surplus that they have earned.\n   * @param address The user's address\n   * @param contextOverride Optional context override for this request.\n   * @returns Calculated user's surplus\n   */\n  getTotalSurplus(address: Address, contextOverride: PartialApiContext = {}): Promise<TotalSurplus> {\n    return this.fetch({ path: `/api/v1/users/${address}/total_surplus`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Retrieve the full app data for a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param contextOverride Optional context override for this request.\n   * @returns Full app data that was uploaded\n   */\n  getAppData(appDataHash: AppDataHash, contextOverride: PartialApiContext = {}): Promise<AppDataObject> {\n    return this.fetch({ path: `/api/v1/app_data/${appDataHash}`, method: 'GET' }, contextOverride)\n  }\n\n  /**\n   * Upload the full app data that corresponds to a given app data hash.\n   * @param appDataHash `bytes32` hash of the app data\n   * @param fullAppData Full app data to be uploaded\n   * @param contextOverride Optional context override for this request.\n   * @returns The string encoding of the full app data that was uploaded.\n   */\n  uploadAppData(\n    appDataHash: AppDataHash,\n    fullAppData: string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<AppDataObject> {\n    return this.fetch(\n      { path: `/api/v1/app_data/${appDataHash}`, method: 'PUT', body: { fullAppData } },\n      contextOverride\n    )\n  }\n\n  getSolverCompetition(auctionId: number, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  getSolverCompetition(txHash: string, contextOverride?: PartialApiContext): Promise<SolverCompetitionResponse>\n\n  /**\n   * Given an auction id or tx hash, get the details of the solver competition for that auction.\n   * @param auctionIdorTx auction id or tx hash corresponding to the auction\n   * @param contextOverride Optional context override for this request.\n   * @returns An object containing the solver competition details\n   */\n  getSolverCompetition(\n    auctionIdorTx: number | string,\n    contextOverride: PartialApiContext = {}\n  ): Promise<SolverCompetitionResponse> {\n    return this.fetch(\n      {\n        path: `/api/v1/solver_competition${typeof auctionIdorTx === 'string' ? '/by_tx_hash' : ''}/${auctionIdorTx}`,\n        method: 'GET',\n      },\n      contextOverride\n    )\n  }\n\n  /**\n   * Generate an API endpoint for an order by its unique identifier, `orderUid`.\n   * @param orderUid The unique identifier of the order.\n   * @param contextOverride Optional context override for this request.\n   * @returns The API endpoint to get the order.\n   */\n  getOrderLink(orderUid: UID, contextOverride?: PartialApiContext): string {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    return this.getApiBaseUrls(env)[chainId] + `/api/v1/orders/${orderUid}`\n  }\n\n  /**\n   * Apply an override to the context for a request.\n   * @param contextOverride Optional context override for this request.\n   * @returns New context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext & RequestOptions {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the API endpoints given the environment.\n   * @param env The environment to get the base URLs for.\n   * @returns The base URLs for the API endpoints.\n   */\n  private getApiBaseUrls(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? ORDER_BOOK_PROD_CONFIG : ORDER_BOOK_STAGING_CONFIG\n  }\n\n  /**\n   * Make a request to the API.\n   * @param params The parameters for the request.\n   * @param contextOverride Optional context override for this request.\n   * @returns The response from the API.\n   */\n  private fetch<T>(params: FetchParams, contextOverride: PartialApiContext = {}): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getApiBaseUrls(env)[chainId]\n    const backoffOpts = this.context.backoffOpts || DEFAULT_BACKOFF_OPTIONS\n\n    return request(baseUrl, params, this.rateLimiter, backoffOpts)\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `buyToken` be transferred to?\n */\nexport enum BuyTokenDestination {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum EcdsaSigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nimport type { Address } from './Address';\n\nexport type OnchainOrderData = {\n    /**\n     * If orders are placed as on-chain orders, the owner of the order might\n     * be a smart contract, but not the user placing the order. The\n     * actual user will be provided in this field.\n     *\n     */\n    sender: Address;\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    placementError?: OnchainOrderData.placementError;\n};\n\nexport namespace OnchainOrderData {\n\n    /**\n     * Describes the error, if the order placement was not successful. This could\n     * happen, for example, if the `validTo` is too high, or no valid quote was\n     * found or generated.\n     *\n     */\n    export enum placementError {\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        VALID_TO_TOO_FAR_IN_FUTURE = 'ValidToTooFarInFuture',\n        PRE_VALIDATION_ERROR = 'PreValidationError',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderCancellationError = {\n    errorType: OrderCancellationError.errorType;\n    description: string;\n};\n\nexport namespace OrderCancellationError {\n\n    export enum errorType {\n        INVALID_SIGNATURE = 'InvalidSignature',\n        WRONG_OWNER = 'WrongOwner',\n        ORDER_NOT_FOUND = 'OrderNotFound',\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Order class.\n */\nexport enum OrderClass {\n    MARKET = 'market',\n    LIMIT = 'limit',\n    LIQUIDITY = 'liquidity',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Is this order a buy or sell?\n */\nexport enum OrderKind {\n    BUY = 'buy',\n    SELL = 'sell',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type OrderPostError = {\n    errorType: OrderPostError.errorType;\n    description: string;\n};\n\nexport namespace OrderPostError {\n\n    export enum errorType {\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        QUOTE_NOT_FOUND = 'QuoteNotFound',\n        INVALID_QUOTE = 'InvalidQuote',\n        MISSING_FROM = 'MissingFrom',\n        WRONG_OWNER = 'WrongOwner',\n        INVALID_EIP1271SIGNATURE = 'InvalidEip1271Signature',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        SELL_AMOUNT_OVERFLOW = 'SellAmountOverflow',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        ZERO_AMOUNT = 'ZeroAmount',\n        INCOMPATIBLE_SIGNING_SCHEME = 'IncompatibleSigningScheme',\n        TOO_MANY_LIMIT_ORDERS_UNSUPPORTED_BUY_TOKEN_DESTINATION = 'TooManyLimitOrders UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        INVALID_NATIVE_SELL_TOKEN_SAME_BUY_AND_SELL_TOKEN = 'InvalidNativeSellToken SameBuyAndSellToken',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        UNSUPPORTED_CUSTOM_INTERACTION_INVALID_APP_DATA = 'UnsupportedCustomInteraction InvalidAppData',\n        APP_DATA_HASH_MISMATCH = 'AppDataHashMismatch',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindBuy {\n    BUY = 'buy',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport enum OrderQuoteSideKindSell {\n    SELL = 'sell',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * The current order status.\n */\nexport enum OrderStatus {\n    PRESIGNATURE_PENDING = 'presignaturePending',\n    OPEN = 'open',\n    FULFILLED = 'fulfilled',\n    CANCELLED = 'cancelled',\n    EXPIRED = 'expired',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type PriceEstimationError = {\n    errorType: PriceEstimationError.errorType;\n    description: string;\n};\n\nexport namespace PriceEstimationError {\n\n    export enum errorType {\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How good should the price estimate be?\n *\n * Fast: The price estimate is chosen among the fastest N price estimates.\n * Optimal: The price estimate is chosen among all price estimates.\n * Verified: The price estimate is chosen among all verified/simulated price estimates.\n *\n * **NOTE**: Orders are supposed to be created from `verified` price estimates.\n *\n */\nexport enum PriceQuality {\n    FAST = 'fast',\n    OPTIMAL = 'optimal',\n    VERIFIED = 'verified',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nexport type ReplaceOrderError = {\n    errorType: ReplaceOrderError.errorType;\n    description: string;\n};\n\nexport namespace ReplaceOrderError {\n\n    export enum errorType {\n        ALREADY_CANCELLED = 'AlreadyCancelled',\n        ORDER_FULLY_EXECUTED = 'OrderFullyExecuted',\n        ORDER_EXPIRED = 'OrderExpired',\n        ON_CHAIN_ORDER = 'OnChainOrder',\n        DUPLICATED_ORDER = 'DuplicatedOrder',\n        INSUFFICIENT_FEE = 'InsufficientFee',\n        INSUFFICIENT_ALLOWANCE = 'InsufficientAllowance',\n        INSUFFICIENT_BALANCE = 'InsufficientBalance',\n        INSUFFICIENT_VALID_TO = 'InsufficientValidTo',\n        EXCESSIVE_VALID_TO = 'ExcessiveValidTo',\n        INVALID_SIGNATURE = 'InvalidSignature',\n        TRANSFER_ETH_TO_CONTRACT = 'TransferEthToContract',\n        TRANSFER_SIMULATION_FAILED = 'TransferSimulationFailed',\n        UNSUPPORTED_TOKEN = 'UnsupportedToken',\n        WRONG_OWNER = 'WrongOwner',\n        SAME_BUY_AND_SELL_TOKEN = 'SameBuyAndSellToken',\n        ZERO_AMOUNT = 'ZeroAmount',\n        UNSUPPORTED_BUY_TOKEN_DESTINATION = 'UnsupportedBuyTokenDestination',\n        UNSUPPORTED_SELL_TOKEN_SOURCE = 'UnsupportedSellTokenSource',\n        UNSUPPORTED_ORDER_TYPE = 'UnsupportedOrderType',\n        UNSUPPORTED_SIGNATURE = 'UnsupportedSignature',\n    }\n\n\n}\n\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * Where should the `sellToken` be drawn from?\n */\nexport enum SellTokenSource {\n    ERC20 = 'erc20',\n    INTERNAL = 'internal',\n    EXTERNAL = 'external',\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n/**\n * How was the order signed?\n */\nexport enum SigningScheme {\n    EIP712 = 'eip712',\n    ETHSIGN = 'ethsign',\n    PRESIGN = 'presign',\n    EIP1271 = 'eip1271',\n}\n","import { gql } from 'graphql-request'\n\n/**\n * GraphQL query for the total number of tokens, orders, traders, settlements, volume, and fees.\n */\nexport const TOTALS_QUERY = gql`\n  query Totals {\n    totals {\n      tokens\n      orders\n      traders\n      settlements\n      volumeUsd\n      volumeEth\n      feesUsd\n      feesEth\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N days.\n * @param days The number of days to query.\n */\nexport const LAST_DAYS_VOLUME_QUERY = gql`\n  query LastDaysVolume($days: Int!) {\n    dailyTotals(orderBy: timestamp, orderDirection: desc, first: $days) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n\n/**\n * GraphQL query for the total volume over the last N hours.\n * @param hours The number of hours to query.\n */\nexport const LAST_HOURS_VOLUME_QUERY = gql`\n  query LastHoursVolume($hours: Int!) {\n    hourlyTotals(orderBy: timestamp, orderDirection: desc, first: $hours) {\n      timestamp\n      volumeUsd\n    }\n  }\n`\n","import { CowError } from '../common/cow-error'\nimport { LastDaysVolumeQuery, LastHoursVolumeQuery, TotalsQuery } from './graphql'\nimport { LAST_DAYS_VOLUME_QUERY, LAST_HOURS_VOLUME_QUERY, TOTALS_QUERY } from './queries'\nimport { DocumentNode } from 'graphql/index'\nimport { request, Variables } from 'graphql-request'\nimport { ApiContext, CowEnv, DEFAULT_COW_API_CONTEXT, ApiBaseUrls, PartialApiContext } from '../common/configs'\nimport { SupportedChainId } from '../common/chains'\n\nconst SUBGRAPH_BASE_URL = 'https://api.thegraph.com/subgraphs/name/cowprotocol'\n\n/**\n * CoW Protocol Production Subgraph API configuration.\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-goerli}\n */\nexport const SUBGRAPH_PROD_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc',\n  [SupportedChainId.GOERLI]: SUBGRAPH_BASE_URL + '/cow-goerli',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * CoW Protocol Staging Subgraph API configuration.\n * @deprecated\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-staging}\n * @see {@link https://api.thegraph.com/subgraphs/name/cowprotocol/cow-gc-staging}\n */\nexport const SUBGRAPH_STAGING_CONFIG: ApiBaseUrls = {\n  [SupportedChainId.MAINNET]: SUBGRAPH_BASE_URL + '/cow-staging',\n  [SupportedChainId.GNOSIS_CHAIN]: SUBGRAPH_BASE_URL + '/cow-gc-staging',\n  [SupportedChainId.GOERLI]: '',\n  [SupportedChainId.MUMBAI]: 'https://thegraph.com/hosted-service/subgraph/shahzeb8285/wowswapfork',\n\n}\n\n/**\n * TheGraph API client for CoW Protocol.\n */\nexport class SubgraphApi {\n  API_NAME = 'CoW Protocol Subgraph'\n\n  public context: ApiContext\n\n  /**\n   * Create a new CoW Protocol API instance.\n   * @param context Any properties of the {@link ApiContext} may be overridden by passing a {@link PartialApiContext}.\n   */\n  constructor(context: PartialApiContext = {}) {\n    this.context = {\n      ...DEFAULT_COW_API_CONTEXT,\n      ...context,\n    }\n  }\n\n  /**\n   * Query the totals from TheGraph for the CoW Protocol.\n   * @param contextOverride Override the context for this call only.\n   * @returns The totals for the CoW Protocol.\n   */\n  async getTotals(contextOverride: PartialApiContext = {}): Promise<TotalsQuery['totals'][0]> {\n    const response = await this.runQuery<TotalsQuery>(TOTALS_QUERY, undefined, contextOverride)\n    return response.totals[0]\n  }\n\n  /**\n   * Query the volume over the last N days from TheGraph for the CoW Protocol.\n   * @param {number} days The number of days to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N days.\n   */\n  async getLastDaysVolume(days: number, contextOverride: PartialApiContext = {}): Promise<LastDaysVolumeQuery> {\n    return this.runQuery<LastDaysVolumeQuery>(LAST_DAYS_VOLUME_QUERY, { days }, contextOverride)\n  }\n\n  /**\n   * Query the volume over the last N hours from TheGraph for the CoW Protocol.\n   * @param {number} hours The number of hours to query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns The volume for the last N hours.\n   */\n  async getLastHoursVolume(hours: number, contextOverride: PartialApiContext = {}): Promise<LastHoursVolumeQuery> {\n    return this.runQuery<LastHoursVolumeQuery>(LAST_HOURS_VOLUME_QUERY, { hours }, contextOverride)\n  }\n\n  /**\n   * Run a query against the CoW Protocol Subgraph.\n   * @param {string | DocumentNode} query GQL query string or DocumentNode.\n   * @param {Variables | undefined} variables To be passed to the query.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns Results of the query.\n   * @throws {@link CowError} if the query fails.\n   */\n  async runQuery<T>(\n    query: string | DocumentNode,\n    variables: Variables | undefined = undefined,\n    contextOverride: PartialApiContext = {}\n  ): Promise<T> {\n    const { chainId, env } = this.getContextWithOverride(contextOverride)\n    const baseUrl = this.getEnvConfigs(env)[chainId]\n\n    try {\n      return await request(baseUrl, query, variables)\n    } catch (error) {\n      console.error(`[subgraph:${this.API_NAME}]`, error)\n      throw new CowError(\n        `Error running query: ${query}. Variables: ${JSON.stringify(variables)}. API: ${baseUrl}. Inner Error: ${error}`\n      )\n    }\n  }\n\n  /**\n   * Override parts of the context for a specific call.\n   * @param {PartialApiContext} contextOverride Override the context for this call only.\n   * @returns {ApiContext} The context with the override applied.\n   */\n  private getContextWithOverride(contextOverride: PartialApiContext = {}): ApiContext {\n    return { ...this.context, ...contextOverride }\n  }\n\n  /**\n   * Get the base URLs for the given environment.\n   * @param {CowEnv} env The environment to get the base URLs for.\n   * @returns {ApiBaseUrls} The base URLs for the given environment.\n   */\n  private getEnvConfigs(env: CowEnv): ApiBaseUrls {\n    if (this.context.baseUrls) return this.context.baseUrls\n\n    return env === 'prod' ? SUBGRAPH_PROD_CONFIG : SUBGRAPH_STAGING_CONFIG\n  }\n}\n","import type { SupportedChainId } from '../common'\nimport type { Signer } from '@ethersproject/abstract-signer'\nimport type { TypedDataDomain } from '@cowprotocol/contracts'\nimport type { SigningResult, UnsignedOrder } from './types'\n\nconst getSignUtils = () => import('./utils')\nconst ethersUtils = () => import('ethers/lib/utils')\n\n/**\n * Utility class for signing order intents and cancellations.\n *\n * @remarks This class only supports `eth_sign` and wallet-native EIP-712 signing. For use of\n *          `presign` and `eip1271` {@link https://docs.cow.fi/ | see the docs}.\n * @example\n *\n * ```typescript\n * import { OrderSigningUtils, SupportedChainId } from '@cowprotocol/cow-sdk'\n * import { Web3Provider } from '@ethersproject/providers'\n *\n * const account = 'YOUR_WALLET_ADDRESS'\n * const chainId = 5 // Goerli\n * const provider = new Web3Provider(window.ethereum)\n * const signer = provider.getSigner()\n *\n * async function main() {\n *     const { order: Order } = { ... }\n *     const orderSigningResult = await OrderSigningUtils.signOrder(quote, chainId, signer)\n *\n *     const orderId = await orderBookApi.sendOrder({ ...quote, ...orderSigningResult })\n *\n *     const order = await orderBookApi.getOrder(orderId)\n *\n *     const trades = await orderBookApi.getTrades({ orderId })\n *\n *     const orderCancellationSigningResult = await OrderSigningUtils.signOrderCancellations([orderId], chainId, signer)\n *\n *     const cancellationResult = await orderBookApi.sendSignedOrderCancellations({...orderCancellationSigningResult, orderUids: [orderId] })\n *\n *     console.log('Results: ', { orderId, order, trades, orderCancellationSigningResult, cancellationResult })\n * }\n * ```\n */\nexport class OrderSigningUtils {\n  /**\n   * Sign the order intent with the specified signer.\n   *\n   * @remarks If the API reports an error with the signature, it is likely to be due to an incorrectly\n   *          specified `chainId`. Please ensure that the `chainId` is correct for the network you are\n   *          using.\n   * @param {UnsignedOrder} order The unsigned order intent to be placed.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who is placing the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the order.\n   */\n  static async signOrder(order: UnsignedOrder, chainId: SupportedChainId, signer: Signer): Promise<SigningResult> {\n    const { signOrder } = await getSignUtils()\n    return signOrder(order, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of an order intent with the specified signer.\n   * @param {string} orderUid The unique identifier of the order to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol `chainid` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intent.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellation(\n    orderUid: string,\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellation } = await getSignUtils()\n    return signOrderCancellation(orderUid, chainId, signer)\n  }\n\n  /**\n   * Sign a cancellation message of multiple order intents with the specified signer.\n   * @param {string[]} orderUids An array of `orderUid` to cancel.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @param {Signer} signer The signer who initially placed the order intents.\n   * @returns {Promise<SigningResult>} Encoded signature including signing scheme for the cancellation.\n   */\n  static async signOrderCancellations(\n    orderUids: string[],\n    chainId: SupportedChainId,\n    signer: Signer\n  ): Promise<SigningResult> {\n    const { signOrderCancellations } = await getSignUtils()\n    return signOrderCancellations(orderUids, chainId, signer)\n  }\n\n  /**\n   * Get the EIP-712 typed domain data being used for signing.\n   * @param {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @return The EIP-712 typed domain data.\n   * @see https://eips.ethereum.org/EIPS/eip-712\n   */\n  static async getDomain(chainId: SupportedChainId): Promise<TypedDataDomain> {\n    const { getDomain } = await getSignUtils()\n    return getDomain(chainId)\n  }\n\n  /**\n   * Get the domain separator hash for the EIP-712 typed domain data being used for signing.\n   * @param chainId {SupportedChainId} chainId The CoW Protocol protocol `chainId` context that's being used.\n   * @returns A string representation of the EIP-712 typed domain data hash.\n   */\n  static async getDomainSeparator(chainId: SupportedChainId): Promise<string> {\n    const { getDomain } = await getSignUtils()\n    const { _TypedDataEncoder } = await ethersUtils()\n    return _TypedDataEncoder.hashDomain(getDomain(chainId))\n  }\n\n  /**\n   * Get the EIP-712 types used for signing a GPv2Order.Data struct. This is useful for when\n   * signing orders using smart contracts, whereby this SDK cannot do the EIP-1271 signing for you.\n   * @returns The EIP-712 types used for signing.\n   */\n  static getEIP712Types(): Record<string, any> {\n    return {\n      Order: [\n        { name: 'sellToken', type: 'address' },\n        { name: 'buyToken', type: 'address' },\n        { name: 'receiver', type: 'address' },\n        { name: 'sellAmount', type: 'uint256' },\n        { name: 'buyAmount', type: 'uint256' },\n        { name: 'validTo', type: 'uint32' },\n        { name: 'appData', type: 'bytes32' },\n        { name: 'feeAmount', type: 'uint256' },\n        { name: 'kind', type: 'string' },\n        { name: 'partiallyFillable', type: 'bool' },\n        { name: 'sellTokenBalance', type: 'string' },\n        { name: 'buyTokenBalance', type: 'string' },\n      ],\n    }\n  }\n}\n","import { OrderBookApi } from '../order-book'\nimport { SupportedChainId } from '../common'\nimport { GPv2Order } from './generated/ComposableCoW'\nimport { providers } from 'ethers'\n\nexport interface ConditionalOrderArguments<T> {\n  handler: string\n  data: T\n  salt?: string\n  hasOffChainInput?: boolean\n}\n\nexport type ConditionalOrderParams = {\n  readonly handler: string\n  readonly salt: string\n  readonly staticInput: string\n}\n\nexport enum ProofLocation {\n  // The location of the proofs is private to the caller.\n  PRIVATE = 0,\n  // The `data` field of the emitted `Proof` struct contains proofs + conditional order parameters.\n  EMITTED = 1,\n  // The `data` field of the emitted `Proof` struct contains the Swarm address (`bytes32`) of the proofs + conditional order parameters.\n  SWARM = 2,\n  // The `data` field is set to TBD.\n  WAKU = 3,\n  // The `data` field is set to TBD\n  RESERVED = 4,\n  // The `data` field of the emitted `Proof` struct contains the IPFS address (`bytes32`) of the proofs + conditional order parameters.\n  IPFS = 5,\n}\n\n/**\n * A factory and it's arguments that are called at transaction mining time to generate the context\n * for a conditional order(s).\n *\n * This allows to support the case where conditional orders may want to *commence* validity at the\n * time of transaction mining, like in the case of a `TWAP` executed by a DAO or `Safe` that takes\n * a reasonable amount of time to aggregate signatures or collect votes.\n *\n * @remarks This is used in conjunction with `setRootWithContext` or `createWithContext`.\n */\nexport type ContextFactory = {\n  // The address of the `IValueFactory` that will be used to resolve the context.\n  address: string\n  // Any arguments that will be passed to the `IValueFactory` to resolve the context.\n  factoryArgs?: {\n    args: unknown[]\n    argsType: string[]\n  }\n}\n\n/**\n * A struct for a proof that can be used with `setRoot` and `setRootWithContext` on a\n * ComposableCoW-enabled Safe.\n */\nexport type ProofStruct = {\n  // The location of the proof.\n  location: ProofLocation\n  // The data for the proof.\n  data: string | '0x'\n}\n\n/**\n * Payload for emitting a merkle root to a ComposableCoW-enabled Safe.\n *\n * If setting `ProofLocation.EMITTED`, this type should be used as the `data` in the `Proof` struct.\n */\nexport type PayloadLocationEmitted = {\n  // An array of conditional orders and their proofs.\n  proofs: ProofWithParams[]\n}\n\n/**\n * A proof for a conditional order and it's parameters.\n */\nexport type ProofWithParams = {\n  // The proof for the Merkle tree that contains the conditional order.\n  proof: string[]\n  // The parameters as expected by ABI encoding.\n  params: ConditionalOrderParams\n}\n\nexport type OwnerContext = {\n  owner: string\n  chainId: SupportedChainId\n  provider: providers.Provider\n}\n\nexport type PollParams = OwnerContext & {\n  offchainInput?: string\n  proof?: string[]\n\n  /**\n   * If present, it can be used for custom conditional order validations. If not present, the orders will need to get the block info themselves\n   */\n  blockInfo?: BlockInfo\n\n  /**\n   * Allows to optional pass the config of the orderbook API\n   */\n  orderbookApiConfig?: OrderBookApiConfig\n}\n\nexport type OrderBookApiConfig = Omit<ConstructorParameters<typeof OrderBookApi>[0], 'chainId'>\n\nexport type BlockInfo = {\n  blockNumber: number\n  blockTimestamp: number\n}\n\nexport type PollResult = PollResultSuccess | PollResultErrors\n\nexport type PollResultErrors =\n  | PollResultTryNextBlock\n  | PollResultTryOnBlock\n  | PollResultTryAtEpoch\n  | PollResultUnexpectedError\n  | PollResultDontTryAgain\n\nexport enum PollResultCode {\n  SUCCESS = 'SUCCESS',\n  UNEXPECTED_ERROR = 'UNEXPECTED_ERROR',\n  TRY_NEXT_BLOCK = 'TRY_NEXT_BLOCK',\n  TRY_ON_BLOCK = 'TRY_ON_BLOCK',\n  TRY_AT_EPOCH = 'TRY_AT_EPOCH',\n  DONT_TRY_AGAIN = 'DONT_TRY_AGAIN',\n}\nexport interface PollResultSuccess {\n  readonly result: PollResultCode.SUCCESS\n  readonly order: GPv2Order.DataStruct\n  readonly signature: string\n}\n\nexport interface PollResultUnexpectedError {\n  readonly result: PollResultCode.UNEXPECTED_ERROR\n  readonly error: unknown\n  reason?: string\n}\n\nexport interface PollResultTryNextBlock {\n  readonly result: PollResultCode.TRY_NEXT_BLOCK\n  reason?: string\n}\n\nexport interface PollResultTryOnBlock {\n  readonly result: PollResultCode.TRY_ON_BLOCK\n  readonly blockNumber: number\n  reason?: string\n}\n\nexport interface PollResultTryAtEpoch {\n  readonly result: PollResultCode.TRY_AT_EPOCH\n  /**\n   * The epoch after which it is ok to retry to to poll this order.\n   * The value is expressed as a Unix timestamp (in seconds).\n   *\n   * This epoch will be inclusive, meaning that it is ok to retry at the block mined precisely at this epoch or later.\n   */\n  readonly epoch: number\n  reason?: string\n}\n\nexport interface PollResultDontTryAgain {\n  readonly result: PollResultCode.DONT_TRY_AGAIN\n  reason?: string\n}\n\nexport type IsValidResult = IsValid | IsNotValid\nexport interface IsValid {\n  isValid: true\n}\nexport interface IsNotValid {\n  isValid: false\n  reason: string\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type { ComposableCoW, ComposableCoWInterface } from \"../ComposableCoW\";\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_settlement\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"InterfaceNotSupported\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidHandler\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ProofNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SingleOrderNotAuthed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SwapGuardRestricted\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"ConditionalOrderCreated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        indexed: false,\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"MerkleRootSet\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"SwapGuardSet\",\n    type: \"event\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"cabinet\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"create\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"dispatch\",\n        type: \"bool\",\n      },\n    ],\n    name: \"createWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"domainSeparator\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"offchainInput\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"proof\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"getTradeableOrderWithSignature\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IERC20\",\n            name: \"sellToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"contract IERC20\",\n            name: \"buyToken\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"receiver\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"sellAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"buyAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint32\",\n            name: \"validTo\",\n            type: \"uint32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"appData\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"feeAmount\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"kind\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bool\",\n            name: \"partiallyFillable\",\n            type: \"bool\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"sellTokenBalance\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"buyTokenBalance\",\n            type: \"bytes32\",\n          },\n        ],\n        internalType: \"struct GPv2Order.Data\",\n        name: \"order\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"contract IConditionalOrder\",\n            name: \"handler\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"salt\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"staticInput\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct IConditionalOrder.ConditionalOrderParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"hash\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"encodeData\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"payload\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSafeSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"singleOrderHash\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"remove\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"roots\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"setRoot\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"location\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct ComposableCoW.Proof\",\n        name: \"proof\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"contract IValueFactory\",\n        name: \"factory\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"setRootWithContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"swapGuard\",\n        type: \"address\",\n      },\n    ],\n    name: \"setSwapGuard\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"singleOrders\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"swapGuards\",\n    outputs: [\n      {\n        internalType: \"contract ISwapGuard\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ComposableCoW__factory {\n  static readonly abi = _abi;\n  static createInterface(): ComposableCoWInterface {\n    return new utils.Interface(_abi) as ComposableCoWInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ComposableCoW {\n    return new Contract(address, _abi, signerOrProvider) as ComposableCoW;\n  }\n}\n","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { Contract, Signer, utils } from \"ethers\";\nimport type { Provider } from \"@ethersproject/providers\";\nimport type {\n  ExtensibleFallbackHandler,\n  ExtensibleFallbackHandlerInterface,\n} from \"../ExtensibleFallbackHandler\";\n\nconst _abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"verifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"AddedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"method\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AddedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"oldVerifier\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"ChangedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"oldMethod\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"ChangedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"RemovedDomainVerifier\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedInterface\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"contract Safe\",\n        name: \"safe\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"RemovedSafeMethod\",\n    type: \"event\",\n  },\n  {\n    stateMutability: \"nonpayable\",\n    type: \"fallback\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"domainVerifiers\",\n    outputs: [\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"isValidSignature\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"magic\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155BatchReceived\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC1155Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"onERC721Received\",\n    outputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeInterfaces\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract Safe\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes4\",\n        name: \"\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"safeMethods\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"domainSeparator\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"contract ISafeSignatureVerifier\",\n        name: \"newVerifier\",\n        type: \"address\",\n      },\n    ],\n    name: \"setDomainVerifier\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"selector\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"newMethod\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"setSafeMethod\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bool\",\n        name: \"supported\",\n        type: \"bool\",\n      },\n    ],\n    name: \"setSupportedInterface\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"_interfaceId\",\n        type: \"bytes4\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"handlerWithSelectors\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"setSupportedInterfaceBatch\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"supportsInterface\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\nexport class ExtensibleFallbackHandler__factory {\n  static readonly abi = _abi;\n  static createInterface(): ExtensibleFallbackHandlerInterface {\n    return new utils.Interface(_abi) as ExtensibleFallbackHandlerInterface;\n  }\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ExtensibleFallbackHandler {\n    return new Contract(\n      address,\n      _abi,\n      signerOrProvider\n    ) as ExtensibleFallbackHandler;\n  }\n}\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;","import { ethers } from \"ethers\";\n/**\n * Marker address to indicate that an order is buying Ether.\n *\n * Note that this address is only has special meaning in the `buyToken` and will\n * be treated as a ERC20 token address in the `sellToken` position, causing the\n * settlement to revert.\n */\nexport const BUY_ETH_ADDRESS = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n/**\n * Order kind.\n */\nexport var OrderKind;\n(function (OrderKind) {\n    /**\n     * A sell order.\n     */\n    OrderKind[\"SELL\"] = \"sell\";\n    /**\n     * A buy order.\n     */\n    OrderKind[\"BUY\"] = \"buy\";\n})(OrderKind || (OrderKind = {}));\n/**\n * Order balance configuration.\n */\nexport var OrderBalance;\n(function (OrderBalance) {\n    /**\n     * Use ERC20 token balances.\n     */\n    OrderBalance[\"ERC20\"] = \"erc20\";\n    /**\n     * Use Balancer Vault external balances.\n     *\n     * This can only be specified specified for the sell balance and allows orders\n     * to re-use Vault ERC20 allowances. When specified for the buy balance, it\n     * will be treated as {@link OrderBalance.ERC20}.\n     */\n    OrderBalance[\"EXTERNAL\"] = \"external\";\n    /**\n     * Use Balancer Vault internal balances.\n     */\n    OrderBalance[\"INTERNAL\"] = \"internal\";\n})(OrderBalance || (OrderBalance = {}));\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_FIELDS = [\n    { name: \"sellToken\", type: \"address\" },\n    { name: \"buyToken\", type: \"address\" },\n    { name: \"receiver\", type: \"address\" },\n    { name: \"sellAmount\", type: \"uint256\" },\n    { name: \"buyAmount\", type: \"uint256\" },\n    { name: \"validTo\", type: \"uint32\" },\n    { name: \"appData\", type: \"bytes32\" },\n    { name: \"feeAmount\", type: \"uint256\" },\n    { name: \"kind\", type: \"string\" },\n    { name: \"partiallyFillable\", type: \"bool\" },\n    { name: \"sellTokenBalance\", type: \"string\" },\n    { name: \"buyTokenBalance\", type: \"string\" },\n];\n/**\n * The EIP-712 type fields definition for a Gnosis Protocol v2 order.\n */\nexport const CANCELLATIONS_TYPE_FIELDS = [\n    { name: \"orderUids\", type: \"bytes[]\" },\n];\n/**\n * The EIP-712 type hash for a Gnosis Protocol v2 order.\n */\nexport const ORDER_TYPE_HASH = ethers.utils.id(`Order(${ORDER_TYPE_FIELDS.map(({ name, type }) => `${type} ${name}`).join(\",\")})`);\n/**\n * Normalizes a timestamp value to a Unix timestamp.\n * @param time The timestamp value to normalize.\n * @return Unix timestamp or number of seconds since the Unix Epoch.\n */\nexport function timestamp(t) {\n    return typeof t === \"number\" ? t : ~~(t.getTime() / 1000);\n}\n/**\n * Normalizes an app data value to a 32-byte hash.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function hashify(h) {\n    return typeof h === \"number\"\n        ? `0x${h.toString(16).padStart(64, \"0\")}`\n        : ethers.utils.hexZeroPad(h, 32);\n}\n/**\n * Normalizes the balance configuration for a buy token. Specifically, this\n * function ensures that {@link OrderBalance.EXTERNAL} gets normalized to\n * {@link OrderBalance.ERC20}.\n *\n * @param balance The balance configuration.\n * @returns The normalized balance configuration.\n */\nexport function normalizeBuyTokenBalance(balance) {\n    switch (balance) {\n        case undefined:\n        case OrderBalance.ERC20:\n        case OrderBalance.EXTERNAL:\n            return OrderBalance.ERC20;\n        case OrderBalance.INTERNAL:\n            return OrderBalance.INTERNAL;\n        default:\n            throw new Error(`invalid order balance ${balance}`);\n    }\n}\n/**\n * Normalizes an order for hashing and signing, so that it can be used with\n * Ethers.js for EIP-712 operations.\n * @param hashLike A hash-like value to normalize.\n * @returns A 32-byte hash encoded as a hex-string.\n */\nexport function normalizeOrder(order) {\n    var _a, _b;\n    if (order.receiver === ethers.constants.AddressZero) {\n        throw new Error(\"receiver cannot be address(0)\");\n    }\n    const normalizedOrder = Object.assign(Object.assign({}, order), { sellTokenBalance: (_a = order.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20, receiver: (_b = order.receiver) !== null && _b !== void 0 ? _b : ethers.constants.AddressZero, validTo: timestamp(order.validTo), appData: hashify(order.appData), buyTokenBalance: normalizeBuyTokenBalance(order.buyTokenBalance) });\n    return normalizedOrder;\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param types The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashTypedData(domain, types, data) {\n    return ethers.utils._TypedDataEncoder.hash(domain, types, data);\n}\n/**\n * Compute the 32-byte signing hash for the specified order.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param order The order to compute the digest for.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrder(domain, order) {\n    return hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order));\n}\n/**\n * Compute the 32-byte signing hash for the specified cancellation.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUid The unique identifier of the order to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellation(domain, orderUid) {\n    return hashOrderCancellations(domain, [orderUid]);\n}\n/**\n * Compute the 32-byte signing hash for the specified order cancellations.\n *\n * @param domain The EIP-712 domain separator to compute the hash for.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @return Hex-encoded 32-byte order digest.\n */\nexport function hashOrderCancellations(domain, orderUids) {\n    return hashTypedData(domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids });\n}\n/**\n * The byte length of an order UID.\n */\nexport const ORDER_UID_LENGTH = 56;\n/**\n * Computes the order UID for an order and the given owner.\n */\nexport function computeOrderUid(domain, order, owner) {\n    return packOrderUidParams({\n        orderDigest: hashOrder(domain, order),\n        owner,\n        validTo: order.validTo,\n    });\n}\n/**\n * Compute the unique identifier describing a user order in the settlement\n * contract.\n *\n * @param OrderUidParams The parameters used for computing the order's unique\n * identifier.\n * @returns A string that unequivocally identifies the order of the user.\n */\nexport function packOrderUidParams({ orderDigest, owner, validTo, }) {\n    return ethers.utils.solidityPack([\"bytes32\", \"address\", \"uint32\"], [orderDigest, owner, timestamp(validTo)]);\n}\n/**\n * Extracts the order unique identifier parameters from the specified bytes.\n *\n * @param orderUid The order UID encoded as a hexadecimal string.\n * @returns The extracted order UID parameters.\n */\nexport function extractOrderUidParams(orderUid) {\n    const bytes = ethers.utils.arrayify(orderUid);\n    if (bytes.length != ORDER_UID_LENGTH) {\n        throw new Error(\"invalid order UID length\");\n    }\n    const view = new DataView(bytes.buffer);\n    return {\n        orderDigest: ethers.utils.hexlify(bytes.subarray(0, 32)),\n        owner: ethers.utils.getAddress(ethers.utils.hexlify(bytes.subarray(32, 52))),\n        validTo: view.getUint32(52),\n    };\n}\n//# sourceMappingURL=order.js.map","/**\n * Normalizes interaction data so that it is ready to be be ABI encoded.\n *\n * @param interaction The interaction to normalize.\n * @return The normalized interaction.\n */\nexport function normalizeInteraction(interaction) {\n    return Object.assign({ value: 0, callData: \"0x\" }, interaction);\n}\n/**\n * Normalizes data for many interactions so that they can be ABI encoded. This\n * calls [`normalizeInteraction`] for each interaction.\n *\n * @param interactions The interactions to normalize.\n * @return The normalized interactions.\n */\nexport function normalizeInteractions(interactions) {\n    return interactions.map(normalizeInteraction);\n}\n//# sourceMappingURL=interaction.js.map","/**\n * Checks whether the specified signer is a typed data signer.\n */\nexport function isTypedDataSigner(signer) {\n    return \"_signTypedData\" in signer;\n}\n/**\n * Checks whether the specified provider is a JSON RPC provider.\n */\nexport function isJsonRpcProvider(provider) {\n    return \"send\" in provider;\n}\n//# sourceMappingURL=ethers.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\nimport { ORDER_TYPE_FIELDS, CANCELLATIONS_TYPE_FIELDS, normalizeOrder, hashTypedData, } from \"./order\";\nimport { isTypedDataSigner, } from \"./types/ethers\";\n/**\n * Value returned by a call to `isValidSignature` if the signature was verified\n * successfully. The value is defined in the EIP-1271 standard as:\n * bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n */\nexport const EIP1271_MAGICVALUE = ethers.utils.hexDataSlice(ethers.utils.id(\"isValidSignature(bytes32,bytes)\"), 0, 4);\n/**\n * Marker value indicating a presignature is set.\n */\nexport const PRE_SIGNED = ethers.utils.id(\"GPv2Signing.Scheme.PreSign\");\n/**\n * The signing scheme used to sign the order.\n */\nexport var SigningScheme;\n(function (SigningScheme) {\n    /**\n     * The EIP-712 typed data signing scheme. This is the preferred scheme as it\n     * provides more infomation to wallets performing the signature on the data\n     * being signed.\n     *\n     * <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-domainseparator>\n     */\n    SigningScheme[SigningScheme[\"EIP712\"] = 0] = \"EIP712\";\n    /**\n     * Message signed using eth_sign RPC call.\n     */\n    SigningScheme[SigningScheme[\"ETHSIGN\"] = 1] = \"ETHSIGN\";\n    /**\n     * Smart contract signatures as defined in EIP-1271.\n     *\n     * <https://eips.ethereum.org/EIPS/eip-1271>\n     */\n    SigningScheme[SigningScheme[\"EIP1271\"] = 2] = \"EIP1271\";\n    /**\n     * Pre-signed order.\n     */\n    SigningScheme[SigningScheme[\"PRESIGN\"] = 3] = \"PRESIGN\";\n})(SigningScheme || (SigningScheme = {}));\nfunction ecdsaSignTypedData(scheme, owner, domain, types, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let signature = null;\n        switch (scheme) {\n            case SigningScheme.EIP712:\n                if (!isTypedDataSigner(owner)) {\n                    throw new Error(\"signer does not support signing typed data\");\n                }\n                signature = yield owner._signTypedData(domain, types, data);\n                break;\n            case SigningScheme.ETHSIGN:\n                signature = yield owner.signMessage(ethers.utils.arrayify(hashTypedData(domain, types, data)));\n                break;\n            default:\n                throw new Error(\"invalid signing scheme\");\n        }\n        // Passing the signature through split/join to normalize the `v` byte.\n        // Some wallets do not pad it with `27`, which causes a signature failure\n        // `splitSignature` pads it if needed, and `joinSignature` simply puts it back together\n        return ethers.utils.joinSignature(ethers.utils.splitSignature(signature));\n    });\n}\n/**\n * Returns the signature for the specified order with the signing scheme encoded\n * into the signature.\n *\n * @param domain The domain to sign the order for. This is used by the smart\n * contract to ensure orders can't be replayed across different applications,\n * but also different deployments (as the contract chain ID and address are\n * mixed into to the domain value).\n * @param order The order to sign.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the order.\n */\nexport function signOrder(domain, order, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order)),\n        };\n    });\n}\n/**\n * Returns the signature for cancelling a single order with the specified\n * signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUid The unique identifier of the order being cancelled.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellation(domain, orderUid, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return signOrderCancellations(domain, [orderUid], owner, scheme);\n    });\n}\n/**\n * Returns the signature for cancelling multiple orders by UID with the\n * specified signing scheme.\n *\n * @param domain The domain to sign the cancellation.\n * @param orderUids The unique identifiers of the orders to cancel.\n * @param owner The owner for the order used to sign.\n * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n * details.\n * @return Encoded signature including signing scheme for the cancellation.\n */\nexport function signOrderCancellations(domain, orderUids, owner, scheme) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            scheme,\n            data: yield ecdsaSignTypedData(scheme, owner, domain, { OrderCancellations: CANCELLATIONS_TYPE_FIELDS }, { orderUids }),\n        };\n    });\n}\n/**\n * Encodes the necessary data required for the Gnosis Protocol contracts to\n * verify an EIP-1271 signature.\n *\n * @param signature The EIP-1271 signature data to encode.\n */\nexport function encodeEip1271SignatureData({ verifier, signature, }) {\n    return ethers.utils.solidityPack([\"address\", \"bytes\"], [verifier, signature]);\n}\n/**\n * Decodes a GPv2 EIP-1271-type signature into the actual EIP-1271 signature\n * and the verifier contract.\n *\n * @param signature The EIP-1271 signature data to decode.\n * @returns decodedSignature The decoded signature object, composed of an\n * EIP-1271 signature and a verifier.\n */\nexport function decodeEip1271SignatureData(signature) {\n    const arrayifiedSignature = ethers.utils.arrayify(signature);\n    const verifier = ethers.utils.getAddress(ethers.utils.hexlify(arrayifiedSignature.slice(0, 20)));\n    return {\n        verifier,\n        signature: arrayifiedSignature.slice(20),\n    };\n}\n//# sourceMappingURL=sign.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers, BigNumber } from \"ethers\";\nimport { normalizeInteraction, } from \"./interaction\";\nimport { ORDER_TYPE_FIELDS, ORDER_UID_LENGTH, OrderBalance, OrderKind, hashTypedData, normalizeBuyTokenBalance, normalizeOrder, } from \"./order\";\nimport { SigningScheme, encodeEip1271SignatureData, signOrder, decodeEip1271SignatureData, } from \"./sign\";\n/**\n * The stage an interaction should be executed in.\n */\nexport var InteractionStage;\n(function (InteractionStage) {\n    /**\n     * A pre-settlement intraction.\n     *\n     * The interaction will be executed before any trading occurs. This can be\n     * used, for example, to perform as EIP-2612 `permit` call for a user trading\n     * in the current settlement.\n     */\n    InteractionStage[InteractionStage[\"PRE\"] = 0] = \"PRE\";\n    /**\n     * An intra-settlement interaction.\n     *\n     * The interaction will be executed after all trade sell amounts are\n     * transferred into the settlement contract, but before the buy amounts are\n     * transferred out to the traders. This can be used, for example, to interact\n     * with on-chain AMMs.\n     */\n    InteractionStage[InteractionStage[\"INTRA\"] = 1] = \"INTRA\";\n    /**\n     * A post-settlement interaction.\n     *\n     * The interaction will be executed after all trading has completed.\n     */\n    InteractionStage[InteractionStage[\"POST\"] = 2] = \"POST\";\n})(InteractionStage || (InteractionStage = {}));\n/**\n * An object listing all flag options in order along with their bit offset.\n */\nexport const FLAG_MASKS = {\n    kind: {\n        offset: 0,\n        options: [OrderKind.SELL, OrderKind.BUY],\n    },\n    partiallyFillable: {\n        offset: 1,\n        options: [false, true],\n    },\n    sellTokenBalance: {\n        offset: 2,\n        options: [\n            OrderBalance.ERC20,\n            undefined,\n            OrderBalance.EXTERNAL,\n            OrderBalance.INTERNAL,\n        ],\n    },\n    buyTokenBalance: {\n        offset: 4,\n        options: [OrderBalance.ERC20, OrderBalance.INTERNAL],\n    },\n    signingScheme: {\n        offset: 5,\n        options: [\n            SigningScheme.EIP712,\n            SigningScheme.ETHSIGN,\n            SigningScheme.EIP1271,\n            SigningScheme.PRESIGN,\n        ],\n    },\n};\nfunction encodeFlag(key, flag) {\n    const index = FLAG_MASKS[key].options.findIndex((search) => search === flag);\n    if (index === undefined) {\n        throw new Error(`Bad key/value pair to encode: ${key}/${flag}`);\n    }\n    return index << FLAG_MASKS[key].offset;\n}\n// Counts the smallest mask needed to store the input options in the masked\n// bitfield.\nfunction mask(options) {\n    const num = options.length;\n    const bitCount = 32 - Math.clz32(num - 1);\n    return (1 << bitCount) - 1;\n}\nfunction decodeFlag(key, flag) {\n    const { offset, options } = FLAG_MASKS[key];\n    const numberFlags = BigNumber.from(flag).toNumber();\n    const index = (numberFlags >> offset) & mask(options);\n    // This type casting should not be needed\n    const decoded = options[index];\n    if (decoded === undefined || index < 0) {\n        throw new Error(`Invalid input flag for ${key}: 0b${numberFlags.toString(2)}`);\n    }\n    return decoded;\n}\n/**\n * Encodes signing scheme as a bitfield.\n *\n * @param scheme The signing scheme to encode.\n * @return The bitfield result.\n */\nexport function encodeSigningScheme(scheme) {\n    return encodeFlag(\"signingScheme\", scheme);\n}\n/**\n * Decodes signing scheme from a bitfield.\n *\n * @param flag The encoded order flag.\n * @return The decoded signing scheme.\n */\nexport function decodeSigningScheme(flags) {\n    return decodeFlag(\"signingScheme\", flags);\n}\n/**\n * Encodes order flags as a bitfield.\n *\n * @param flags The order flags to encode.\n * @return The bitfield result.\n */\nexport function encodeOrderFlags(flags) {\n    var _a;\n    return (encodeFlag(\"kind\", flags.kind) |\n        encodeFlag(\"partiallyFillable\", flags.partiallyFillable) |\n        encodeFlag(\"sellTokenBalance\", (_a = flags.sellTokenBalance) !== null && _a !== void 0 ? _a : OrderBalance.ERC20) |\n        encodeFlag(\"buyTokenBalance\", normalizeBuyTokenBalance(flags.buyTokenBalance)));\n}\n/**\n * Decode order flags from a bitfield.\n *\n * @param flags The order flags encoded as a bitfield.\n * @return The decoded order flags.\n */\nexport function decodeOrderFlags(flags) {\n    return {\n        kind: decodeFlag(\"kind\", flags),\n        partiallyFillable: decodeFlag(\"partiallyFillable\", flags),\n        sellTokenBalance: decodeFlag(\"sellTokenBalance\", flags),\n        buyTokenBalance: decodeFlag(\"buyTokenBalance\", flags),\n    };\n}\n/**\n * Encodes trade flags as a bitfield.\n *\n * @param flags The trade flags to encode.\n * @return The bitfield result.\n */\nexport function encodeTradeFlags(flags) {\n    return encodeOrderFlags(flags) | encodeSigningScheme(flags.signingScheme);\n}\n/**\n * Decode trade flags from a bitfield.\n *\n * @param flags The trade flags encoded as a bitfield.\n * @return The bitfield result.\n */\nexport function decodeTradeFlags(flags) {\n    return Object.assign(Object.assign({}, decodeOrderFlags(flags)), { signingScheme: decodeSigningScheme(flags) });\n}\nexport function encodeSignatureData(sig) {\n    switch (sig.scheme) {\n        case SigningScheme.EIP712:\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.joinSignature(sig.data);\n        case SigningScheme.EIP1271:\n            return encodeEip1271SignatureData(sig.data);\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(sig.data);\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\nexport function decodeSignatureOwner(domain, order, scheme, sig) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return ethers.utils.verifyTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order), sig);\n        case SigningScheme.ETHSIGN:\n            return ethers.utils.verifyMessage(ethers.utils.arrayify(hashTypedData(domain, { Order: ORDER_TYPE_FIELDS }, normalizeOrder(order))), sig);\n        case SigningScheme.EIP1271:\n            return decodeEip1271SignatureData(sig).verifier;\n        case SigningScheme.PRESIGN:\n            return ethers.utils.getAddress(ethers.utils.hexlify(sig));\n        default:\n            throw new Error(\"unsupported signing scheme\");\n    }\n}\n/**\n * Encodes a trade to be used with the settlement contract.\n */\nexport function encodeTrade(tokens, order, signature, { executedAmount }) {\n    const tradeFlags = Object.assign(Object.assign({}, order), { signingScheme: signature.scheme });\n    const o = normalizeOrder(order);\n    return {\n        sellTokenIndex: tokens.index(o.sellToken),\n        buyTokenIndex: tokens.index(o.buyToken),\n        receiver: o.receiver,\n        sellAmount: o.sellAmount,\n        buyAmount: o.buyAmount,\n        validTo: o.validTo,\n        appData: o.appData,\n        feeAmount: o.feeAmount,\n        flags: encodeTradeFlags(tradeFlags),\n        executedAmount,\n        signature: encodeSignatureData(signature),\n    };\n}\n/**\n * A class used for tracking tokens when encoding settlements.\n *\n * This is used as settlement trades reference tokens by index instead of\n * directly by address for multiple reasons:\n * - Reduce encoding size of orders to save on `calldata` gas.\n * - Direct access to a token's clearing price on settlement instead of\n *   requiring a search.\n */\nexport class TokenRegistry {\n    constructor() {\n        this._tokens = [];\n        this._tokenMap = {};\n    }\n    /**\n     * Gets the array of token addresses currently stored in the registry.\n     */\n    get addresses() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.slice();\n    }\n    /**\n     * Retrieves the token index for the specified token address. If the token is\n     * not in the registry, it will be added.\n     *\n     * @param token The token address to add to the registry.\n     * @return The token index.\n     */\n    index(token) {\n        // NOTE: Verify and normalize the address into a case-checksummed address.\n        // Not only does this ensure validity of the addresses early on, it also\n        // makes it so `0xff...f` and `0xFF..F` map to the same ID.\n        const tokenAddress = ethers.utils.getAddress(token);\n        let tokenIndex = this._tokenMap[tokenAddress];\n        if (tokenIndex === undefined) {\n            tokenIndex = this._tokens.length;\n            this._tokens.push(tokenAddress);\n            this._tokenMap[tokenAddress] = tokenIndex;\n        }\n        return tokenIndex;\n    }\n}\n/**\n * A class for building calldata for a settlement.\n *\n * The encoder ensures that token addresses are kept track of and performs\n * necessary computation in order to map each token addresses to IDs to\n * properly encode order parameters for trades.\n */\nexport class SettlementEncoder {\n    /**\n     * Creates a new settlement encoder instance.\n     * @param domain Domain used for signing orders. See {@link signOrder} for\n     * more details.\n     */\n    constructor(domain) {\n        this.domain = domain;\n        this._tokens = new TokenRegistry();\n        this._trades = [];\n        this._interactions = {\n            [InteractionStage.PRE]: [],\n            [InteractionStage.INTRA]: [],\n            [InteractionStage.POST]: [],\n        };\n        this._orderRefunds = {\n            filledAmounts: [],\n            preSignatures: [],\n        };\n    }\n    /**\n     * Gets the array of token addresses used by the currently encoded orders.\n     */\n    get tokens() {\n        // NOTE: Make sure to slice the original array, so it cannot be modified\n        // outside of this class.\n        return this._tokens.addresses;\n    }\n    /**\n     * Gets the encoded trades.\n     */\n    get trades() {\n        return this._trades.slice();\n    }\n    /**\n     * Gets all encoded interactions for all stages.\n     *\n     * Note that order refund interactions are included as post-interactions.\n     */\n    get interactions() {\n        return [\n            this._interactions[InteractionStage.PRE].slice(),\n            this._interactions[InteractionStage.INTRA].slice(),\n            [\n                ...this._interactions[InteractionStage.POST],\n                ...this.encodedOrderRefunds,\n            ],\n        ];\n    }\n    /**\n     * Gets the order refunds encoded as interactions.\n     */\n    get encodedOrderRefunds() {\n        const { filledAmounts, preSignatures } = this._orderRefunds;\n        if (filledAmounts.length + preSignatures.length === 0) {\n            return [];\n        }\n        const settlement = this.domain.verifyingContract;\n        if (settlement === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        // NOTE: Avoid importing the full GPv2Settlement contract artifact just for\n        // a tiny snippet of the ABI. Unit and integration tests will catch any\n        // issues that may arise from this definition becoming out of date.\n        const iface = new ethers.utils.Interface([\n            \"function freeFilledAmountStorage(bytes[] orderUids)\",\n            \"function freePreSignatureStorage(bytes[] orderUids)\",\n        ]);\n        const interactions = [];\n        for (const [functionName, orderUids] of [\n            [\"freeFilledAmountStorage\", filledAmounts],\n            [\"freePreSignatureStorage\", preSignatures],\n        ].filter(([, orderUids]) => orderUids.length > 0)) {\n            interactions.push(normalizeInteraction({\n                target: settlement,\n                callData: iface.encodeFunctionData(functionName, [orderUids]),\n            }));\n        }\n        return interactions;\n    }\n    /**\n     * Returns a clearing price vector for the current settlement tokens from the\n     * provided price map.\n     *\n     * @param prices The price map from token address to price.\n     * @return The price vector.\n     */\n    clearingPrices(prices) {\n        return this.tokens.map((token) => {\n            const price = prices[token];\n            if (price === undefined) {\n                throw new Error(`missing price for token ${token}`);\n            }\n            return price;\n        });\n    }\n    /**\n     * Encodes a trade from a signed order and executed amount, appending it to\n     * the `calldata` bytes that are being built.\n     *\n     * Additionally, if the order references new tokens that the encoder has not\n     * yet seen, they are added to the tokens array.\n     *\n     * @param order The order of the trade to encode.\n     * @param signature The signature for the order data.\n     * @param tradeExecution The execution details for the trade.\n     */\n    encodeTrade(order, signature, { executedAmount } = {}) {\n        if (order.partiallyFillable && executedAmount === undefined) {\n            throw new Error(\"missing executed amount for partially fillable trade\");\n        }\n        this._trades.push(encodeTrade(this._tokens, order, signature, {\n            executedAmount: executedAmount !== null && executedAmount !== void 0 ? executedAmount : 0,\n        }));\n    }\n    /**\n     * Signs an order and encodes a trade with that order.\n     *\n     * @param order The order to sign for the trade.\n     * @param owner The externally owned account that should sign the order.\n     * @param scheme The signing scheme to use. See {@link SigningScheme} for more\n     * details.\n     * @param tradeExecution The execution details for the trade.\n     */\n    signEncodeTrade(order, owner, scheme, tradeExecution) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signature = yield signOrder(this.domain, order, owner, scheme);\n            this.encodeTrade(order, signature, tradeExecution);\n        });\n    }\n    /**\n     * Encodes the input interaction in the packed format accepted by the smart\n     * contract and adds it to the interactions encoded so far.\n     *\n     * @param stage The stage the interaction should be executed.\n     * @param interaction The interaction to encode.\n     */\n    encodeInteraction(interaction, stage = InteractionStage.INTRA) {\n        this._interactions[stage].push(normalizeInteraction(interaction));\n    }\n    /**\n     * Encodes order UIDs for gas refunds.\n     *\n     * @param settlement The address of the settlement contract.\n     * @param orderRefunds The order refunds to encode.\n     */\n    encodeOrderRefunds(orderRefunds) {\n        var _a, _b;\n        if (this.domain.verifyingContract === undefined) {\n            throw new Error(\"domain missing settlement contract address\");\n        }\n        const filledAmounts = (_a = orderRefunds.filledAmounts) !== null && _a !== void 0 ? _a : [];\n        const preSignatures = (_b = orderRefunds.preSignatures) !== null && _b !== void 0 ? _b : [];\n        if (![...filledAmounts, ...preSignatures].every((orderUid) => ethers.utils.isHexString(orderUid, ORDER_UID_LENGTH))) {\n            throw new Error(\"one or more invalid order UIDs\");\n        }\n        this._orderRefunds.filledAmounts.push(...filledAmounts);\n        this._orderRefunds.preSignatures.push(...preSignatures);\n    }\n    /**\n     * Returns the encoded settlement parameters.\n     */\n    encodedSettlement(prices) {\n        return [\n            this.tokens,\n            this.clearingPrices(prices),\n            this.trades,\n            this.interactions,\n        ];\n    }\n    /**\n     * Returns an encoded settlement that exclusively performs setup interactions.\n     * This method can be used, for example, to set the settlement contract's\n     * allowances to other protocols it may interact with.\n     *\n     * @param interactions The list of setup interactions to encode.\n     */\n    static encodedSetup(...interactions) {\n        const encoder = new SettlementEncoder({ name: \"unused\" });\n        for (const interaction of interactions) {\n            encoder.encodeInteraction(interaction);\n        }\n        return encoder.encodedSettlement({});\n    }\n}\n/**\n * Decodes an order from a settlement trade.\n *\n * @param trade The trade to decode into an order.\n * @param tokens The list of token addresses as they appear in the settlement.\n * @returns The decoded order.\n */\nexport function decodeOrder(trade, tokens) {\n    const sellTokenIndex = BigNumber.from(trade.sellTokenIndex).toNumber();\n    const buyTokenIndex = BigNumber.from(trade.buyTokenIndex).toNumber();\n    if (Math.max(sellTokenIndex, buyTokenIndex) >= tokens.length) {\n        throw new Error(\"Invalid trade\");\n    }\n    return Object.assign({ sellToken: tokens[sellTokenIndex], buyToken: tokens[buyTokenIndex], receiver: trade.receiver, sellAmount: trade.sellAmount, buyAmount: trade.buyAmount, validTo: BigNumber.from(trade.validTo).toNumber(), appData: trade.appData, feeAmount: trade.feeAmount }, decodeOrderFlags(trade.flags));\n}\n//# sourceMappingURL=settlement.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, constants } from \"ethers\";\nimport fetch from \"node-fetch\";\nimport { normalizeOrder, OrderKind, } from \"./order\";\nimport { encodeSignatureData } from \"./settlement\";\nimport { SigningScheme } from \"./sign\";\nexport var Environment;\n(function (Environment) {\n    Environment[Environment[\"Dev\"] = 0] = \"Dev\";\n    Environment[Environment[\"Prod\"] = 1] = \"Prod\";\n})(Environment || (Environment = {}));\nexport const LIMIT_CONCURRENT_REQUESTS = 5;\nexport function apiUrl(environment, network) {\n    switch (environment) {\n        case Environment.Dev:\n            return `https://barn.api.cow.fi/${network}`;\n        case Environment.Prod:\n            return `https://api.cow.fi/${network}`;\n        default:\n            throw new Error(\"Invalid environment\");\n    }\n}\nexport var QuotePriceQuality;\n(function (QuotePriceQuality) {\n    QuotePriceQuality[\"FAST\"] = \"fast\";\n    QuotePriceQuality[\"OPTIMAL\"] = \"optimal\";\n})(QuotePriceQuality || (QuotePriceQuality = {}));\nexport var GetQuoteErrorType;\n(function (GetQuoteErrorType) {\n    GetQuoteErrorType[\"SellAmountDoesNotCoverFee\"] = \"SellAmountDoesNotCoverFee\";\n    GetQuoteErrorType[\"NoLiquidity\"] = \"NoLiquidity\";\n    // other errors are added when necessary\n})(GetQuoteErrorType || (GetQuoteErrorType = {}));\nfunction apiKind(kind) {\n    switch (kind) {\n        case OrderKind.SELL:\n            return \"sell\";\n        case OrderKind.BUY:\n            return \"buy\";\n        default:\n            throw new Error(`Unsupported kind ${kind}`);\n    }\n}\nfunction apiSigningScheme(scheme) {\n    switch (scheme) {\n        case SigningScheme.EIP712:\n            return \"eip712\";\n        case SigningScheme.ETHSIGN:\n            return \"ethsign\";\n        case SigningScheme.EIP1271:\n            return \"eip1271\";\n        case SigningScheme.PRESIGN:\n            return \"presign\";\n        default:\n            throw new Error(`Unsupported signing scheme ${scheme}`);\n    }\n}\nfunction call(route, baseUrl, init) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = `${baseUrl}/api/v1/${route}`;\n        const response = yield fetch(url, init);\n        const body = yield response.text();\n        if (!response.ok) {\n            const error = new Error(`Calling \"${url} ${JSON.stringify(init)} failed with ${response.status}: ${body}`);\n            try {\n                error.apiError = JSON.parse(body);\n            }\n            catch (_a) {\n                // no api error\n            }\n            throw error;\n        }\n        return JSON.parse(body);\n    });\n}\nfunction estimateTradeAmount({ sellToken, buyToken, kind, amount, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const side = kind == OrderKind.SELL\n            ? {\n                kind: OrderKind.SELL,\n                sellAmountAfterFee: amount,\n            }\n            : {\n                kind: OrderKind.BUY,\n                buyAmountAfterFee: amount,\n            };\n        const { quote } = yield getQuote({ baseUrl }, Object.assign({ from: constants.AddressZero, sellToken,\n            buyToken, priceQuality: QuotePriceQuality.FAST }, side));\n        // The services return the quote token used for the price. The quote token\n        // is checked to make sure that the returned price meets our expectations.\n        if (quote.buyToken.toLowerCase() !== buyToken.toLowerCase()) {\n            throw new Error(`Price returned for sell token ${sellToken} uses an incorrect quote token (${quote.buyToken.toLowerCase()} instead of ${buyToken.toLowerCase()})`);\n        }\n        const estimatedAmount = kind == OrderKind.SELL ? quote.buyAmount : quote.sellAmount;\n        return BigNumber.from(estimatedAmount);\n    });\n}\nfunction placeOrder({ order, signature, baseUrl, from, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const normalizedOrder = normalizeOrder(order);\n        return yield call(\"orders\", baseUrl, {\n            method: \"post\",\n            body: JSON.stringify({\n                sellToken: normalizedOrder.sellToken,\n                buyToken: normalizedOrder.buyToken,\n                sellAmount: BigNumber.from(normalizedOrder.sellAmount).toString(),\n                buyAmount: BigNumber.from(normalizedOrder.buyAmount).toString(),\n                validTo: normalizedOrder.validTo,\n                appData: normalizedOrder.appData,\n                feeAmount: BigNumber.from(normalizedOrder.feeAmount).toString(),\n                kind: apiKind(order.kind),\n                partiallyFillable: normalizedOrder.partiallyFillable,\n                signature: encodeSignatureData(signature),\n                signingScheme: apiSigningScheme(signature.scheme),\n                receiver: normalizedOrder.receiver,\n                from,\n            }),\n            headers: { \"Content-Type\": \"application/json\" },\n        });\n    });\n}\nfunction getExecutedSellAmount({ uid, baseUrl, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield call(`orders/${uid}`, baseUrl);\n        return BigNumber.from(response.executedSellAmount);\n    });\n}\nfunction getQuote({ baseUrl }, quote) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Convert BigNumber into JSON strings (native serialisation is a hex object)\n        if (quote.sellAmountBeforeFee) {\n            quote.sellAmountBeforeFee = (quote).sellAmountBeforeFee.toString();\n        }\n        if (quote.sellAmountAfterFee) {\n            quote.sellAmountAfterFee = (quote).sellAmountAfterFee.toString();\n        }\n        if (quote.buyAmountAfterFee) {\n            quote.buyAmountAfterFee = (quote).buyAmountAfterFee.toString();\n        }\n        return call(\"quote\", baseUrl, {\n            method: \"post\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(quote),\n        });\n    });\n}\nexport class Api {\n    constructor(network, baseUrlOrEnv) {\n        this.network = network;\n        let baseUrl;\n        if (typeof baseUrlOrEnv === \"string\") {\n            baseUrl = baseUrlOrEnv;\n        }\n        else {\n            baseUrl = apiUrl(baseUrlOrEnv, network);\n        }\n        this.baseUrl = baseUrl;\n    }\n    apiCallParams() {\n        return { network: this.network, baseUrl: this.baseUrl };\n    }\n    estimateTradeAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return estimateTradeAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    placeOrder(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return placeOrder(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getExecutedSellAmount(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getExecutedSellAmount(Object.assign(Object.assign({}, this.apiCallParams()), query));\n        });\n    }\n    getQuote(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getQuote(this.apiCallParams(), query);\n        });\n    }\n}\n//# sourceMappingURL=api.js.map","import { utils } from \"ethers\";\n/**\n * The salt used when deterministically deploying smart contracts.\n */\nexport const SALT = utils.formatBytes32String(\"Mattresses in Berlin!\");\n/**\n * The contract used to deploy contracts deterministically with CREATE2.\n * The address is chosen by the hardhat-deploy library.\n * It is the same in any EVM-based network.\n *\n * https://github.com/Arachnid/deterministic-deployment-proxy\n */\nexport const DEPLOYER_CONTRACT = \"0x4e59b44847b379578588920ca78fbf26c0b4956c\";\n/**\n * Dictionary containing all deployed contract names.\n */\nexport const CONTRACT_NAMES = {\n    authenticator: \"GPv2AllowListAuthentication\",\n    settlement: \"GPv2Settlement\",\n    tradeSimulator: \"GPv2TradeSimulator\",\n};\n/**\n * Computes the deterministic address at which the contract will be deployed.\n * This address does not depend on which network the contract is deployed to.\n *\n * @param contractName Name of the contract for which to find the address.\n * @param deploymentArguments Extra arguments that are necessary to deploy.\n * @returns The address that is expected to store the deployed code.\n */\nexport function deterministicDeploymentAddress({ abi, bytecode }, deploymentArguments) {\n    const contractInterface = new utils.Interface(abi);\n    const deployData = utils.hexConcat([\n        bytecode,\n        contractInterface.encodeDeploy(deploymentArguments),\n    ]);\n    return utils.getCreate2Address(DEPLOYER_CONTRACT, SALT, utils.keccak256(deployData));\n}\n//# sourceMappingURL=deploy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber, Contract, ethers } from \"ethers\";\n/**\n * Compute an EIP-1967 slot for the specified name. The proxy contract used by\n * `hardhat-deploy` implements EIP-1967 (Standard Proxy Storage Slot).\n *\n * <https://eips.ethereum.org/EIPS/eip-1967>.\n */\nfunction slot(name) {\n    return ethers.utils.defaultAbiCoder.encode([\"bytes32\"], [BigNumber.from(ethers.utils.id(name)).sub(1)]);\n}\nconst IMPLEMENTATION_STORAGE_SLOT = slot(\"eip1967.proxy.implementation\");\nconst OWNER_STORAGE_SLOT = slot(\"eip1967.proxy.admin\");\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the contract storing the proxy implementation.\n */\nexport function implementationAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [implementation] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, IMPLEMENTATION_STORAGE_SLOT));\n        return implementation;\n    });\n}\n/**\n * Returns the address of the implementation of an EIP-1967-compatible proxy\n * from its address.\n *\n * @param proxy Address of the proxy contract.\n * @returns The address of the administrator of the proxy.\n */\nexport function ownerAddress(provider, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [owner] = ethers.utils.defaultAbiCoder.decode([\"address\"], yield provider.getStorageAt(proxy, OWNER_STORAGE_SLOT));\n        return owner;\n    });\n}\n/**\n * EIP-173 proxy ABI in \"human-readable ABI\" format. The proxy used by the\n * deployment plugin implements this interface, and copying it here avoids\n * pulling in `hardhat` as a dependency for just this ABI.\n *\n * <https://eips.ethereum.org/EIPS/eip-173#specification>\n */\nexport const EIP173_PROXY_ABI = [\n    \"event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)\",\n    \"function owner() view external returns(address)\",\n    \"function transferOwnership(address newOwner) external\",\n    \"function supportsInterface(bytes4 interfaceID) external view returns (bool)\",\n];\n/**\n * Returns the proxy interface for the specified address.\n *\n * @param contract The proxy contract to return a proxy interface for.\n * @returns A Ethers.js contract instance for interacting with the proxy.\n */\nexport function proxyInterface(contract) {\n    var _a;\n    return new Contract(contract.address, EIP173_PROXY_ABI, (_a = contract.signer) !== null && _a !== void 0 ? _a : contract.provider);\n}\n//# sourceMappingURL=proxy.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ethers } from \"ethers\";\n/**\n * Balancer Vault partial ABI interface.\n *\n * This definition only contains the Vault methods that are used by GPv2 Vault\n * relayer. It is copied here to avoid relying on build artifacts.\n */\nexport const VAULT_INTERFACE = new ethers.utils.Interface([\n    \"function manageUserBalance((uint8, address, uint256, address, address)[])\",\n    \"function batchSwap(uint8, (bytes32, uint256, uint256, uint256, bytes)[], address[], (address, bool, address, bool), int256[], uint256)\",\n]);\n/**\n * Grants the required roles to the specified Vault relayer.\n *\n * This method is intended to be called by the Balancer Vault admin, and **not**\n * traders. It is included in the exported TypeScript library for completeness\n * and \"documentation\".\n *\n * @param authorizer The Vault authorizer contract that manages access.\n * @param vaultAddress The address to the Vault.\n * @param vaultRelayerAddress The address to the GPv2 Vault relayer contract.\n */\nexport function grantRequiredRoles(authorizer, vaultAddress, vaultRelayerAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const name in VAULT_INTERFACE.functions) {\n            yield authorizer.grantRole(ethers.utils.solidityKeccak256([\"uint256\", \"bytes4\"], [vaultAddress, VAULT_INTERFACE.getSighash(name)]), vaultRelayerAddress);\n        }\n    });\n}\n//# sourceMappingURL=vault.js.map","import { utils, providers, BigNumber } from 'ethers'\nimport {\n  COMPOSABLE_COW_CONTRACT_ADDRESS,\n  EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS,\n  SupportedChainId,\n} from '../common'\nimport { ExtensibleFallbackHandler__factory } from './generated'\nimport { BlockInfo, ConditionalOrderParams } from './types'\nimport { Order, OrderBalance, OrderKind } from '@wowswapfork/contracts'\nimport { GPv2Order } from './generated/ComposableCoW'\n\nconst ERC20_BALANCE_VALUES = ['erc20', '0x5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9']\nconst EXTERNAL_BALANCE_VALUES = ['external', '0xabee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632']\nconst INTERNAL_BALANCE_VALUES = ['internal', '0x4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce']\nconst SELL_KIND_VALUES = ['sell', '0xf3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775']\nconst BUY_KIND_VALUES = ['buy', '0x6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc']\n\n// Define the ABI tuple for the ConditionalOrderParams struct\nexport const CONDITIONAL_ORDER_PARAMS_ABI = ['tuple(address handler, bytes32 salt, bytes staticInput)']\n\nexport const DEFAULT_TOKEN_FORMATTER = (address: string, amount: BigNumber) => `${amount}@${address}`\n\nexport function isExtensibleFallbackHandler(handler: string, chainId: SupportedChainId): boolean {\n  return handler === EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId]\n}\n\nexport function isComposableCow(handler: string, chainId: SupportedChainId): boolean {\n  return handler === COMPOSABLE_COW_CONTRACT_ADDRESS[chainId]\n}\n\nexport async function getDomainVerifier(\n  safe: string,\n  domain: string,\n  chainId: SupportedChainId,\n  provider: providers.Provider\n): Promise<string> {\n  const contract = ExtensibleFallbackHandler__factory.connect(\n    EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS[chainId],\n    provider\n  )\n  return await contract.callStatic.domainVerifiers(safe, domain)\n}\n\nexport function createSetDomainVerifierTx(domain: string, verifier: string): string {\n  return ExtensibleFallbackHandler__factory.createInterface().encodeFunctionData('setDomainVerifier', [\n    domain,\n    verifier,\n  ])\n}\n\n/**\n * Encode the `ConditionalOrderParams` for the conditional order.\n *\n * @param params The `ConditionalOrderParams` struct representing the conditional order as taken from a merkle tree.\n * @returns The ABI-encoded conditional order.\n * @see ConditionalOrderParams\n */\nexport function encodeParams(params: ConditionalOrderParams): string {\n  return utils.defaultAbiCoder.encode(CONDITIONAL_ORDER_PARAMS_ABI, [params])\n}\n\n/**\n * Decode the `ConditionalOrderParams` for the conditional order.\n *\n * @param encoded The encoded conditional order.\n * @returns The decoded conditional order.\n */\nexport function decodeParams(encoded: string): ConditionalOrderParams {\n  const { handler, salt, staticInput } = utils.defaultAbiCoder.decode(CONDITIONAL_ORDER_PARAMS_ABI, encoded)[0]\n  return { handler, salt, staticInput }\n}\n\n/**\n * Helper method for validating ABI types.\n * @param types ABI types to validate against.\n * @param values The values to validate.\n * @returns {boolean} Whether the values are valid ABI for the given types.\n */\nexport function isValidAbi(types: readonly (string | utils.ParamType)[], values: any[]): boolean {\n  try {\n    utils.defaultAbiCoder.encode(types, values)\n  } catch (e) {\n    return false\n  }\n  return true\n}\n\nexport async function getBlockInfo(provider: providers.Provider): Promise<BlockInfo> {\n  const block = await provider.getBlock('latest')\n\n  return {\n    blockNumber: block.number,\n    blockTimestamp: block.timestamp,\n  }\n}\n\nexport function formatEpoch(epoch: number): string {\n  return new Date(epoch * 1000).toISOString()\n}\n\n/**\n * Convert a balance source/destination hash to a string\n *\n * @param balance balance source/destination hash\n * @returns string representation of the balance\n * @throws if the balance is not recognized\n */\nfunction balanceToString(balance: string) {\n  if (ERC20_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.ERC20\n  } else if (EXTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.EXTERNAL\n  } else if (INTERNAL_BALANCE_VALUES.includes(balance)) {\n    return OrderBalance.INTERNAL\n  } else {\n    throw new Error(`Unknown balance type: ${balance}`)\n  }\n}\n\n/**\n * Convert an order kind hash to a string\n * @param kind of order in hash format\n * @returns string representation of the order kind\n */\nfunction kindToString(kind: string) {\n  if (SELL_KIND_VALUES.includes(kind)) {\n    return OrderKind.SELL\n  } else if (BUY_KIND_VALUES.includes(kind)) {\n    return OrderKind.BUY\n  } else {\n    throw new Error(`Unknown kind: ${kind}`)\n  }\n}\n\nexport function fromStructToOrder(order: GPv2Order.DataStruct): Order {\n  const {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    buyTokenBalance,\n    sellTokenBalance,\n    feeAmount,\n    kind,\n    receiver,\n    validTo,\n    partiallyFillable,\n    appData,\n  } = order\n\n  return {\n    sellToken,\n    sellAmount,\n    buyToken,\n    buyAmount,\n    feeAmount,\n    receiver,\n    partiallyFillable,\n    appData,\n    validTo: Number(validTo),\n    kind: kindToString(kind.toString()),\n    sellTokenBalance: balanceToString(sellTokenBalance.toString()),\n    buyTokenBalance: balanceToString(buyTokenBalance.toString()),\n  }\n}\n","import { providers } from 'ethers'\nimport { COMPOSABLE_COW_CONTRACT_ADDRESS, SupportedChainId } from '../common'\nimport { ComposableCoW, ComposableCoW__factory } from './generated'\nimport { ComposableCoWInterface } from './generated/ComposableCoW'\n\nlet composableCowInterfaceCache: ComposableCoWInterface | undefined\nlet composableCowContractCache: ComposableCoW | undefined\n\nexport function getComposableCowInterface(): ComposableCoWInterface {\n  if (!composableCowInterfaceCache) {\n    composableCowInterfaceCache = ComposableCoW__factory.createInterface()\n  }\n\n  return composableCowInterfaceCache\n}\n\nexport function getComposableCow(chain: SupportedChainId, provider: providers.Provider): ComposableCoW {\n  if (!composableCowContractCache) {\n    composableCowContractCache = ComposableCoW__factory.connect(COMPOSABLE_COW_CONTRACT_ADDRESS[chain], provider)\n  }\n\n  return composableCowContractCache\n}\n","import { BigNumber, constants, ethers, utils } from 'ethers'\nimport { GPv2Order, IConditionalOrder } from './generated/ComposableCoW'\n\nimport { decodeParams, encodeParams, fromStructToOrder } from './utils'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  IsValidResult,\n  OwnerContext,\n  PollParams,\n  PollResult,\n  PollResultCode,\n  PollResultErrors,\n} from './types'\nimport { getComposableCow, getComposableCowInterface } from './contracts'\nimport { OrderBookApi, UID } from '../order-book'\nimport { computeOrderUid } from '../utils'\n\nconst orderBookCache: Record<string, OrderBookApi> = {}\n\n/**\n * An abstract base class from which all conditional orders should inherit.\n *\n * This class provides some basic functionality to help with handling conditional orders,\n * such as:\n * - Validating the conditional order\n * - Creating a human-readable string representation of the conditional order\n * - Serializing the conditional order for use with the `IConditionalOrder` struct\n * - Getting any dependencies for the conditional order\n * - Getting the off-chain input for the conditional order\n *\n * **NOTE**: Instances of conditional orders have an `id` property that is a `keccak256` hash of\n *           the serialized conditional order.\n */\nexport abstract class ConditionalOrder<D, S> {\n  public readonly handler: string\n  public readonly salt: string\n  public readonly data: D\n  public readonly staticInput: S\n  public readonly hasOffChainInput: boolean\n\n  /**\n   * A constructor that provides some basic validation for the conditional order.\n   *\n   * This constructor **MUST** be called by any class that inherits from `ConditionalOrder`.\n   *\n   * **NOTE**: The salt is optional and will be randomly generated if not provided.\n   * @param handler The address of the handler for the conditional order.\n   * @param salt A 32-byte string used to salt the conditional order.\n   * @param data The data of the order\n   * @param hasOffChainInput Whether the conditional order has off-chain input.\n   * @throws If the handler is not a valid ethereum address.\n   * @throws If the salt is not a valid 32-byte string.\n   */\n  constructor(params: ConditionalOrderArguments<D>) {\n    const { handler, salt = utils.keccak256(utils.randomBytes(32)), data, hasOffChainInput = false } = params\n    // Verify input to the constructor\n    // 1. Verify that the handler is a valid ethereum address\n    if (!ethers.utils.isAddress(handler)) {\n      throw new Error(`Invalid handler: ${handler}`)\n    }\n\n    // 2. Verify that the salt is a valid 32-byte string usable with ethers\n    if (!ethers.utils.isHexString(salt) || ethers.utils.hexDataLength(salt) !== 32) {\n      throw new Error(`Invalid salt: ${salt}`)\n    }\n\n    this.handler = handler\n    this.salt = salt\n    this.data = data\n    this.staticInput = this.transformDataToStruct(data)\n\n    this.hasOffChainInput = hasOffChainInput\n  }\n\n  // TODO: https://github.com/cowprotocol/cow-sdk/issues/155\n  abstract get isSingleOrder(): boolean\n\n  /**\n   * Get a descriptive name for the type of the conditional order (i.e twap, dca, etc).\n   *\n   * @returns {string} The concrete type of the conditional order.\n   */\n  abstract get orderType(): string\n\n  /**\n   * Get the context dependency for the conditional order.\n   *\n   * This is used when calling `createWithContext` or `setRootWithContext` on a ComposableCoW-enabled Safe.\n   * @returns The context dependency.\n   */\n  get context(): ContextFactory | undefined {\n    return undefined\n  }\n\n  assertIsValid(): void {\n    const isValidResult = this.isValid()\n    if (!isValidResult.isValid) {\n      throw new Error(`Invalid order: ${isValidResult.reason}`)\n    }\n  }\n\n  abstract isValid(): IsValidResult\n\n  /**\n   * Get the calldata for creating the conditional order.\n   *\n   * This will automatically determine whether or not to use `create` or `createWithContext` based on the\n   * order type's context dependency.\n   *\n   * **NOTE**: By default, this will cause the create to emit the `ConditionalOrderCreated` event.\n   * @returns The calldata for creating the conditional order.\n   */\n  get createCalldata(): string {\n    this.assertIsValid()\n\n    const context = this.context\n    const composableCow = getComposableCowInterface()\n    const paramsStruct: IConditionalOrder.ConditionalOrderParamsStruct = {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n\n    if (context) {\n      // Create (with context)\n      const contextArgsAbi = context.factoryArgs\n        ? utils.defaultAbiCoder.encode(context.factoryArgs.argsType, context.factoryArgs.args)\n        : '0x'\n      return composableCow.encodeFunctionData('createWithContext', [\n        paramsStruct,\n        context.address,\n        contextArgsAbi,\n        true,\n      ])\n    } else {\n      // Create\n      return composableCow.encodeFunctionData('create', [paramsStruct, true])\n    }\n  }\n\n  /**\n   * Get the calldata for removing a conditional order that was created as a single order.\n   * @returns The calldata for removing the conditional order.\n   */\n  get removeCalldata(): string {\n    this.assertIsValid()\n\n    return getComposableCowInterface().encodeFunctionData('remove', [this.id])\n  }\n\n  /**\n   * Calculate the id of the conditional order (which also happens to be the key used for `ctx` in the ComposableCoW contract).\n   *\n   * This is a `keccak256` hash of the serialized conditional order.\n   * @returns The id of the conditional order.\n   */\n  get id(): string {\n    return utils.keccak256(this.serialize())\n  }\n\n  /**\n   * The context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet\n   *\n   * The context, relates to the 'ctx' in the contract: https://github.com/cowprotocol/composable-cow/blob/c7fb85ab10c05e28a1632ba97a1749fb261fcdfb/src/interfaces/IConditionalOrder.sol#L38\n   */\n  protected get ctx(): string {\n    return this.isSingleOrder ? this.id : constants.HashZero\n  }\n\n  /**\n   * Get the `leaf` of the conditional order. This is the data that is used to create the merkle tree.\n   *\n   * For the purposes of this library, the `leaf` is the `ConditionalOrderParams` struct.\n   * @returns The `leaf` of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  get leaf(): ConditionalOrderParams {\n    return {\n      handler: this.handler,\n      salt: this.salt,\n      staticInput: this.encodeStaticInput(),\n    }\n  }\n\n  /**\n   * Calculate the id of the conditional order.\n   * @param leaf The `leaf` representing the conditional order.\n   * @returns The id of the conditional order.\n   * @see ConditionalOrderParams\n   */\n  static leafToId(leaf: ConditionalOrderParams): string {\n    return utils.keccak256(encodeParams(leaf))\n  }\n\n  /**\n   * If the conditional order has off-chain input, return it!\n   *\n   * **NOTE**: This should be overridden by any conditional order that has off-chain input.\n   * @returns The off-chain input.\n   */\n  get offChainInput(): string {\n    return '0x'\n  }\n\n  /**\n   * Create a human-readable string representation of the conditional order.\n   *\n   * @param tokenFormatter An optional function that takes an address and an amount and returns a human-readable string.\n   */\n  abstract toString(tokenFormatter?: (address: string, amount: BigNumber) => string): string\n\n  /**\n   * Serializes the conditional order into it's ABI-encoded form.\n   *\n   * @returns The equivalent of `IConditionalOrder.Params` for the conditional order.\n   */\n  abstract serialize(): string\n\n  /**\n   * Encode the `staticInput` for the conditional order.\n   *\n   * @returns The ABI-encoded `staticInput` for the conditional order.\n   * @see ConditionalOrderParams\n   */\n  abstract encodeStaticInput(): string\n\n  /**\n   * A helper function for generically serializing a conditional order's static input.\n   *\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param data The order's data struct.\n   * @returns An ABI-encoded representation of the order's data struct.\n   */\n  protected encodeStaticInputHelper(orderDataTypes: string[], staticInput: S): string {\n    return utils.defaultAbiCoder.encode(orderDataTypes, [staticInput])\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   *\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  async poll(params: PollParams): Promise<PollResult> {\n    const { chainId, owner, provider, orderbookApiConfig } = params\n    const composableCow = getComposableCow(chainId, provider)\n\n    try {\n      const isValid = this.isValid()\n      // Do a validation first\n      if (!isValid.isValid) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `InvalidConditionalOrder. Reason: ${isValid.reason}`,\n        }\n      }\n\n      // Let the concrete Conditional Order decide about the poll result\n      const pollResult = await this.pollValidate(params)\n      if (pollResult) {\n        return pollResult\n      }\n\n      // Check if the owner authorized the order\n      const isAuthorized = await this.isAuthorized(params)\n      if (!isAuthorized) {\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `NotAuthorized: Order ${this.id} is not authorized for ${owner} on chain ${chainId}`,\n        }\n      }\n\n      // Lastly, try to get the tradeable order and signature\n      const [order, signature] = await composableCow.getTradeableOrderWithSignature(\n        owner,\n        this.leaf,\n        this.offChainInput,\n        []\n      )\n\n      let orderBookApi = orderBookCache[chainId]\n      if (!orderBookApi) {\n        orderBookApi = new OrderBookApi({ ...orderbookApiConfig, chainId })\n        orderBookCache[chainId] = orderBookApi\n      }\n\n      const orderUid = await computeOrderUid(chainId, owner, fromStructToOrder(order))\n\n      // Check if the order is already in the order book\n      const isOrderInOrderbook = await orderBookApi\n        .getOrder(orderUid)\n        .then(() => true)\n        .catch(() => false)\n\n      // Let the concrete Conditional Order decide about the poll result (in the case the order is already in the orderbook)\n      if (isOrderInOrderbook) {\n        const pollResult = await this.handlePollFailedAlreadyPresent(orderUid, order, params)\n        if (pollResult) {\n          return pollResult\n        }\n\n        return {\n          result: PollResultCode.TRY_NEXT_BLOCK,\n          reason: 'Order already in orderbook',\n        }\n      }\n\n      return {\n        result: PollResultCode.SUCCESS,\n        order,\n        signature,\n      }\n    } catch (error) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        error: error,\n      }\n    }\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param params owner context, to be able to check if the order is authorized\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  public isAuthorized(params: OwnerContext): Promise<boolean> {\n    const { chainId, owner, provider } = params\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.singleOrders(owner, this.id)\n  }\n\n  /**\n   * Checks the value in the cabinet for a given owner and chain\n   *\n   * @param params owner context, to be able to check the cabinet\n   */\n  public cabinet(params: OwnerContext): Promise<string> {\n    const { chainId, owner, provider } = params\n\n    const composableCow = getComposableCow(chainId, provider)\n    return composableCow.callStatic.cabinet(owner, this.ctx)\n  }\n\n  /**\n   * Allow concrete conditional orders to perform additional validation for the poll method.\n   *\n   * This will allow the concrete orders to decide when an order shouldn't be polled again. For example, if the orders is expired.\n   * It also allows to signal when should the next check be done. For example, an order could signal that the validations will fail until a certain time or block.\n   *\n   * @param params The poll parameters\n   *\n   * @returns undefined if the concrete order can't make a decision. Otherwise, it returns a PollResultErrors object.\n   */\n  protected abstract pollValidate(params: PollParams): Promise<PollResultErrors | undefined>\n\n  /**\n   * This method lets the concrete conditional order decide what to do if the order yielded in the polling is already present in the Orderbook API.\n   *\n   * The concrete conditional order will have a chance to schedule the next poll.\n   * For example, a TWAP order that has the current part already in the orderbook, can signal that the next poll should be done at the start time of the next part.\n   *\n   * @param params\n   */\n  protected abstract handlePollFailedAlreadyPresent(\n    orderUid: UID,\n    order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined>\n\n  /**\n   * Convert the struct that the contract expect as an encoded `staticInput` into a friendly data object modelling the smart order.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformStructToData(params: S): D\n\n  /**\n   * Converts a friendly data object modelling the smart order into the struct that the contract expect as an encoded `staticInput`.\n   *\n   * **NOTE**: This should be overridden by any conditional order that requires transformations.\n   * This implementation is a no-op if you use the same type for both.\n   *\n   * @param params {S} Parameters that are passed in to the constructor.\n   * @returns {D} The static input for the conditional order.\n   */\n  abstract transformDataToStruct(params: D): S\n\n  /**\n   * A helper function for generically deserializing a conditional order.\n   * @param s The ABI-encoded `IConditionalOrder.Params` struct to deserialize.\n   * @param handler Address of the handler for the conditional order.\n   * @param orderDataTypes ABI types for the order's data struct.\n   * @param callback A callback function that takes the deserialized data struct and the salt and returns an instance of the class.\n   * @returns An instance of the conditional order class.\n   */\n  protected static deserializeHelper<T>(\n    s: string,\n    handler: string,\n    orderDataTypes: string[],\n    callback: (d: any, salt: string) => T\n  ): T {\n    try {\n      // First, decode the `IConditionalOrder.Params` struct\n      const { handler: recoveredHandler, salt, staticInput } = decodeParams(s)\n\n      // Second, verify that the recovered handler is the correct handler\n      if (!(recoveredHandler == handler)) throw new Error('HandlerMismatch')\n\n      // Third, decode the data struct\n      const [d] = utils.defaultAbiCoder.decode(orderDataTypes, staticInput)\n\n      // Create a new instance of the class\n      return callback(d, salt)\n    } catch (e: any) {\n      if (e.message === 'HandlerMismatch') {\n        throw e\n      } else {\n        throw new Error('InvalidSerializedConditionalOrder')\n      }\n    }\n  }\n}\n","import type { Order } from '@wowswapfork/contracts'\nimport type { SupportedChainId } from './common'\nimport { OrderSigningUtils } from './order-signing'\n\nexport async function computeOrderUid(chainId: SupportedChainId, owner: string, order: Order): Promise<string> {\n  const { computeOrderUid: _computeOrderUid } = await import('@wowswapfork/contracts')\n  const domain = await OrderSigningUtils.getDomain(chainId)\n\n  return _computeOrderUid(domain, order, owner)\n}\n","import { StandardMerkleTree } from '@openzeppelin/merkle-tree'\nimport { BigNumber, providers, utils } from 'ethers'\n\nimport { SupportedChainId } from '../common'\n\nimport { ComposableCoW, GPv2Order } from './generated/ComposableCoW'\nimport { ProofLocation, ProofWithParams, ConditionalOrderParams } from './types'\nimport { ConditionalOrder } from './ConditionalOrder'\nimport { getComposableCow } from './contracts'\n\nconst CONDITIONAL_ORDER_LEAF_ABI = ['address', 'bytes32', 'bytes']\n\nconst PAYLOAD_EMITTED_ABI = ['tuple(bytes32[] proof, tuple(address handler, bytes32 salt, bytes staticInput) params)[]']\n\nexport type Orders = Record<string, ConditionalOrder<unknown, unknown>>\n\n/**\n * Multiplexer for conditional orders - using `ComposableCoW`!\n *\n * This class provides functionality to:\n * - Generate a merkle tree of conditional orders\n * - Generate proofs for all orders in the merkle tree\n * - Save proofs, with the ability to omit / skip specific conditional orders\n * - Support for passing an optional upload function to upload the proofs to a decentralized storage network\n */\nexport class Multiplexer {\n  static orderTypeRegistry: Record<string, new (...args: unknown[]) => ConditionalOrder<unknown, unknown>> = {}\n\n  public chain: SupportedChainId\n  public location: ProofLocation\n\n  private orders: Orders = {}\n  private tree?: StandardMerkleTree<string[]>\n  private ctx?: string\n\n  /**\n   * @param chain The `chainId` for where we're using `ComposableCoW`.\n   * @param orders An optional array of conditional orders to initialize the merkle tree with.\n   * @param root An optional root to verify against.\n   * @param location The location of the proofs for the conditional orders.\n   */\n  constructor(\n    chain: SupportedChainId,\n    orders?: Orders,\n    root?: string,\n    location: ProofLocation = ProofLocation.PRIVATE\n  ) {\n    this.chain = chain\n    this.location = location\n\n    // If orders are provided, the length must be > 0\n    if (orders && Object.keys(orders).length === 0) {\n      throw new Error('orders must have non-zero length')\n    }\n\n    // If orders are provided, so must a root, and vice versa\n    if ((orders && !root) || (!orders && root)) {\n      throw new Error('orders cannot have undefined root')\n    }\n\n    // can only proceed past here if both orders and root are provided, or neither are\n\n    // validate that no unknown order types are provided\n    for (const orderKey in orders) {\n      if (orders.hasOwnProperty(orderKey)) {\n        const order = orders[orderKey]\n        if (!Multiplexer.orderTypeRegistry.hasOwnProperty(order.orderType)) {\n          throw new Error(`Unknown order type: ${order.orderType}`)\n        }\n      }\n    }\n\n    // If orders (and therefore the root) are provided, generate the merkle tree\n    if (orders) {\n      this.orders = orders\n\n      // if generate was successful, we can verify the root\n      if (this.getOrGenerateTree().root !== root) {\n        throw new Error('root mismatch')\n      }\n    }\n  }\n\n  // --- user facing serialization methods ---\n\n  /**\n   * Given a serialized multiplexer, create the multiplexer and rehydrate all conditional orders.\n   * Integrity of the multiplexer will be verified by generating the merkle tree and verifying\n   * the root.\n   *\n   * **NOTE**: Before using this method, you must register all conditional order types using `Multiplexer.registerOrderType`.\n   * @param s The serialized multiplexer.\n   * @returns The multiplexer with all conditional orders rehydrated.\n   * @throws If the multiplexer cannot be deserialized.\n   * @throws If the merkle tree cannot be generated.\n   * @throws If the merkle tree cannot be verified against the root.\n   */\n  static fromJSON(s: string): Multiplexer {\n    // reviver function to deserialize the orders\n    const reviver = (k: string, v: any) => {\n      if (k === 'orders' && typeof v === 'object' && v !== null) {\n        const orders: Orders = {}\n\n        for (const orderKey in v) {\n          if (v.hasOwnProperty(orderKey)) {\n            const { orderType, ...orderData } = v[orderKey]\n\n            if (Multiplexer.orderTypeRegistry.hasOwnProperty(orderType)) {\n              const OrderConstructor = Multiplexer.orderTypeRegistry[orderType]\n              orders[orderKey] = new OrderConstructor(orderData)\n            } else {\n              throw new Error(`Unknown order type: ${orderType}`)\n            }\n          }\n        }\n\n        return orders\n      }\n\n      // Make sure we deserialize `BigNumber` correctly\n      if (typeof v === 'object' && v !== null && v.hasOwnProperty('type') && v.hasOwnProperty('hex')) {\n        if (v.type === 'BigNumber') {\n          return BigNumber.from(v)\n        }\n      }\n\n      return v\n    }\n\n    const { chain, orders, root, location } = JSON.parse(s, reviver)\n    const m = new Multiplexer(chain, orders, root)\n    m.location = location\n    return m\n  }\n\n  /**\n   * Serialize the multiplexer to JSON.\n   *\n   * This will include all state necessary to reconstruct the multiplexer, including the root.\n   * @remarks This will **NOT** include the merkle tree.\n   * @returns The JSON representation of the multiplexer, including the root but excluding the merkle tree.\n   */\n  toJSON(): string {\n    const root = this.getOrGenerateTree().root\n\n    // serialize the multiplexer, including the root but excluding the merkle tree.\n    return JSON.stringify({ ...this, root }, (k, v) => {\n      // filter out the merkle tree\n      if (k === 'tree') return undefined\n      if (typeof v === 'object' && v !== null && 'orderType' in v) {\n        const conditionalOrder = v as ConditionalOrder<unknown, unknown>\n        return {\n          ...conditionalOrder,\n          orderType: conditionalOrder.orderType,\n        }\n      }\n      // We do not do any custom serialization of `BigNumber` in order to preserve it's type.\n      return v\n    })\n  }\n\n  // --- crud methods ---\n\n  /**\n   * Add a conditional order to the merkle tree.\n   * @param order The order to add to the merkle tree.\n   */\n  add<T, P>(order: ConditionalOrder<T, P>): void {\n    order.assertIsValid()\n\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  /**\n   * Remove a conditional order from the merkle tree.\n   * @param id The id of the `ConditionalOrder` to remove from the merkle tree.\n   */\n  remove(id: string): void {\n    delete this.orders[id]\n    this.reset()\n  }\n\n  /**\n   * Update a given conditional order in the merkle tree.\n   * @param id The id of the `ConditionalOrder` to update.\n   * @param updater A function that takes the existing `ConditionalOrder` and context, returning an updated `ConditionalOrder`.\n   */\n  update(\n    id: string,\n    updater: (order: ConditionalOrder<unknown, unknown>, ctx?: string) => ConditionalOrder<unknown, unknown>\n  ): void {\n    // copy the existing order and update it, given the existing context (if any)\n    const order = updater(this.orders[id], this.ctx)\n    // delete the existing order\n    delete this.orders[id]\n\n    // add the updated order\n    this.orders[order.id] = order\n    this.reset()\n  }\n\n  // --- accessors ---\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param id The `id` of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` with the given `id`.\n   */\n  getById(id: string): ConditionalOrder<unknown, unknown> {\n    return this.orders[id]\n  }\n\n  /**\n   * Accessor for a given conditional order in the multiplexer.\n   * @param i The index of the `ConditionalOrder` to retrieve.\n   * @returns A `ConditionalOrder` at the given index.\n   */\n  getByIndex(i: number): ConditionalOrder<unknown, unknown> {\n    return this.orders[this.orderIds[i]]\n  }\n\n  /**\n   * Get all the conditional order ids in the multiplexer.\n   */\n  get orderIds(): string[] {\n    return Object.keys(this.orders)\n  }\n\n  get root(): string {\n    return this.getOrGenerateTree().root\n  }\n\n  /**\n   * Retrieve the merkle tree of orders, or generate it if it doesn't exist.\n   *\n   * **CAUTION**: Developers of the SDK should prefer to use this method instead of generating the\n   *              merkle tree themselves. This method makes use of caching to avoid generating the\n   *              merkle tree needlessly.\n   * @throws If the merkle tree cannot be generated.\n   * @returns The merkle tree for the current set of conditional orders.\n   */\n  private getOrGenerateTree(): StandardMerkleTree<string[]> {\n    if (!this.tree) {\n      this.tree = StandardMerkleTree.of(\n        Object.values(this.orders).map((order) => [...Object.values(order.leaf)]),\n        CONDITIONAL_ORDER_LEAF_ABI\n      )\n    }\n\n    return this.tree\n  }\n\n  // --- serialization for watchtowers / indexers ---\n\n  /**\n   * The primary method for watch towers to use when deserializing the proofs and parameters for the conditional orders.\n   * @param s The serialized proofs with parameters for consumption by watchtowers / indexers.\n   * @returns The `ProofWithParams` array.\n   * @throws If the `ProofWithParams` array cannot be deserialized.\n   */\n  static decodeFromJSON(s: string): ProofWithParams[] {\n    // no need to rehydrate `BigNumber` as this is fully ABI encoded\n    return JSON.parse(s)\n  }\n\n  /**\n   * The primary entry point for dapps integrating with `ComposableCoW` to generate the proofs and\n   * parameters for the conditional orders.\n   *\n   * After populating the multiplexer with conditional orders, this method can be used to generate\n   * the proofs and parameters for the conditional orders. The returned `ProofStruct` can then be\n   * used with `setRoot` or `setRootWithContext` on a `ComposableCoW`-enabled Safe.\n   *\n   * @param filter {@link getProofs}\n   * @parma locFn A function that takes the off-chain encoded input, and returns the `location`\n   *        for the `ProofStruct`, and the `data` for the `ProofStruct`.\n   * @returns The ABI-encoded `ProofStruct` for `setRoot` and `setRootWithContext`.\n   */\n  async prepareProofStruct(\n    location: ProofLocation = this.location,\n    filter?: (v: string[]) => boolean,\n    uploader?: (offChainEncoded: string) => Promise<string>\n  ): Promise<ComposableCoW.ProofStruct> {\n    const data = async (): Promise<string> => {\n      switch (location) {\n        case ProofLocation.PRIVATE:\n          return '0x'\n        case ProofLocation.EMITTED:\n          return this.encodeToABI(filter)\n        case ProofLocation.SWARM:\n        case ProofLocation.WAKU:\n        case ProofLocation.IPFS:\n          if (!uploader) throw new Error('Must provide an uploader function')\n          try {\n            return await uploader(this.encodeToJSON(filter))\n          } catch (e) {\n            throw new Error(`Error uploading to decentralized storage ${location}: ${e}`)\n          }\n        default:\n          throw new Error('Unsupported location')\n      }\n    }\n\n    return await data()\n      .then((d) => {\n        try {\n          // validate that `d` is a valid `bytes` ready to be abi-encoded\n          utils.hexlify(utils.arrayify(d))\n\n          // if we get here, we have a valid `data` field for the `ProofStruct`\n          // This means that if there was an upload function, it was called and the upload was successful\n          // note: we don't check if the location has changed because we don't care\n          this.location = location\n\n          return {\n            location,\n            data: d,\n          }\n        } catch (e) {\n          throw new Error(`data returned by uploader is invalid`)\n        }\n      })\n      .catch((e) => {\n        throw new Error(`Error preparing proof struct: ${e}`)\n      })\n  }\n\n  /**\n   * Poll a conditional order to see if it is tradeable.\n   * @param owner The owner of the conditional order.\n   * @param p The proof and parameters.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @param offChainInputFn A function, if provided, that will return the off-chain input for the conditional order.\n   * @throws If the conditional order is not tradeable.\n   * @returns The tradeable `GPv2Order.Data` struct and the `signature` for the conditional order.\n   */\n  static async poll(\n    owner: string,\n    p: ProofWithParams,\n    chain: SupportedChainId,\n    provider: providers.Provider,\n    offChainInputFn?: (owner: string, params: ConditionalOrderParams) => Promise<string>\n  ): Promise<[GPv2Order.DataStruct, string]> {\n    const composableCow = getComposableCow(chain, provider)\n\n    const offChainInput = offChainInputFn ? await offChainInputFn(owner, p.params) : '0x'\n    return await composableCow.getTradeableOrderWithSignature(owner, p.params, offChainInput, p.proof)\n  }\n\n  /**\n   * The primary entry point for dumping the proofs and parameters for the conditional orders.\n   *\n   * This is to be used by watchtowers / indexers to store the proofs and parameters for the\n   * conditional orders off-chain. The encoding returned by this method may **NOT** contain all\n   * proofs and parameters, depending on the `filter` provided, and therefore should not be used\n   * to rehydrate the multiplexer from a user's perspective.\n   * @param filter {@link getProofs}\n   * @returns A JSON-encoded string of the proofs and parameters for the conditional orders.\n   */\n  dumpProofs(filter?: (v: string[]) => boolean): string {\n    return this.encodeToJSON(filter)\n  }\n\n  dumpProofsAndParams(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    return this.getProofs(filter)\n  }\n\n  /**\n   * Get the proofs with parameters for the conditional orders in the merkle tree.\n   * @param filter A function that takes a conditional order and returns a boolean indicating\n   *               whether the order should be included in the proof.\n   * @returns An array of proofs and their order's parameters for the conditional orders in the\n   *          merkle tree.\n   */\n  private getProofs(filter?: (v: string[]) => boolean): ProofWithParams[] {\n    // Get a list of all entry indices in the tree, excluding any that don't match the filter\n    return [...this.getOrGenerateTree().entries()]\n      .map(([i, v]) => {\n        if ((filter && filter(v)) || filter === undefined) {\n          return { idx: i, value: v }\n        } else {\n          return undefined\n        }\n      })\n      .reduce((acc: ProofWithParams[], x) => {\n        if (x) {\n          const p: ConditionalOrderParams = {\n            handler: x.value[0],\n            salt: x.value[1],\n            staticInput: x.value[2],\n          }\n          acc.push({\n            proof: this.getOrGenerateTree().getProof(x.idx),\n            params: p,\n          })\n        }\n        return acc\n      }, [])\n  }\n\n  /**\n   * ABI-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns ABI-encoded `data` for the `ProofStruct`.\n   */\n  private encodeToABI(filter?: (v: string[]) => boolean): string {\n    return utils.defaultAbiCoder.encode(PAYLOAD_EMITTED_ABI, [this.getProofs(filter)])\n  }\n\n  /**\n   * JSON-encode the proofs and parameters for the conditional orders in the merkle tree.\n   * @param filter {@link getProofs}\n   * @returns The JSON-encoded data for storage off-chain.\n   */\n  private encodeToJSON(filter?: (v: string[]) => boolean): string {\n    return JSON.stringify(this.getProofs(filter))\n  }\n\n  /**\n   * A helper to reset the merkle tree.\n   */\n  private reset(): void {\n    this.tree = undefined\n  }\n\n  /**\n   * Register a conditional order type with the multiplexer.\n   *\n   * **CAUTION**: This is required for using `Multiplexer.fromJSON` and `Multiplexer.toJSON`.\n   * @param orderType The order type to register.\n   * @param conditionalOrderClass The class to use for the given order type.\n   */\n  public static registerOrderType(\n    orderType: string,\n    conditionalOrderClass: new (...args: any[]) => ConditionalOrder<unknown, unknown>\n  ) {\n    Multiplexer.orderTypeRegistry[orderType] = conditionalOrderClass\n  }\n\n  /**\n   * Reset the order type registry.\n   */\n  public static resetOrderTypeRegistry() {\n    Multiplexer.orderTypeRegistry = {}\n  }\n}\n","import { type ConditionalOrder } from './ConditionalOrder'\nimport { ConditionalOrderParams } from './types'\n\nexport type FromParams<D, S> = (params: ConditionalOrderParams) => ConditionalOrder<D, S>\nexport type ConditionalOrderRegistry = Record<string, FromParams<unknown, unknown>>\n\nexport class ConditionalOrderFactory {\n  public knownOrderTypes\n\n  constructor(registry: ConditionalOrderRegistry) {\n    this.knownOrderTypes = registry\n  }\n\n  public fromParams(params: ConditionalOrderParams): ConditionalOrder<unknown, unknown> | undefined {\n    const { handler } = params\n\n    const factory = this.knownOrderTypes[handler]\n    if (!factory) {\n      return undefined\n    }\n\n    return factory(params)\n  }\n}\n","import { BigNumber, constants, utils } from 'ethers'\n\nimport { ConditionalOrder } from '../ConditionalOrder'\nimport {\n  ConditionalOrderArguments,\n  ConditionalOrderParams,\n  ContextFactory,\n  OwnerContext,\n  IsValidResult,\n  PollParams,\n  PollResultCode,\n  PollResultErrors,\n} from '../types'\nimport { encodeParams, formatEpoch, getBlockInfo, isValidAbi } from '../utils'\nimport { GPv2Order } from '../generated/ComposableCoW'\n\n// The type of Conditional Order\nconst TWAP_ORDER_TYPE = 'twap'\n// The address of the TWAP handler contract\nexport const TWAP_ADDRESS = '0x6cF1e9cA41f7611dEf408122793c358a3d11E5a5'\n/**\n * The address of the `CurrentBlockTimestampFactory` contract\n *\n * **NOTE**: This is used in the event that TWAP's have a `t0` of `0`.\n */\nexport const CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS = '0x52eD56Da04309Aca4c3FECC595298d80C2f16BAc'\n\nexport const MAX_UINT32 = BigNumber.from(2).pow(32).sub(1) // 2^32 - 1\nexport const MAX_FREQUENCY = BigNumber.from(365 * 24 * 60 * 60) // 1 year\n\n// Define the ABI tuple for the TWAPData struct\nconst TWAP_STRUCT_ABI = [\n  'tuple(address sellToken, address buyToken, address receiver, uint256 partSellAmount, uint256 minPartLimit, uint256 t0, uint256 n, uint256 t, uint256 span, bytes32 appData)',\n]\n\n/**\n * Base parameters for a TWAP order. Shared by:\n *   - TwapStruct (modelling the contract's struct used for `staticInput`).\n *   - TwapData (modelling the friendly SDK interface).\n */\nexport type TwapDataBase = {\n  /**\n   * which token to sell\n   */\n  readonly sellToken: string\n\n  /**\n   * which token to buy\n   */\n  readonly buyToken: string\n\n  /**\n   * who to send the tokens to\n   */\n  readonly receiver: string\n\n  /**\n   * Meta-data associated with the order. Normally would be the keccak256 hash of the document generated in http://github.com/cowprotocol/app-data\n   *\n   * This hash should have been uploaded to the API https://api.cow.fi/docs/#/default/put_api_v1_app_data__app_data_hash_ and potentially to other data availability protocols like IPFS.\n   *\n   */\n  readonly appData: string\n}\n\n/**\n * Parameters for a TWAP order, as expected by the contract's `staticInput`.\n */\nexport interface TwapStruct extends TwapDataBase {\n  /**\n   * amount of sellToken to sell in each part\n   */\n  readonly partSellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought in each part\n   */\n  readonly minPartLimit: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly t0: BigNumber\n\n  /**\n   * number of parts\n   */\n  readonly n: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly t: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly span: BigNumber\n}\n\n/**\n * Parameters for a TWAP order, made a little more user-friendly for SDK users.\n *\n * @see {@link TwapStruct} for the native struct.\n */\nexport interface TwapData extends TwapDataBase {\n  /**\n   * total amount of sellToken to sell across the entire TWAP\n   */\n  readonly sellAmount: BigNumber\n\n  /**\n   * minimum amount of buyToken that must be bought across the entire TWAP\n   */\n  readonly buyAmount: BigNumber\n\n  /**\n   * start time of the TWAP\n   */\n  readonly startTime?: StartTime\n\n  /**\n   * number of parts\n   */\n  readonly numberOfParts: BigNumber\n\n  /**\n   * duration of the TWAP interval\n   */\n  readonly timeBetweenParts: BigNumber\n\n  /**\n   * whether the TWAP is valid for the entire interval or not\n   */\n  readonly durationOfPart?: DurationOfPart\n}\n\nexport type DurationOfPart =\n  | { durationType: DurationType.AUTO }\n  | { durationType: DurationType.LIMIT_DURATION; duration: BigNumber }\n\nexport enum DurationType {\n  AUTO = 'AUTO',\n  LIMIT_DURATION = 'LIMIT_DURATION',\n}\n\nexport type StartTime =\n  | { startType: StartTimeValue.AT_MINING_TIME }\n  | { startType: StartTimeValue.AT_EPOCH; epoch: BigNumber }\n\nexport enum StartTimeValue {\n  AT_MINING_TIME = 'AT_MINING_TIME',\n  AT_EPOCH = 'AT_EPOCH',\n}\n\nconst DEFAULT_START_TIME: StartTime = { startType: StartTimeValue.AT_MINING_TIME }\nconst DEFAULT_DURATION_OF_PART: DurationOfPart = { durationType: DurationType.AUTO }\n\n/**\n * `ComposableCoW` implementation of a TWAP order.\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nexport class Twap extends ConditionalOrder<TwapData, TwapStruct> {\n  isSingleOrder = true\n\n  /**\n   * @see {@link ConditionalOrder.constructor}\n   * @throws If the TWAP order is invalid.\n   * @throws If the TWAP order is not ABI-encodable.\n   * @throws If the handler is not the TWAP address.\n   */\n  constructor(params: ConditionalOrderArguments<TwapData>) {\n    const { handler, salt, data: staticInput, hasOffChainInput } = params\n\n    // First, verify that the handler is the TWAP address\n    if (handler !== TWAP_ADDRESS) throw new Error(`InvalidHandler: Expected: ${TWAP_ADDRESS}, provided: ${handler}`)\n\n    // Third, construct the base class using transformed parameters\n    super({ handler: TWAP_ADDRESS, salt, data: staticInput, hasOffChainInput })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromData(data: TwapData, salt?: string): Twap {\n    return new Twap({ handler: TWAP_ADDRESS, data, salt })\n  }\n\n  /**\n   * Create a TWAP order with sound defaults.\n   * @param data The TWAP order parameters in a more user-friendly format.\n   * @returns An instance of the TWAP order.\n   */\n  static fromParams(params: ConditionalOrderParams): Twap {\n    return Twap.deserialize(encodeParams(params))\n  }\n\n  /**\n   * Enforces that TWAPs will commence at the beginning of a block by use of the\n   * `CurrentBlockTimestampFactory` contract to provide the current block timestamp\n   * as the start time of the TWAP.\n   */\n  get context(): ContextFactory | undefined {\n    if (this.staticInput.t0.gt(0)) {\n      return super.context\n    } else {\n      return {\n        address: CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS,\n        factoryArgs: undefined,\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc {@link ConditionalOrder.orderType}\n   */\n  get orderType(): string {\n    return TWAP_ORDER_TYPE\n  }\n\n  /**\n   * Validate the TWAP order.\n   * @param data The TWAP order to validate.\n   * @returns Whether the TWAP order is valid.\n   * @throws If the TWAP order is invalid.\n   * @see {@link TwapStruct} for the native struct.\n   */\n  isValid(): IsValidResult {\n    const error = (() => {\n      const {\n        sellToken,\n        sellAmount,\n        buyToken,\n        buyAmount,\n        startTime = DEFAULT_START_TIME,\n        numberOfParts,\n        timeBetweenParts,\n        durationOfPart = DEFAULT_DURATION_OF_PART,\n      } = this.data\n\n      // Verify that the order params are logically valid\n      if (!(sellToken != buyToken)) return 'InvalidSameToken'\n      if (!(sellToken != constants.AddressZero && buyToken != constants.AddressZero)) return 'InvalidToken'\n      if (!sellAmount.gt(constants.Zero)) return 'InvalidSellAmount'\n      if (!buyAmount.gt(constants.Zero)) return 'InvalidMinBuyAmount'\n      if (startTime.startType === StartTimeValue.AT_EPOCH) {\n        const t0 = startTime.epoch\n        if (!(t0.gte(constants.Zero) && t0.lt(MAX_UINT32))) return 'InvalidStartTime'\n      }\n      if (!(numberOfParts.gt(constants.One) && numberOfParts.lte(MAX_UINT32))) return 'InvalidNumParts'\n      if (!(timeBetweenParts.gt(constants.Zero) && timeBetweenParts.lte(MAX_FREQUENCY))) return 'InvalidFrequency'\n      if (durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n        if (!durationOfPart.duration.lte(timeBetweenParts)) return 'InvalidSpan'\n      }\n\n      // Verify that the staticInput derived from the data is ABI-encodable\n      if (!isValidAbi(TWAP_STRUCT_ABI, [this.staticInput])) return 'InvalidData'\n\n      // No errors\n      return undefined\n    })()\n\n    return error ? { isValid: false, reason: error } : { isValid: true }\n  }\n\n  protected async startTimestamp(params: OwnerContext): Promise<number> {\n    const { startTime } = this.data\n\n    if (startTime?.startType === StartTimeValue.AT_EPOCH) {\n      return startTime.epoch.toNumber()\n    }\n\n    const cabinet = await this.cabinet(params)\n    const rawCabinetEpoch = utils.defaultAbiCoder.decode(['uint256'], cabinet)[0] as BigNumber\n\n    // Guard against out-of-range cabinet epoch\n    if (rawCabinetEpoch.gt(MAX_UINT32)) {\n      throw new Error(`Cabinet epoch out of range: ${rawCabinetEpoch.toString()}`)\n    }\n\n    // Convert the cabinet epoch (bignumber) to a number.\n    const cabinetEpoch = rawCabinetEpoch.toNumber()\n\n    if (cabinetEpoch === 0) {\n      throw new Error('Cabinet is not set. Required for TWAP orders that start at mining time.')\n    }\n\n    return cabinetEpoch\n  }\n\n  /**\n   * Given the start timestamp of the TWAP, calculate the end timestamp.\n   * @dev As usually the `endTimestamp` is used when determining a TWAP's validity, we don't\n   *      do any lookup to the blockchain to determine the start timestamp, as this has likely\n   *      already been done during the verification flow.\n   * @dev Beware to handle the case of `span != 0` ie. `durationOfPart.durationType !== DurationType.AUTO`.\n   * @param startTimestamp The start timestamp of the TWAP.\n   * @returns The timestamp at which the TWAP will end.\n   */\n  protected endTimestamp(startTimestamp: number): number {\n    const { numberOfParts, timeBetweenParts, durationOfPart } = this.data\n\n    if (durationOfPart && durationOfPart.durationType === DurationType.LIMIT_DURATION) {\n      return startTimestamp + numberOfParts.sub(1).mul(timeBetweenParts).add(durationOfPart.duration).toNumber()\n    }\n\n    return startTimestamp + numberOfParts.mul(timeBetweenParts).toNumber()\n  }\n\n  /**\n   * Checks if the owner authorized the conditional order.\n   *\n   * @param owner The owner of the conditional order.\n   * @param chain Which chain to use for the ComposableCoW contract.\n   * @param provider An RPC provider for the chain.\n   * @returns true if the owner authorized the order, false otherwise.\n   */\n  protected async pollValidate(params: PollParams): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    try {\n      const startTimestamp = await this.startTimestamp(params)\n\n      if (startTimestamp > blockTimestamp) {\n        // The start time hasn't started\n        return {\n          result: PollResultCode.TRY_AT_EPOCH,\n          epoch: startTimestamp,\n          reason: `TWAP hasn't started yet. Starts at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        }\n      }\n\n      const expirationTimestamp = this.endTimestamp(startTimestamp)\n      if (blockTimestamp >= expirationTimestamp) {\n        // The order has expired\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `TWAP has expired. Expired at ${expirationTimestamp} (${formatEpoch(expirationTimestamp)})`,\n        }\n      }\n\n      return undefined\n    } catch (err: any) {\n      if (err?.message?.includes('Cabinet is not set')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}. User likely removed the order.`,\n        }\n      } else if (err?.message?.includes('Cabinet epoch out of range')) {\n        // in this case we have a firm reason to not monitor this order as the cabinet is not set correctly\n        return {\n          result: PollResultCode.DONT_TRY_AGAIN,\n          reason: `${err?.message}`,\n        }\n      }\n\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `Unexpected error: ${err.message}`,\n        error: err,\n      }\n    }\n  }\n\n  /**\n   * Handles the error when the order is already present in the orderbook.\n   *\n   * Given the current part is in the book, it will signal to Watch Tower what to do:\n   *   - Wait until the next part starts\n   *   - Don't try again if current part is the last one\n   *\n   * NOTE: The error messages will refer to the parts 1-indexed, so first part is 1, second part is 2, etc.\n   */\n  protected async handlePollFailedAlreadyPresent(\n    _orderUid: string,\n    _order: GPv2Order.DataStruct,\n    params: PollParams\n  ): Promise<PollResultErrors | undefined> {\n    const { blockInfo = await getBlockInfo(params.provider) } = params\n    const { blockTimestamp } = blockInfo\n\n    const timeBetweenParts = this.data.timeBetweenParts.toNumber()\n    const { numberOfParts } = this.data\n    const startTimestamp = await this.startTimestamp(params)\n\n    if (blockTimestamp < startTimestamp) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP part hash't started. First TWAP part start at ${startTimestamp} (${formatEpoch(startTimestamp)})`,\n        error: undefined,\n      }\n    }\n    const expireTime = numberOfParts.mul(timeBetweenParts).add(startTimestamp).toNumber()\n    if (blockTimestamp >= expireTime) {\n      return {\n        result: PollResultCode.UNEXPECTED_ERROR,\n        reason: `TWAP is expired. Expired at ${expireTime} (${formatEpoch(expireTime)})`,\n        error: undefined,\n      }\n    }\n\n    // Get current part number\n    const currentPartNumber = Math.floor((blockTimestamp - startTimestamp) / timeBetweenParts)\n\n    // If current part is the last one\n    if (currentPartNumber === numberOfParts.toNumber() - 1) {\n      return {\n        result: PollResultCode.DONT_TRY_AGAIN,\n        reason: `Current active TWAP part (${\n          currentPartNumber + 1\n        }/${numberOfParts}) is already in the Order Book. This was the last TWAP part, no more orders need to be placed`,\n      }\n    }\n\n    // Next part start time\n    const nextPartStartTime = startTimestamp + (currentPartNumber + 1) * timeBetweenParts\n\n    /**\n     * Given we know, that TWAP part that is due in the current block is already in the Orderbook,\n     * Then, we can safely instruct that we should wait until the next TWAP part starts\n     */\n    return {\n      result: PollResultCode.TRY_AT_EPOCH,\n      epoch: nextPartStartTime,\n      reason: `Current active TWAP part (${\n        currentPartNumber + 1\n      }/${numberOfParts}) is already in the Order Book. TWAP part ${\n        currentPartNumber + 2\n      } doesn't start until ${nextPartStartTime} (${formatEpoch(nextPartStartTime)})`,\n    }\n  }\n\n  /**\n   * Serialize the TWAP order into it's ABI-encoded form.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  serialize(): string {\n    return encodeParams(this.leaf)\n  }\n\n  /**\n   * Get the encoded static input for the TWAP order.\n   * @returns {string} The ABI-encoded TWAP order.\n   */\n  encodeStaticInput(): string {\n    return super.encodeStaticInputHelper(TWAP_STRUCT_ABI, this.staticInput)\n  }\n\n  /**\n   * Deserialize a TWAP order from it's ABI-encoded form.\n   * @param {string} twapSerialized ABI-encoded TWAP order to deserialize.\n   * @returns A deserialized TWAP order.\n   */\n  static deserialize(twapSerialized: string): Twap {\n    return super.deserializeHelper(\n      twapSerialized,\n      TWAP_ADDRESS,\n      TWAP_STRUCT_ABI,\n      (struct: TwapStruct, salt: string) =>\n        new Twap({\n          handler: TWAP_ADDRESS,\n          salt,\n          data: transformStructToData(struct),\n        })\n    )\n  }\n\n  /**\n   * Create a human-readable string representation of the TWAP order.\n   * @returns {string} A human-readable string representation of the TWAP order.\n   */\n  toString(): string {\n    const {\n      sellAmount,\n      sellToken,\n      buyAmount,\n      buyToken,\n      numberOfParts,\n      startTime = DEFAULT_START_TIME,\n      timeBetweenParts,\n      durationOfPart = DEFAULT_DURATION_OF_PART,\n      receiver,\n      appData,\n    } = this.data\n\n    const startTimeFormatted =\n      startTime.startType === StartTimeValue.AT_MINING_TIME ? 'AT_MINING_TIME' : startTime.epoch.toNumber()\n    const durationOfPartFormatted =\n      durationOfPart.durationType === DurationType.AUTO ? 'AUTO' : durationOfPart.duration.toNumber()\n\n    const details = {\n      sellAmount: sellAmount.toString(),\n      sellToken,\n      buyAmount: buyAmount.toString(),\n      buyToken,\n      numberOfParts: numberOfParts.toString(),\n      startTime: startTimeFormatted,\n      timeBetweenParts: timeBetweenParts.toNumber(),\n      durationOfPart: durationOfPartFormatted,\n      receiver,\n      appData,\n    }\n\n    return `${this.orderType} (${this.id}): ${JSON.stringify(details)}`\n  }\n\n  /**\n   * Transform parameters into a native struct.\n   *\n   * @param {TwapData} data As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformDataToStruct(data: TwapData): TwapStruct {\n    return transformDataToStruct(data)\n  }\n\n  /**\n   * Transform parameters into a TWAP order struct.\n   *\n   * @param {TwapData} params As passed by the consumer of the API.\n   * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n   */\n  transformStructToData(struct: TwapStruct): TwapData {\n    return transformStructToData(struct)\n  }\n}\n\n/**\n * Transform parameters into a native struct.\n *\n * @param {TwapData} data As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformDataToStruct(data: TwapData): TwapStruct {\n  const {\n    sellAmount,\n    buyAmount,\n    numberOfParts,\n    startTime: startTime = DEFAULT_START_TIME,\n    timeBetweenParts,\n    durationOfPart = DEFAULT_DURATION_OF_PART,\n    ...rest\n  } = data\n\n  const { partSellAmount, minPartLimit } =\n    numberOfParts && !numberOfParts.isZero()\n      ? {\n          partSellAmount: sellAmount.div(numberOfParts),\n          minPartLimit: buyAmount.div(numberOfParts),\n        }\n      : {\n          partSellAmount: constants.Zero,\n          minPartLimit: constants.Zero,\n        }\n\n  const span = durationOfPart.durationType === DurationType.AUTO ? constants.Zero : durationOfPart.duration\n  const t0 = startTime.startType === StartTimeValue.AT_MINING_TIME ? constants.Zero : startTime.epoch\n\n  return {\n    partSellAmount,\n    minPartLimit,\n    t0,\n    n: numberOfParts,\n    t: timeBetweenParts,\n    span,\n    ...rest,\n  }\n}\n\n/**\n * Transform parameters into a TWAP order struct.\n *\n * @param {TwapData} params As passed by the consumer of the API.\n * @returns {TwapStruct} A formatted struct as expected by the smart contract.\n */\nexport function transformStructToData(struct: TwapStruct): TwapData {\n  const { n: numberOfParts, partSellAmount, minPartLimit, t: timeBetweenParts, t0: startEpoch, span, ...rest } = struct\n\n  const durationOfPart: DurationOfPart = span.isZero()\n    ? { durationType: DurationType.AUTO }\n    : { durationType: DurationType.LIMIT_DURATION, duration: span }\n\n  const startTime: StartTime = span.isZero()\n    ? { startType: StartTimeValue.AT_MINING_TIME }\n    : { startType: StartTimeValue.AT_EPOCH, epoch: startEpoch }\n\n  return {\n    sellAmount: partSellAmount.mul(numberOfParts),\n    buyAmount: minPartLimit.mul(numberOfParts),\n    startTime,\n    numberOfParts,\n    timeBetweenParts,\n    durationOfPart,\n    ...rest,\n  }\n}\n","import { ConditionalOrderRegistry } from '../ConditionalOrderFactory'\nimport { TWAP_ADDRESS, Twap } from './Twap'\nexport * from './Twap'\n\nexport const DEFAULT_CONDITIONAL_ORDER_REGISTRY: ConditionalOrderRegistry = {\n  // Registry of all known order types\n  [TWAP_ADDRESS]: (params) => Twap.fromParams(params),\n}\n"],"names":["SupportedChainId","ENVS_LIST","DEFAULT_COW_API_CONTEXT","env","chainId","MAINNET","CowError","Error","constructor","message","error_code","super","this","logPrefix","DEFAULT_IPFS_READ_URI","DEFAULT_IPFS_WRITE_URI","GPv2Settlement","JSON","parse","BUY_ETH_ADDRESS","EXTENSIBLE_FALLBACK_HANDLER","COMPOSABLE_COW","ALL_SUPPORTED_CHAIN_IDS","GOERLI","GNOSIS_CHAIN","MUMBAI","COW_PROTOCOL_SETTLEMENT_CONTRACT_ADDRESS","reduce","acc","_extends","address","EXTENSIBLE_FALLBACK_HANDLER_CONTRACT_ADDRESS","COMPOSABLE_COW_CONTRACT_ADDRESS","transformOrder","order","ethflowData","userValidTo","validTo","owner","onchainUser","sellToken","transformEthFlowOrder","dto","executedFeeAmount","executedSurplusFee","totalFee","addTotalFeeToOrder","OrderBookApiError","response","body","statusText","STATUS_CODES_TO_RETRY","DEFAULT_BACKOFF_OPTIONS","numOfAttempts","maxDelay","Infinity","jitter","retry","error","includes","status","DEFAULT_LIMITER_OPTIONS","tokensPerInterval","interval","getResponseBody","async","contentType","headers","get","toLowerCase","startsWith","json","text","console","undefined","request","baseUrl","path","query","method","rateLimiter","backoffOpts","url","init","stringify","Accept","backOff","removeTokens","fetch","responseBody","Promise","reject","ORDER_BOOK_PROD_CONFIG","ORDER_BOOK_STAGING_CONFIG","cleanObjectFromUndefinedValues","obj","Object","keys","key","val","OrderBookApi","context","RateLimiter","limiterOpts","getVersion","contextOverride","getTrades","orderUid","URLSearchParams","getOrders","offset","limit","toString","then","orders","map","getTxOrders","txHash","getOrder","getOrderMultiEnv","getContextWithOverride","otherEnvs","filter","i","attemptsCount","fallback","nextEnv","catch","getQuote","requestBody","sendSignedOrderCancellations","sendOrder","getNativePrice","tokenAddress","getTotalSurplus","getAppData","appDataHash","uploadAppData","fullAppData","getSolverCompetition","auctionIdorTx","getOrderLink","getApiBaseUrls","baseUrls","params","BuyTokenDestination","EcdsaSigningScheme","OnchainOrderData","OrderCancellationError","OrderClass","OrderKind","OrderPostError","OrderQuoteSideKindBuy","OrderQuoteSideKindSell","OrderStatus","PriceEstimationError","PriceQuality","ReplaceOrderError","SellTokenSource","SigningScheme","placementError","errorType","_t","_t2","_t3","_","t","TOTALS_QUERY","gql","LAST_DAYS_VOLUME_QUERY","LAST_HOURS_VOLUME_QUERY","SUBGRAPH_BASE_URL","SUBGRAPH_PROD_CONFIG","SUBGRAPH_STAGING_CONFIG","SubgraphApi","API_NAME","runQuery","totals","days","hours","variables","getEnvConfigs","getSignUtils","import","OrderSigningUtils","static","signer","signOrder","signOrderCancellation","orderUids","signOrderCancellations","getDomain","_TypedDataEncoder","hashDomain","Order","name","type","ProofLocation","PollResultCode","_abi","inputs","internalType","stateMutability","anonymous","indexed","components","outputs","ComposableCoW__factory","utils","Interface","signerOrProvider","Contract","abi","ExtensibleFallbackHandler__factory","global","self","window","getGlobal","module","exports","default","bind","Headers","Request","Response","OrderBalance","ORDER_TYPE_FIELDS","CANCELLATIONS_TYPE_FIELDS","ORDER_TYPE_HASH","ethers","id","join","timestamp","getTime","hashify","h","padStart","hexZeroPad","normalizeBuyTokenBalance","balance","ERC20","EXTERNAL","INTERNAL","normalizeOrder","_a","_b","receiver","constants","AddressZero","assign","sellTokenBalance","appData","buyTokenBalance","hashTypedData","domain","types","data","hash","hashOrder","hashOrderCancellation","hashOrderCancellations","OrderCancellations","ORDER_UID_LENGTH","computeOrderUid","packOrderUidParams","orderDigest","solidityPack","extractOrderUidParams","bytes","arrayify","length","view","DataView","buffer","hexlify","subarray","getAddress","getUint32","normalizeInteraction","interaction","value","callData","normalizeInteractions","interactions","isTypedDataSigner","isJsonRpcProvider","provider","__awaiter","thisArg","_arguments","P","generator","resolve","fulfilled","step","next","e","rejected","result","done","apply","EIP1271_MAGICVALUE","hexDataSlice","PRE_SIGNED","InteractionStage","ecdsaSignTypedData","scheme","signature","EIP712","_signTypedData","ETHSIGN","signMessage","joinSignature","splitSignature","encodeEip1271SignatureData","verifier","decodeEip1271SignatureData","arrayifiedSignature","slice","FLAG_MASKS","kind","options","SELL","BUY","partiallyFillable","signingScheme","EIP1271","PRESIGN","encodeFlag","flag","index","findIndex","search","decodeFlag","numberFlags","BigNumber","from","toNumber","Math","clz32","mask","decoded","encodeSigningScheme","decodeSigningScheme","flags","encodeOrderFlags","decodeOrderFlags","encodeTradeFlags","decodeTradeFlags","encodeSignatureData","sig","decodeSignatureOwner","verifyTypedData","verifyMessage","encodeTrade","tokens","executedAmount","tradeFlags","o","sellTokenIndex","buyTokenIndex","buyToken","sellAmount","buyAmount","feeAmount","TokenRegistry","_tokens","_tokenMap","addresses","token","tokenIndex","push","SettlementEncoder","_trades","_interactions","PRE","INTRA","POST","_orderRefunds","filledAmounts","preSignatures","trades","encodedOrderRefunds","settlement","verifyingContract","iface","functionName","target","encodeFunctionData","clearingPrices","prices","price","signEncodeTrade","tradeExecution","encodeInteraction","stage","encodeOrderRefunds","orderRefunds","every","isHexString","encodedSettlement","encoder","decodeOrder","trade","max","Environment","LIMIT_CONCURRENT_REQUESTS","apiUrl","environment","network","Dev","Prod","QuotePriceQuality","GetQuoteErrorType","apiKind","apiSigningScheme","call","route","ok","apiError","quote","sellAmountBeforeFee","sellAmountAfterFee","buyAmountAfterFee","Api","baseUrlOrEnv","apiCallParams","estimateTradeAmount","amount","side","priceQuality","FAST","placeOrder","normalizedOrder","getExecutedSellAmount","uid","executedSellAmount","SALT","formatBytes32String","DEPLOYER_CONTRACT","CONTRACT_NAMES","authenticator","tradeSimulator","deterministicDeploymentAddress","bytecode","deploymentArguments","contractInterface","deployData","hexConcat","encodeDeploy","getCreate2Address","keccak256","slot","defaultAbiCoder","encode","sub","IMPLEMENTATION_STORAGE_SLOT","OWNER_STORAGE_SLOT","implementationAddress","proxy","implementation","decode","getStorageAt","ownerAddress","EIP173_PROXY_ABI","proxyInterface","contract","VAULT_INTERFACE","grantRequiredRoles","authorizer","vaultAddress","vaultRelayerAddress","functions","grantRole","solidityKeccak256","getSighash","ERC20_BALANCE_VALUES","EXTERNAL_BALANCE_VALUES","INTERNAL_BALANCE_VALUES","SELL_KIND_VALUES","BUY_KIND_VALUES","CONDITIONAL_ORDER_PARAMS_ABI","DEFAULT_TOKEN_FORMATTER","isExtensibleFallbackHandler","handler","isComposableCow","getDomainVerifier","safe","connect","callStatic","domainVerifiers","createSetDomainVerifierTx","createInterface","encodeParams","decodeParams","encoded","salt","staticInput","isValidAbi","values","getBlockInfo","block","getBlock","blockNumber","number","blockTimestamp","formatEpoch","epoch","Date","toISOString","balanceToString","kindToString","fromStructToOrder","Number","composableCowInterfaceCache","composableCowContractCache","getComposableCowInterface","getComposableCow","chain","orderBookCache","ConditionalOrder","hasOffChainInput","randomBytes","isAddress","hexDataLength","transformDataToStruct","assertIsValid","isValidResult","isValid","reason","createCalldata","composableCow","paramsStruct","encodeStaticInput","contextArgsAbi","factoryArgs","argsType","args","removeCalldata","serialize","ctx","isSingleOrder","HashZero","leaf","offChainInput","encodeStaticInputHelper","orderDataTypes","orderbookApiConfig","DONT_TRY_AGAIN","pollResult","pollValidate","isAuthorized","getTradeableOrderWithSignature","orderBookApi","_computeOrderUid","handlePollFailedAlreadyPresent","TRY_NEXT_BLOCK","SUCCESS","UNEXPECTED_ERROR","singleOrders","cabinet","s","callback","recoveredHandler","d","_excluded","CONDITIONAL_ORDER_LEAF_ABI","PAYLOAD_EMITTED_ABI","Multiplexer","root","location","PRIVATE","tree","orderKey","hasOwnProperty","orderTypeRegistry","orderType","getOrGenerateTree","reviver","k","v","_v$orderKey","orderData","_objectWithoutPropertiesLoose","OrderConstructor","m","toJSON","conditionalOrder","add","reset","remove","update","updater","getById","getByIndex","orderIds","StandardMerkleTree","of","uploader","_this","EMITTED","encodeToABI","SWARM","WAKU","IPFS","encodeToJSON","p","offChainInputFn","proof","dumpProofs","dumpProofsAndParams","getProofs","entries","idx","x","getProof","conditionalOrderClass","ConditionalOrderFactory","registry","knownOrderTypes","fromParams","factory","TWAP_ADDRESS","CURRENT_BLOCK_TIMESTAMP_FACTORY_ADDRESS","MAX_UINT32","pow","MAX_FREQUENCY","TWAP_STRUCT_ABI","DurationType","StartTimeValue","DEFAULT_START_TIME","startType","AT_MINING_TIME","DEFAULT_DURATION_OF_PART","durationType","AUTO","Twap","deserialize","t0","gt","startTime","numberOfParts","timeBetweenParts","durationOfPart","Zero","AT_EPOCH","gte","lt","One","lte","LIMIT_DURATION","duration","rawCabinetEpoch","cabinetEpoch","endTimestamp","startTimestamp","mul","blockInfo","TRY_AT_EPOCH","expirationTimestamp","err","_err$message","_err$message2","_orderUid","_order","expireTime","currentPartNumber","floor","nextPartStartTime","twapSerialized","deserializeHelper","struct","transformStructToData","startTimeFormatted","durationOfPartFormatted","details","rest","partSellAmount","minPartLimit","isZero","div","n","span","startEpoch","_excluded2","DEFAULT_CONDITIONAL_ORDER_REGISTRY"],"mappings":"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CACEK,aAAc,yBACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,OACNC,KAAM,SAER,CACEK,aAAc,OACdN,KAAM,WACNC,KAAM,SAGVD,KAAM,oBACNW,QAAS,GACTJ,gBAAiB,aACjBN,KAAM,YAER,CACEI,OAAQ,GACRL,KAAM,kBACNW,QAAS,CACP,CACEL,aAAc,UACdN,KAAM,GACNC,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEC,aAAc,UACdN,KAAM,QACNC,KAAM,WAER,CACES,WAAY,CACV,CACEJ,aAAc,6BACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,QACdN,KAAM,cACNC,KAAM,UAGVK,aAAc,kDACdN,KAAM,SACNC,KAAM,SAER,CACEK,aAAc,QACdN,KAAM,gBACNC,KAAM,SAER,CACEK,aAAc,YACdN,KAAM,QACNC,KAAM,cAGVD,KAAM,iCACNW,QAAS,CACP,CACED,WAAY,CACV,CACEJ,aAAc,kBACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,kBACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,WACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,aACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,SACdN,KAAM,UACNC,KAAM,UAER,CACEK,aAAc,UACdN,KAAM,UACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,YACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,OACNC,KAAM,WAER,CACEK,aAAc,OACdN,KAAM,oBACNC,KAAM,QAER,CACEK,aAAc,UACdN,KAAM,mBACNC,KAAM,WAER,CACEK,aAAc,UACdN,KAAM,kBACNC,KAAM,YAGVK,aAAc,wBACdN,KAAM,QACNC,KAAM,SAER,CACEK,aAAc,QACdN,KAAM,YACNC,KAAM,UAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEI,OAAQ,CACN,CACEK,WAAY,CACV,CACEJ,aAAc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"}